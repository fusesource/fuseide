<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>File2</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-Facebook.html" title="Facebook"><link rel="next" href="IDU-Flatpack.html" title="Flatpack"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-File2"></a>File2</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_FileComponentCamel20onwards"></a>File Component - Apache Camel 2.0 onwards</h2></div></div></div><p>The File component provides access to file systems, allowing files to be processed by
            any other Apache Camel <a href="IDU-Components.html" class="olink">Components</a> or messages from
            other components to be saved to disk.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_URIformat"></a>URI format</h2></div></div></div><pre class="programlisting">file:directoryName[?options]</pre><p>or</p><pre class="programlisting">file://directoryName[?options]</pre><p>Where <span class="bold"><strong>directoryName</strong></span> represents the underlying file
            directory.</p><p>You can append query options to the URI in the following format,
                <code class="literal">?option=value&amp;option=value&amp;...</code>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Apache Camel only supports endpoints configured with a starting directory. So the
                    <span class="bold"><strong>directoryName</strong></span> must be a directory. If you want
                to consume a single file only, you can use the <span class="bold"><strong>fileName</strong></span> option, e.g. by setting
                    <code class="literal">fileName=thefilename</code>. Also, the starting directory must not
                contain dynamic expressions with ${ } placeholders. Again use the
                    <code class="literal">fileName</code> option to specify the dynamic part of the
                filename.</p></td></tr></table></div><p></p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning: Avoid reading files currently being written by another application"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="imagesdb/warning.png"></td><th align="left">Avoid reading files currently being written by another application</th></tr><tr><td align="left" valign="top"><p>Beware the JDK File IO API is a bit limited in detecting whether another
                application is currently writing/copying a file. And the implementation can be
                different depending on OS platform as well. This could lead to that Apache Camel thinks
                the file is not locked by another process and start consuming it. Therefore you have
                to do your own investigation as to what suits your environment. To help with this,
                Apache Camel provides different <code class="literal">readLock</code> options and the
                    <code class="code">doneFileName</code> option that you can use. Also, see the section <a class="xref" href="IDU-File2.html#IDU-File2_HSH_Consumingfilesfromfolderswhereothersdropfilesdirectly" title="Consuming files from folders where others drop files directly">Consuming files from folders where others drop files directly</a>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e80266"></a>Camel on EAP deployment</h2></div></div></div><p>This component is supported by the Camel on EAP (Wildfly Camel) framework, which
            offers a simplified deployment model on the Red Hat JBoss Enterprise Application Platform (JBoss EAP) container.
 </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_URIOptions"></a>URI Options</h2></div></div></div><table id="d0e80275"><tr>
                <th> Name </th>
                <th> Default Value </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">autoCreate</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td> Automatically create missing directories in the file's path name. For the file
                    consumer, that means creating the starting directory. For the file producer, it
                    means the directory where the files should be written. </td>
            </tr><tr>
                <td><code class="literal">bufferSize</code>
                </td>
                <td> 128kb </td>
                <td> Write buffer sized in bytes. </td>
            </tr><tr>
                <td><code class="literal">fileName</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Use <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> such as <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> to dynamically set the
                    filename. For consumers, it's used as a filename filter. For producers, it's
                    used to evaluate the filename to write. If an expression is set, it take
                    precedence over the <code class="literal">CamelFileName</code> header. (<span class="bold"><strong>Note:</strong></span> The header itself can also be an <a class="link" href="Expression" target="_top">Expression</a>). The expression options support both
                        <code class="literal">String</code> and <code class="literal">Expression</code> types. If the
                    expression is a <code class="literal">String</code> type, it is <span class="bold"><strong>always</strong></span> evaluated using the <a class="link" href="File Language" target="_top">File
                        Language</a>. If the expression is an <code class="literal">Expression</code> type,
                    the specified <code class="literal">Expression</code> type is used - this allows you, for
                    instance, to use <a class="link" href="OGNL" target="_top">OGNL</a> expressions. For the consumer,
                    you can use it to filter filenames, so you can for instance consume today's file
                    using the <a class="link" href="File Language" target="_top">File Language</a> syntax:
                        <code class="literal">mydata-${date:now:yyyyMMdd}.txt</code>. From <span class="bold"><strong>Camel 2.11</strong></span> onwards the producers support the
                        <code class="literal">CamelOverruleFileName</code> header which takes precedence over
                    any existing <code class="literal">CamelFileName</code> header; the
                        <code class="literal">CamelOverruleFileName</code> is a header that is used only once,
                    and makes it easier as this avoids to temporary store
                        <code class="literal">CamelFileName</code> and have to restore it afterwards. </td>
            </tr><tr>
                <td><code class="literal">flatten</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td> Flatten is used to flatten the file name path to strip any leading paths, so
                    it's just the file name. This allows you to consume recursively into
                    sub-directories, but when you eg write the files to another directory they will
                    be written in a single directory. Setting this to <code class="literal">true</code> on the
                    producer enforces that any file name received in
                        <code class="literal">CamelFileName</code> header will be stripped for any leading
                    paths. </td>
            </tr><tr>
                <td><code class="literal">charset</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.5:</strong></span> this option is used to specify the
                    encoding of the file, and camel will set the Exchange property with
                    Exchange.CHARSET_NAME with the value of this option. </td>
            </tr><tr>
                <td><code class="literal">copyAndDeleteOnRenameFail</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td><span class="bold"><strong>Camel 2.9</strong></span>: whether to fallback and do a copy
                    and delete file, in case the file could not be renamed directly. This option is
                    not available for the <a href="IDU-FTP2.html" class="olink">FTP</a> component. </td>
            </tr><tr>
                <td><code class="code">renameUsingCopy</code></td>
                <td><code class="code">false</code></td>
                <td><p><span class="bold"><strong>Camel 2.13.1:</strong></span> Perform rename operations using a copy and
                        delete strategy. This is primarily used in environments where the regular
                        rename operation is unreliable (e.g. across different file systems or
                        networks). This option takes precedence over the
                            <code class="code">copyAndDeleteOnRenameFail</code> parameter that will automatically
                        fall back to the copy and delete strategy, but only after additional
                        delays.</p></td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Consumeronly"></a>Consumer only</h2></div></div></div><table id="d0e80471"><tr>
                <th> Name </th>
                <th> Default Value </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">initialDelay</code>
                </td>
                <td><code class="literal">1000</code>
                </td>
                <td> Milliseconds before polling the file/directory starts. </td>
            </tr><tr>
                <td><code class="literal">delay</code>
                </td>
                <td><code class="literal">500</code>
                </td>
                <td> Milliseconds before the next poll of the file/directory. </td>
            </tr><tr>
                <td><code class="literal">useFixedDelay</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td> Set to <code class="literal">true</code> to use fixed delay between pools, otherwise
                    fixed rate is used. See <a class="link" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_top">ScheduledExecutorService</a> in JDK for details.</td>
            </tr><tr>
                <td><code class="literal">runLoggingLevel</code>
                </td>
                <td><code class="literal">TRACE</code>
                </td>
                <td><span class="bold"><strong>Camel 2.8:</strong></span> The consumer logs a start/complete
                    log line when it polls. This option allows you to configure the logging level
                    for that. </td>
            </tr><tr>
                <td><code class="literal">recursive</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td> If a directory, will look for files in all the sub-directories as well. </td>
            </tr><tr>
                <td><code class="literal">delete</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td> If <code class="literal">true</code>, the file will be deleted after it is processed
                    successfully.</td>
            </tr><tr>
                <td><code class="literal">noop</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td> If <code class="literal">true</code>, the file is not moved or deleted in any way. This
                    option is good for readonly data, or for <a class="link" href="http://camel.apache.org/etl-example.html" target="_top">ETL</a> type
                    requirements. If <code class="literal">noop=true</code>, Apache Camel will set
                        <code class="literal">idempotent=true</code> as well, to avoid consuming the same
                    files over and over again. </td>
            </tr><tr>
                <td><code class="literal">preMove</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Use <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> such as <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> to dynamically set the filename
                    when moving it <span class="bold"><strong>before</strong></span> processing. For example
                    to move in-progress files into the <code class="literal">order</code> directory set this
                    value to <code class="literal">order</code>. </td>
            </tr><tr>
                <td><code class="literal">move</code>
                </td>
                <td><code class="literal">.camel</code>
                </td>
                <td> Use <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> such as <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> to dynamically set the filename
                    when moving it <span class="bold"><strong>after</strong></span> processing. To move files
                    into a <code class="literal">.done</code> subdirectory just enter
                    <code class="literal">.done</code>. </td>
            </tr><tr>
                <td><code class="literal">moveFailed</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Use <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> such as <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> to dynamically set the filename
                    when moving <span class="bold"><strong>failed files after</strong></span> processing. To
                    move files into a <code class="literal">error</code> subdirectory just enter
                        <code class="literal">error</code>. <span class="bold"><strong>Note:</strong></span> When moving
                    the files to another location it can/will <span class="bold"><strong>handle</strong></span> the error when you move it to another location so
                    Apache Camel cannot pick up the file again. </td>
            </tr><tr>
                <td><code class="literal">include</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Is used to include files, if filename matches the regex pattern (matching is
                    case in-sensitive from <span class="bold"><strong>Camel 2.17</strong></span>
                    onwards).</td>
            </tr><tr>
                <td><code class="literal">exclude</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Is used to exclude files, if filename matches the regex pattern (matching is
                    case in-sensitive from <span class="bold"><strong>Camel 2.17</strong></span>
                    onwards).</td>
            </tr><tr>
                <td><code class="literal">antInclude</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.10:</strong></span> Ant style filter inclusion, for
                    example
                        <code class="literal">antInclude=\*</code><code class="literal">{}*/*{}</code><code class="literal">.txt</code>.
                    Multiple inclusions may be specified in comma-delimited format. See <a class="xref" href="IDU-File2.html#IDU-File2_HSH_FilteringusingANTpathmatcher" title="Filtering using ANT path matcher">Filtering using ANT path matcher</a> for more details about
                    ant path filters. </td>
            </tr><tr>
                <td><code class="literal">antExclude</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.10:</strong></span> Ant style filter exclusion. If both
                        <code class="literal">antInclude</code> and <code class="literal">antExclude</code> are used,
                        <code class="literal">antExclude</code> takes precedence over
                        <code class="literal">antInclude</code>. Multiple exclusions may be specified in
                    comma-delimited format. See <a class="xref" href="IDU-File2.html#IDU-File2_HSH_FilteringusingANTpathmatcher" title="Filtering using ANT path matcher">Filtering using ANT path matcher</a> for more details about ant path filters. </td>
            </tr><tr>
                <td><code class="literal">antFilterCaseSensitive</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td><span class="bold"><strong>Camel 2.11:</strong></span> Ant style filter which is case
                    sensitive or not. </td>
            </tr><tr>
                <td align="left" valign="top">
                    <p><code class="code">filterDirectory</code></p>
                </td>
                <td align="left" valign="top"></td>
                <td align="left" valign="top">
                    <p><span class="bold"><strong>Camel 2.18:</strong></span> Filters the directory based on Simple language. For example
                        to filter on current date you can use a simple date pattern such as
                        $date:now:yyyMMdd</p>
                </td>
            </tr><tr>
                <td align="left" valign="top">
                    <p><code class="code">filterFile</code></p>
                </td>
                <td align="left" valign="top"></td>
                <td align="left" valign="top">
                    <p><span class="bold"><strong>Camel 2.18:</strong></span> Filters the file based on Simple language. For example to
                        filter on file size you can use $file:size 5000</p>
                </td>
            </tr><tr>
                <td><code class="literal">idempotent</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td> Option to use the <span class="phrase">Idempotent
                        Consumer</span> EIP pattern to let Apache Camel skip already
                    processed files. Will by default use a memory based LRUCache that holds 1000
                    entries. If <code class="literal">noop=true</code> then idempotent will be enabled as well
                    to avoid consuming the same files over and over again. </td>
            </tr><tr>
                <td><code class="literal">idempotentKey</code>
                </td>
                <td><code class="literal">Expression</code>
                </td>
                <td><span class="bold"><strong>Camel 2.11:</strong></span> To use a custom idempotent key. By
                    default the absolute path of the file is used. You can use the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>, for example to use the file
                    name and file size, you can do: idempotentKey=$-$
                    . </td>
            </tr><tr>
                <td><code class="literal">idempotentRepository</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Pluggable repository as a <a class="link" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/IdempotentRepository.html" target="_top">org.apache.camel.processor.idempotent.MessageIdRepository</a> class.
                    Will by default use <code class="literal">MemoryMessageIdRepository</code> if none is
                    specified and <code class="literal">idempotent</code> is <code class="literal">true</code>. </td>
            </tr><tr>
                <td><code class="literal">inProgressRepository</code>
                </td>
                <td><code class="literal">memory</code>
                </td>
                <td> Pluggable in-progress repository as a <a class="link" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/IdempotentRepository.html" target="_top">org.apache.camel.processor.idempotent.MessageIdRepository</a> class. The
                    in-progress repository is used to account the current in progress files being
                    consumed. By default a memory based repository is used. </td>
            </tr><tr>
                <td><code class="literal">filter</code></td>
                <td><code class="literal">null</code>
                </td>
                <td> Pluggable filter as a
                        <code class="literal">org.apache.camel.component.file.GenericFileFilter</code> class.
                    Will skip files if filter returns <code class="literal">false</code> in its
                        <code class="literal">accept()</code> method. Apache Camel also ships with an <span class="bold"><strong>ANT path matcher</strong></span> filter in the
                        <code class="literal">camel-spring</code> component. More details in section below.
                </td>
            </tr><tr>
                <td><code class="literal">shuffle</code></td>
                <td><code class="literal">false</code>
                </td>
                <td>
                    <span class="bold"><strong>Camel 2.16:</strong></span> To shuffle the list of files (sort
                    in random order) </td>
            </tr><tr>
                <td><code class="literal">sorter</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Pluggable sorter as a <a class="link" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Comparator.html" target="_top">java.util.Comparator&lt;org.apache.camel.component.file.GenericFile&gt;</a>
                    class. </td>
            </tr><tr>
                <td><code class="literal">sortBy</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> Built-in sort using the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>.
                    Supports nested sorts, so you can have a sort by file name and as a 2nd group
                    sort by modified date. See sorting section below for details. </td>
            </tr><tr>
                <td><code class="literal">readLock</code></td>
                <td><code class="literal">none</code></td>
                <td>
                    <p> Used by consumer, to only poll the files if it has exclusive read-lock on
                        the file (i.e. the file is not in-progress or being written). Apache Camel will
                        wait until the file lock is granted.</p>
                    <p>The <code class="code">readLock</code> option supports the following built-in
                        strategies: </p>
                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">none</code> is for no read locks at all.</p></li><li class="listitem"><p><code class="literal">changed</code> uses a length/modification timestamp to
                                detect whether the file is currently being copied or not. Will wait
                                at least 1 second to determine this, so this option cannot consume
                                files as fast as the others, but can be more reliable as the JDK IO
                                API cannot always determine whether a file is currently being used
                                by another process. The <code class="code">readLockCheckInterval</code> option
                                can be used to set the check frequency.</p></li><li class="listitem"><p><code class="code">markerFile</code> Camel creates a marker file,
                                        <code class="code"><em class="replaceable"><code>fileName</code></em>.camelLock</code>.
                                and then holds a lock on it. This option is not available for the
                                FTP component</p></li><li class="listitem"><p><code class="code">fileLock</code> is for using
                                    <code class="code">java.nio.channels.FileLock</code>. This approach should be
                                avoided when accessing a remote file system via a mount/share unless
                                that file system supports distributed file locks.</p></li><li class="listitem"><p><code class="code">rename</code> is for using a try to rename the file as a
                                test if we can get exclusive read-lock. </p></li><li class="listitem"><p><code class="code">idempotent</code> (<span class="bold"><strong>Camel
                                    2.16</strong></span>) is for using a
                                    <code class="code">idempotentRepository</code> as the read-lock. This allows
                                you to use read locks that support clustering, if the idempotent
                                repository implementation supports that.</p></li></ul></div>
           <p><span class="bold"><strong>Note:</strong></span> In cases where a foreign program is writing
                        the files, Red Hat recommends using the <code class="code">doneFileName</code> option
                        instead of the <code class="code">readLock</code> option.</p>
                    <p><span class="bold"><strong>Warning:</strong></span> Most of the read lock strategies
                        are not suitable for use in clustered mode. That is, you cannot have
                        multiple consumers attempting to read the same file in the same directory.
                        In this case, the read locks will not function reliably. The idempotent read
                        lock supports clustered reliably if you use a cluster aware idempotent
                        repository implementation such as from the Hazelcast Component.</p>
              </td>
             
            </tr><tr>
                <td><code class="literal">readLockTimeout</code>
                </td>
                <td><code class="literal">0</code> (for FTP, <code class="code">2000</code>)</td>
                <td>Optional timeout in milliseconds for the read-lock, if supported by the
                    read-lock. If the read-lock could not be granted and the timeout triggered, then
                    Apache Camel will skip the file. At next poll Apache Camel, will try the file again, and
                    this time maybe the read-lock could be granted. Currently
                        <code class="literal">fileLock</code>, <code class="literal">changed</code> and
                        <code class="literal">rename</code> support the timeout.</td>
            </tr><tr>
                <td>
                    <code class="literal">readLockCheckInterval</code>
                </td>
                <td>
                    <code class="literal">1000</code> (for FTP, <code class="code">5000</code>)</td>
                <td>
                    <span class="bold"><strong>Camel 2.6:</strong></span> Interval in millis for the
                    read-lock, if supported by the read lock. This interval is used for sleeping
                    between attempts to acquire the read lock. For example when using the
                        <code class="literal">changed</code> read lock, you can set a higher interval period
                    to cater for <span class="emphasis"><em>slow writes</em></span>. The default of 1 sec. may be
                        <span class="emphasis"><em>too fast</em></span> if the producer is very slow writing the file.
                </td>
            </tr><tr>
                <td><code class="literal">readLockMinLength</code>
                </td>
                <td><code class="literal">1</code>
                </td>
                <td><span class="bold"><strong>Camel 2.10.1:</strong></span> This option applied only for
                        <code class="literal">readLock=changed</code>. This option allows you to configure a
                    minimum file length. By default Camel expects the file to contain data, and thus
                    the default value is 1. You can set this option to zero, to allow consuming
                    zero-length files. </td>
            </tr><tr>
                <td><code class="literal">readLockLoggingLevel</code>
                </td>
                <td><code class="literal">WARN</code>
                </td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> Logging level used when a read lock
                    could not be acquired. By default a WARN is logged. You can change this level,
                    for example to OFF to not have any logging. This option is only applicable for
                    readLock of types: changed, fileLock, rename. </td>
            </tr><tr>
                <td><code class="literal">readLockMarkerFile</code></td>
                <td><code class="code">true</code></td>
                <td><p><span class="bold"><strong>Camel 2.14:</strong></span> Whether to use marker file
                        with the changed, rename, or exclusive read lock types. By default a marker
                        file is used as well to guard against other processes picking up the same
                        files. This behavior can be turned off by setting this option to false. For
                        example if you do not want to write marker files to the file systems by the
                        Camel application.</p></td>
            </tr><tr>
                <td><code class="literal">readLockRemoveOnRollback</code></td>
                <td><code class="code">true</code></td>
                <td>
                    <p><span class="bold"><strong>Camel 2.16:</strong></span> This option applies only for
                            <code class="code">readLock=idempotent</code>. Specifies whether to remove the file
                        name entry from the idempotent repository when file processing fails and a
                        rollback occurs. If <code class="code">false</code>, the file name entry is confirmed (as
                        if the file did a commit).</p>
                </td>
            </tr><tr>
                <td><code class="literal">readLockRemoveOnCommit</code></td>
                <td><code class="code">false</code></td>
                <td>
                    <p><span class="bold"><strong>Camel 2.16:</strong></span> This option applies only for
                            <code class="code">readLock=idempotent</code>. Specifies whether to remove the file
                        name entry from the idempotent repository when file processing succeeds and
                        a commit occurs. By default, the entry is <span class="emphasis"><em>not</em></span> removed
                        which ensures that a race-condition will not occur if another active node
                        attempts to grab the file. In this case, it is recommended that you
                        configure an eviction strategy on the idempotent repository, so that the
                        file name entry is evicted after <span class="emphasis"><em>X</em></span> minutes (after the
                        risk of a race condition is over).</p>
                </td>
            </tr><tr>
                <td><code class="literal">readLockDeleteOrphanLockFiles</code></td>
                <td><code class="code">true</code></td>
                <td>
                    <p><span class="bold"><strong>Camel 2.16:</strong></span> This option applies only for
                            <code class="code">readLock=markerFile</code>. On startup, specifies whether or not
                        to delete orphan read lock files, which might have been left on the file
                        system if Camel was not properly shut down (JVM crash). If
                            <code class="code">false</code>, an orphaned lock file could potentially block Camel
                        from attempting to pick up the corresponding file.</p>
                </td>
            </tr><tr>
                <td><code class="literal">directoryMustExist</code></td>
                <td></td>
                <td><p><span class="bold"><strong>Camel 2.5:</strong></span> Similar to
                            <code class="code">startingDirectoryMustExist</code> but this applies during polling
                        recursive sub directories.</p></td>
            </tr><tr>
                <td><code class="literal">doneFileName</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.6:</strong></span> If provided, Camel will only consume
                    files if a <span class="emphasis"><em>done</em></span> file exists. This option configures what
                    file name to use. Either you can specify a fixed name. Or you can use dynamic
                    placeholders. The <span class="emphasis"><em>done</em></span> file is <span class="bold"><strong>always</strong></span> expected in the same folder as the original file. See
                        <span class="emphasis"><em>using done file</em></span> and <span class="emphasis"><em>writing done
                        file</em></span> sections for examples. Note: In case of the foreign program writing the files, Red Hat recommend you to use the <code class="code">doneFileName</code> option.</td>
             
            </tr><tr>
                <td><code class="literal">exclusiveReadLockStrategy</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td>Pluggable read-lock as a
                        <code class="literal">org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy</code>
                    implementation.</td>
            </tr><tr>
                <td><code class="literal">maxMessagesPerPoll</code>
                </td>
                <td><code class="literal">0</code>
                </td>
                <td>An integer that defines the maximum number of messages to gather per poll. By
                    default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid
                    having the server read thousands of files as it starts up. Set a value of 0 or
                    negative to disabled it.</td>
            </tr><tr>
                <td><code class="literal">eagerMaxMessagesPerPoll</code></td>
                <td><code class="code">true</code></td>
                <td><p><span class="bold"><strong>Camel 2.9.3:</strong></span> Allows for controlling
                        whether the limit from <code class="code">maxMessagesPerPoll</code> is eager or not. If
                        eager then the limit is during the scanning of files. Where as false would
                        scan all files, and then perform sorting. Setting this option to false
                        allows for sorting all files first, and then limit the poll. Mind that this
                        requires a higher memory usage as all file details are in memory to perform
                        the sorting.</p></td>
            </tr><tr>
                <td><code class="literal">minDepth</code>
                </td>
                <td> 0 </td>
                <td><span class="bold"><strong>Camel 2.8</strong></span>: The minimum depth to start
                    processing when recursively processing a directory. Using
                        <code class="literal">minDepth=1</code> means the base directory. Using
                        <code class="literal">minDepth=2</code> means the first sub directory. This option is
                        <span class="bold"><strong>not</strong></span> supported by <a href="IDU-FTP2.html" class="olink">FTP</a> consumer. </td>
            </tr><tr>
                <td><code class="literal">maxDepth</code>
                </td>
                <td><code class="literal">Integer.MAX_VALUE</code>
                </td>
                <td><span class="bold"><strong>Camel 2.8:</strong></span> The maximum depth to traverse when
                    recursively processing a directory. This option is <span class="bold"><strong>not</strong></span> supported by <a href="IDU-FTP2.html" class="olink">FTP</a>
                    consumer. </td>
            </tr><tr>
                <td><code class="literal">processStrategy</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td>A pluggable
                        <code class="literal">org.apache.camel.component.file.GenericFileProcessStrategy</code>
                    allowing you to implement your own <code class="literal">readLock</code> option or
                    similar. Can also be used when special conditions must be met before a file can
                    be consumed, such as a special <span class="emphasis"><em>ready</em></span> file exists. If this
                    option is set then the <code class="literal">readLock</code> option does not apply.</td>
            </tr><tr>
                <td><code class="literal">startingDirectoryMustExist</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td>Whether the starting directory must exist. Mind that the <code class="code">autoCreate</code>
                    option is default enabled, which means the starting directory is normally
                    auto-created if it doesn't exist. You can disable <code class="code">autoCreate</code> and
                    enable this to ensure the starting directory must exist. Will throw an
                    exception, if the directory doesn't exist. </td>
            </tr><tr>
                <td><code class="literal">pollStrategy</code></td>
                <td><code class="code">null</code></td>
                <td><p>A pluggable <code class="code">org.apache.camel.spi.PollingConsumerPollStrategy</code>
                        allowing you to provide your custom implementation to control error handling
                        usually occurred during the poll operation before an <code class="code">Exchange</code>
                        have been created and being routed in Camel. In other words, the error
                        occurred while the polling was gathering information, for instance access to
                        a file network failed so Camel cannot access it to scan for files. The
                        default implementation will log the caused exception at <code class="code">WARN</code>
                        level and ignore it.</p></td>
            </tr><tr>
                <td><code class="literal">sendEmptyMessageWhenIdle</code></td>
                <td><code class="code">false</code></td>
                <td><p><span class="bold"><strong>Camel 2.9:</strong></span> If the polling consumer did
                        not poll any files, you can enable this option to send an empty message (no
                        body) instead.</p></td>
            </tr><tr>
                <td><code class="literal">consumer.bridgeErrorHandler</code></td>
                <td><code class="code">false</code></td>
                <td><p><span class="bold"><strong>Camel 2.10:</strong></span> Allows for bridging the
                        consumer to the Camel routing Error Handler, which mean any exceptions
                        occurred while trying to pick up files, or the like, will now be processed
                        as a message and handled by the routing Error Handler. By default the
                        consumer will use the <code class="code">org.apache.camel.spi.ExceptionHandler</code> to
                        deal with exceptions, that by default will be logged at
                            <code class="code">WARN</code>/<code class="code">ERROR</code> level and ignored. See further
                        below on this page fore more details, at section How to use the Camel error
                        handler to deal with exceptions triggered outside the routing
                    engine.</p></td>
            </tr><tr>
                <td><code class="literal">scheduledExecutorService</code></td>
                <td><code class="code">null</code></td>
                <td><p><span class="bold"><strong>Camel 2.10:</strong></span> Allows for configuring a
                        custom/shared thread pool to use for the consumer. By default each consumer
                        has its own single threaded thread pool. This option allows you to share a
                        thread pool among multiple file consumers.</p></td>
            </tr><tr>
                <td><code class="literal">scheduler</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> Use a custom scheduler to trigger
                    the consumer to run.  For example, there is a
                        <a href="IDU-Quartz2.html" class="olink">Quartz2</a>, and <a class="link" href="http://camel.apache.org/spring.html" target="_top">Spring</a>-based scheduler
                    that supports CRON expressions.</td>
            </tr><tr>
                <td><code class="literal">backoffMultiplier</code>
                </td>
                <td><code class="literal">0</code>
                </td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> Let the scheduled polling
                    consumer backoff if a number of subsequent idles/errors occurred in a row.
                    The multiplier is then the number of polls that will be skipped before the next
                    attempt is made. When this option is set, 
                        <code class="literal">backoffIdleThreshold</code> and/or
                        <code class="literal">backoffErrorThreshold</code> must also be configured.  </td>
            </tr><tr>
                <td><code class="literal">backoffIdleThreshold</code>
                </td>
                <td><code class="literal">0</code>
                </td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> The number of subsequent idle polls
                    that should happen before the <code class="literal">backoffMultipler</code> should
                    kick-in. </td>
            </tr><tr>
                <td><code class="literal">backoffErrorThreshold</code></td>
                <td><code class="literal">0</code></td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> The number of subsequent error
                    polls (failed due some error) that should happen before the
                        <code class="literal">backoffMultipler</code> should kick-in.</td>
            </tr><tr>
                <td><code class="literal">onCompletionExceptionHandler</code></td>
                <td></td>
                <td><span class="bold"><strong>Camel 2.16:</strong></span> To use a custom
                        <code class="code">org.apache.camel.spi.ExceptionHandler</code> to handle any thrown
                    exceptions that happens during the file on completion process where the consumer
                    does either a commit or rollback. The default implementation will log any
                    exception at WARN level and ignore.</td>
            </tr><tr>
                <td><code class="literal">probeContentType</code></td>
                <td><code class="literal">false</code></td>
                <td>
                    <p><span class="bold"><strong>Camel 2.17:</strong></span> Whether to enable probing of
                        the content type. If enabled, the consumer uses
                            <code class="code">Files#probeContentType(java.nio.file.Path)</code> to determine the
                        Content-Type of the file, and store that as a header with the key
                            <code class="code">Exchange#FILE_CONTENT_TYPE</code> on the Message. </p>
                    <p><span class="bold"><strong>Note:</strong></span> From <span class="bold"><strong>Camel
                            2.15</strong></span> onwards this function was introduced and was always
                        enabled. But from <span class="bold"><strong>Camel 2.17</strong></span> it is off by
                        default, as it can cause problems on some file systems.</p>
                </td>
            </tr><tr>
                <td><code class="literal">extendedAttributes</code></td>
                <td><code class="literal">null</code></td>
                <td><span class="bold"><strong>Camel 2.17:</strong></span> To enable gathering extended file
                    attributes through <code class="code">java.nio.file.attribute</code> classes using
                        <code class="code">Files.getAttribute(ava.nio.file.Path, java.lang.String
                        attribute)</code> or <code class="code">Files.readAttributes(ava.nio.file.Path,
                        java.lang.String attributes)</code> depending on the option value. This
                    option supports a comma-delimited list of attributes to collect&#8212;for
                    example: <code class="code">basic:creationTime</code>, <code class="code">posix:group</code>&#8212;or a
                    simple wildcard&#8212;for example, <code class="code">posix:*</code>. If the attribute name
                    is not prefixed, the basic attributes are queried. The result is stored as a
                    header with key, <code class="code">CamelFileExtendedAttributes</code>, of
                        <code class="code">Map&lt;String, Object&gt;</code> type, where the <span class="emphasis"><em>key</em></span>
                    is the name of the attribute (for example, <code class="code">posix:group</code>) and the
                        <span class="emphasis"><em>value</em></span> is the attribute returned by the call to
                        <code class="code">Files.getAttribute()</code> or <code class="code">Files.readAttributes</code>.</td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Defaultbehaviorforfileconsumer"></a>Default behavior for file consumer</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>By default the file is <span class="emphasis"><em>not</em></span> locked for the duration of the
                    processing.</p></li><li class="listitem"><p>After the route has completed, files are moved into the
                        <code class="literal">.camel</code> subdirectory, so that they appear to be
                    deleted.</p></li><li class="listitem"><p>The File Consumer will always skip any file whose name starts with a dot, such
                    as <code class="literal">.</code>, <code class="literal">.camel</code>, <code class="literal">.m2</code> or
                        <code class="literal">.groovy</code>.</p></li><li class="listitem"><p>Only files (not directories) are matched for valid filename, if options such
                    as: <code class="literal">includeNamePrefix</code>, <code class="literal">includeNamePostfix</code>,
                        <code class="literal">excludeNamePrefix</code>, <code class="literal">excludeNamePostfix</code>,
                        <code class="literal">regexPattern</code> are used. </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Produceronly"></a>Producer only</h2></div></div></div><table id="d0e81830"><tr>
                <th> Name </th>
                <th> Default Value </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">fileExist</code>
                </td>
                <td><code class="literal">Override</code>
                </td>
                <td> What to do if a file already exists with the same name. The following values
                    can be specified: <span class="bold"><strong>Override</strong></span>, <span class="bold"><strong>Append</strong></span>, <span class="bold"><strong>Fail</strong></span>,
                        <span class="bold"><strong>Ignore</strong></span>, <span class="bold"><strong>Move</strong></span>, and <span class="bold"><strong>TryRename</strong></span> (Camel
                    2.11.1). <code class="literal">Override</code>, which is the default, replaces the
                    existing file. <code class="literal">Append</code> adds content to the existing file.
                        <code class="literal">Fail</code> throws a
                        <code class="literal">GenericFileOperationException</code>, indicating that there is
                    already an existing file. <code class="literal">Ignore</code> silently ignores the problem
                    and <span class="bold"><strong>does not</strong></span> override the existing file, but
                    assumes everything is okay. The <code class="literal">Move</code> option requires
                        <span class="bold"><strong>Camel 2.10.1</strong></span> onwards, and the corresponding
                        <code class="literal">moveExisting</code> option to be configured as well. The option
                        <code class="literal">eagerDeleteTargetFile</code> can be used to control what to do
                    if an moving the file, and there exists already an existing file, otherwise
                    causing the move operation to fail. The <code class="literal">Move</code> option will move
                    any existing files, before writing the target file.
                        <code class="literal">TryRename</code><span class="bold"><strong>Camel 2.11.1</strong></span> is
                    only applicable if <code class="literal">tempFileName</code> option is in use. This allows
                    to try renaming the file from the temporary name to the actual name, without
                    doing any exists check. This check may be faster on some file systems and
                    especially FTP servers. </td>
            </tr><tr>
                <td><code class="literal">tempPrefix</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td> This option is used to write the file using a temporary name and then, after
                    the write is complete, rename it to the real name. Can be used to identify files
                    being written and also avoid consumers (not using exclusive read locks) reading
                    in progress files. Is often used by <a href="IDU-FTP2.html" class="olink">FTP</a> when
                    uploading big files. </td>
            </tr><tr>
                <td><code class="literal">tempFileName</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.1:</strong></span> The <span class="bold"><strong>same</strong></span> as <code class="literal">tempPrefix</code> option but offering a more
                    fine grained control on the naming of the temporary filename as it uses the
                        <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>.</td>
            </tr><tr>
                <td><code class="literal">keepLastModified</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td><span class="bold"><strong>Camel 2.2:</strong></span> Will keep the last modified
                    timestamp from the source file (if any). Will use the
                        <code class="literal">Exchange.FILE_LAST_MODIFIED</code> header to located the
                    timestamp. This header can contain either a <code class="literal">java.util.Date</code> or
                        <code class="literal">long</code> with the timestamp. If the timestamp exists and the
                    option is enabled it will set this timestamp on the written file. <span class="bold"><strong>Note:</strong></span> This option only applies to the <span class="bold"><strong>file</strong></span> producer. You <span class="emphasis"><em>cannot</em></span> use
                    this option with any of the ftp producers. </td>
            </tr><tr>
                <td><code class="literal">eagerDeleteTargetFile</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td><span class="bold"><strong>Camel 2.3:</strong></span> Whether or not to eagerly delete any
                    existing target file. This option only applies when you use
                        <code class="literal">fileExists=Override</code> and the
                        <code class="literal">tempFileName</code> option as well. You can use this to disable
                    (set it to false) deleting the target file before the temp file is written. For
                    example you may write big files and want the target file to exists during the
                    temp file is being written. This ensure the target file is only deleted until
                    the very last moment, just before the temp file is being renamed to the target
                    filename. From <span class="bold"><strong>Camel 2.10.1</strong></span> on this option is
                    also used to control whether to delete any existing files when
                        <code class="code">fileExist=Move</code> is enabled, and an existing file exists. If the
                    option <code class="code">copyAndDeleteOnRenameFail</code> is <code class="code">false</code>, an
                    exception will be thrown if an existing file existed; if it's <code class="code">true</code>,
                    the existing file is deleted before the move operation.</td>
            </tr><tr>
                <td><code class="literal">doneFileName</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.6:</strong></span> If provided, then Camel will write a
                    2nd <span class="emphasis"><em>done</em></span> file when the original file has been written. The
                        <span class="emphasis"><em>done</em></span> file will be empty. This option configures what
                    file name to use. Either you can specify a fixed name. Or you can use dynamic
                    placeholders. The <span class="emphasis"><em>done</em></span> file will <span class="bold"><strong>always</strong></span> be written in the same folder as the original file. See
                        <span class="emphasis"><em>writing done file</em></span> section for examples. Note: In case of the foreign program writing the files, Red Hat recommend you to use the <code class="code">doneFileName</code> option.</td>
               
            </tr><tr>
                <td><code class="literal">allowNullBody</code>
                </td>
                <td><code class="literal">false</code>
                </td>
                <td><span class="bold"><strong>Camel 2.10.1:</strong></span> Used to specify if a null body is
                    allowed during file writing. If set to true then an empty file will be created,
                    when set to false, and attempting to send a null body to the file component, a
                    GenericFileWriteException of 'Cannot write null body to file.' will be thrown.
                    If the `fileExist` option is set to 'Override', then the file will be truncated,
                    and if set to `append` the file will remain unchanged. </td>
            </tr><tr>
                <td><code class="literal">forceWrites</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td><span class="bold"><strong>Camel 2.10.5/2.11:</strong></span> Whether to force syncing
                    writes to the file system. You can turn this off if you do not want this level
                    of guarantee, for example if writing to logs / audit logs etc; this would yield
                    better performance. </td>
            </tr><tr>
                <td><code class="literal">chmod</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.15.0:</strong></span> Specifies the file permissions
                    sent by the producer, where the <code class="code">chmod</code> value must be between
                        <code class="code">000</code> and <code class="code">777</code>. Leading digits&#8212;for example,
                        <code class="code">0755</code>&#8212;are ignored.</td>
            </tr><tr>
                <td><code class="literal">chmodDirectory</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.17.0:</strong></span> Specifies the directory
                    permissions used when the producer creates missing directories, where the
                        <code class="code">chmod</code> value must be between <code class="code">000</code> and
                        <code class="code">777</code>. Leading digits&#8212;for example,
                    <code class="code">0755</code>&#8212;are ignored. </td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Defaultbehaviorforfileproducer"></a>Default behavior for file producer</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>By default it will override any existing file, if one exist with the same
                    name. In Apache Camel 1.x the
                        <code class="literal">Append</code> is the default for the file producer. <span class="phrase">We
                        have changed this to <code class="literal">Override</code> in Apache Camel 2.0 as this is
                        also the default file operation using <code class="literal">java.io.File</code>. And
                        also the default for the FTP library we use in the <a href="IDU-FTP2.html" class="olink">camel-ftp</a> component.</span>
                    
                </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_MoveandDeleteoperations"></a>Move and Delete operations</h2></div></div></div><p>Any move or delete operations is executed after (post command) the routing has
            completed; so during processing of the <code class="literal">Exchange</code> the file is still
            located in the inbox folder. </p><p>Lets illustrate this with an example:</p><pre class="programlisting">    from("file://inbox?move=.done").to("bean:handleOrder");</pre><p>When a file is dropped in the <code class="literal">inbox</code> folder, the file consumer
            notices this and creates a new <code class="literal">FileExchange</code> that is routed to the
                <code class="literal">handleOrder</code> bean. The bean then processes the
                <code class="literal">File</code> object. At this point in time the file is still located in
            the <code class="literal">inbox</code> folder. After the bean completes, and thus the route is
            completed, the file consumer will perform the move operation and move the file to the
                <code class="literal">.done</code> sub-folder.</p><p>The <span class="bold"><strong>move</strong></span> and <span class="bold"><strong>preMove</strong></span>
            options is considered as a directory name (though if you use an expression such as <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>, or <a class="link" href="http://camel.apache.org/simple.html" target="_top">Simple</a> then the result of the expression evaluation is the file name to be
            used - eg if you set </p><pre class="programlisting">move=../backup/copy-of-${file:name}
</pre><p> then that's using the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> which we use
            return the file name to be used), which can be either relative or absolute. If relative,
            the directory is created as a sub-folder from within the folder where the file was
            consumed.</p><p>By default, Apache Camel will move consumed files to the <code class="literal">.camel</code>
            sub-folder relative to the directory where the file was consumed.</p><p>If you want to delete the file after processing, the route should be:</p><pre class="programlisting">    from("file://inobox?delete=true").to("bean:handleOrder");</pre><p>We have introduced a <span class="bold"><strong>pre</strong></span> move operation to move files
                <span class="bold"><strong>before</strong></span> they are processed. This allows you to mark
            which files have been scanned as they are moved to this sub folder before being
            processed.</p><pre class="programlisting">    from("file://inbox?preMove=inprogress").to("bean:handleOrder");</pre><p>You can combine the <span class="bold"><strong>pre</strong></span> move and the regular
            move:</p><pre class="programlisting">    from("file://inbox?preMove=inprogress&amp;move=.done").to("bean:handleOrder");</pre><p>So in this situation, the file is in the <code class="literal">inprogress</code> folder when
            being processed and after it's processed, it's moved to the <code class="literal">.done</code>
            folder.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_FinegrainedcontroloverMoveandPreMoveoption"></a>Fine grained control over Move and PreMove option</h2></div></div></div><p>The <span class="bold"><strong>move</strong></span> and <span class="bold"><strong>preMove</strong></span>
            option is <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a>-based, so we have the full power
            of the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>
            to do advanced configuration of the directory and name pattern. Apache Camel will, in fact,
            internally convert the directory name you enter into a <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>
            expression. So when we enter <code class="literal">move=.done</code> Apache Camel will convert this
            into: <code class="code">${file:parent}/.done/${file:onlyname}</code>. This is only done if Apache Camel
            detects that you have not provided a <code class="code">${ }</code> in the option value yourself. So
            when you enter an expression containing <code class="code">${ }</code>, the expression is interpreted
            as a File Language expression.</p><p>So if we want to move the file into a backup folder with today's date as the pattern,
            we can do:</p><pre class="programlisting">move=backup/${date:now:yyyyMMdd}/${file:name}</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_AboutmoveFailed"></a>About moveFailed</h2></div></div></div><p>The <code class="literal">moveFailed</code> option allows you to move files that <span class="bold"><strong>could not</strong></span> be processed succesfully to another location such
            as a error folder of your choice. For example to move the files in an error folder with
            a timestamp you can use
                <code class="code">moveFailed=/error/${file:name.noext}-${date:now:yyyyMMddHHmmssSSS}.${file:name.ext}</code>.</p><p>See more examples at <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File
                Language</a>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_MessageHeaders"></a>Message Headers</h2></div></div></div><p>The following headers are supported by this component:</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Fileproduceronly"></a>File producer only</h2></div></div></div><table id="d0e82342"><tr>
                <th> Header </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">CamelFileName</code>
                </td>
                <td> Specifies the name of the file to write (relative to the endpoint directory).
                    The name can be a <code class="literal">String</code>; a <code class="literal">String</code> with a
                        <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> or <a class="link" href="http://camel.apache.org/simple.html" target="_top">Simple</a> expression; or an <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> object. If it's <code class="literal">null</code> then Apache Camel
                    will auto-generate a filename based on the message unique ID. </td>
            </tr><tr>
                <td><code class="literal">CamelFileNameProduced</code>
                </td>
                <td> The actual absolute filepath (path + name) for the output file that was
                    written. This header is set by Camel and its purpose is providing end-users with
                    the name of the file that was written. </td>
            </tr><tr>
                <td><code class="literal">CamelOverruleFileName</code>
                </td>
                <td><span class="bold"><strong>Camel 2.11:</strong></span> Is used for overruling
                        <code class="literal">CamelFileName</code> header and use the value instead (but only
                    once, as the producer will remove this header after writing the file). The value
                    can be only be a String. Notice that if the option <code class="literal">fileName</code>
                    has been configured, then this is still being evaluated. </td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Fileconsumeronly"></a>File consumer only</h2></div></div></div><table id="d0e82411"><tr>
                <th> Header </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">CamelFileName</code>
                </td>
                <td> Name of the consumed file as a relative file path with offset from the starting
                    directory configured on the endpoint. </td>
            </tr><tr>
                <td><code class="literal">CamelFileNameOnly</code>
                </td>
                <td> Only the file name (the name with no leading paths). </td>
            </tr><tr>
                <td><code class="literal">CamelFileAbsolute</code>
                </td>
                <td> A <code class="literal">boolean</code> option specifying whether the consumed file
                    denotes an absolute path or not. Should normally be <code class="literal">false</code> for
                    relative paths. Absolute paths should normally not be used but we added to the
                    move option to allow moving files to absolute paths. But can be used elsewhere
                    as well. </td>
            </tr><tr>
                <td><code class="literal">CamelFileAbsolutePath</code>
                </td>
                <td> The absolute path to the file. For relative files this path holds the relative
                    path instead. </td>
            </tr><tr>
                <td><code class="literal">CamelFilePath</code>
                </td>
                <td> The file path. For relative files this is the starting directory + the relative
                    filename. For absolute files this is the absolute path. </td>
            </tr><tr>
                <td><code class="literal">CamelFileRelativePath</code>
                </td>
                <td> The relative path. </td>
            </tr><tr>
                <td><code class="literal">CamelFileParent</code>
                </td>
                <td> The parent path. </td>
            </tr><tr>
                <td><code class="literal">CamelFileLength</code>
                </td>
                <td> A <code class="literal">long</code> value containing the file size. </td>
            </tr><tr>
                <td><code class="literal">CamelFileLastModified</code>
                </td>
                <td> A <code class="literal">long</code> value containing the last modified timestamp of the
                    file. </td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_BatchConsumer"></a>Batch Consumer</h2></div></div></div><p>This component implements the <a class="link" href="http://camel.apache.org/batch-consumer.html" target="_top">Batch Consumer</a>.
        </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_ExchangePropertiesfileconsumeronly"></a>Exchange Properties, file consumer only</h2></div></div></div><p>As the file consumer is <code class="literal">BatchConsumer</code> it supports batching the
            files it polls. By batching it means that Apache Camel will add some properties to the <a class="link" href="Exchange" target="_top">Exchange</a> so you know the number of files polled the
            current index in that order.</p><table id="d0e82543"><tr>
                <th> Property </th>
                <th> Description </th>
            </tr><tr>
                <td><code class="literal">CamelBatchSize</code>
                </td>
                <td> The total number of files that was polled in this batch. </td>
            </tr><tr>
                <td><code class="literal">CamelBatchIndex</code>
                </td>
                <td> The current index of the batch. Starts from 0. </td>
            </tr><tr>
                <td><code class="literal">CamelBatchComplete</code>
                </td>
                <td> A <code class="literal">boolean</code> value indicating the last <a class="link" href="Exchange" target="_top">Exchange</a> in the batch. Is only <code class="literal">true</code> for the last
                    entry. </td>
            </tr></table><p>This allows you, for example, to know how many files exists in this batch and let the
                <span class="phrase">Aggregator</span>
            aggregate this number of files.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Commongotchaswithfolderandfilenames"></a>Common gotchas with folder and filenames</h2></div></div></div><p>When Apache Camel is producing files (writing files) there are a few gotchas affecting how
            to set a filename of your choice. By default, Apache Camel will use the message ID as the
            filename, and since the message ID is normally a unique generated ID, you will end up
            with filenames such as: <code class="literal">ID-MACHINENAME-2443-1211718892437-1-0</code>. If
            such a filename is not desired, then you must provide a filename in the
                <code class="literal">CamelFileName</code> message header. The constant,
                <code class="literal">Exchange.FILE_NAME</code>, can also be used. </p><p>The sample code below produces files using the message ID as the filename:</p><pre class="programlisting">from("direct:report").to("file:target/reports");</pre><p>To use <code class="literal">report.txt</code> as the filename you have to do:</p><pre class="programlisting">from("direct:report").setHeader(Exchange.FILE_NAME, constant("report.txt")).to( "file:target/reports");</pre><p>Or the same as above, but with <code class="literal">CamelFileName</code>:</p><pre class="programlisting">from("direct:report").setHeader("CamelFileName", constant("report.txt")).to( "file:target/reports");</pre><p>And a syntax where we set the filename on the endpoint with the <span class="bold"><strong>fileName</strong></span> URI option.</p><pre class="programlisting">from("direct:report").to("file:target/reports/?fileName=report.txt");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_FilenameExpression"></a>Filename Expression</h2></div></div></div><p>Filename can be set either using the <span class="bold"><strong>expression</strong></span>
            option or as a string-based <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> expression in the <code class="literal">CamelFileName</code> header. See
            the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> for
            syntax and samples.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Consumingfilesfromfolderswhereothersdropfilesdirectly"></a>Consuming files from folders where others drop files directly</h2></div></div></div><p>Beware if you consume files from a folder where other applications write files
            directly. Take a look at the different <code class="literal">readLock</code> options to see what
            suits your use cases. The best approach is however to write to another folder and after
            the write move the file in the drop folder. However if you write files directly to the
            drop folder then the option <code class="literal">changed</code> could better detect whether a
            file is currently being written/copied as it uses a file changed algorithm to see
            whether the file size / modification changes over a period of time. The other read lock
            options rely on Java File API that sadly is not always very good at detecting this. You
            may also want to look at the <code class="literal">doneFileName</code> option, which uses a marker
            file (done) to signal when a file is done and ready to be consumed.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Usingdonefiles"></a>Using done files</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.6</strong></span>
        </p><p>Also, see the section <span class="emphasis"><em>writing done files</em></span> below.</p><p>If you want only to consume files when a done file exists, then you can use the
                <code class="literal">doneFileName</code> option on the endpoint. </p><pre class="programlisting">from("file:bar?doneFileName=done");</pre><p>Will only consume files from the bar folder, if a file name done exists in the same
            directory as the target files. Camel will automatically delete the done file when it's
            done consuming the files.</p><p>However its more common to have one done file per target file. This means there is a
            1:1 correlation. To do this you must use dynamic placeholders in the
                <code class="literal">doneFileName</code> option. Currently Camel supports the following two
            dynamic tokens: <code class="literal">file:name</code> and <code class="literal">file:name.noext</code>
            which must be enclosed in ${ }. The consumer only supports the static part of the done
            file name as either prefix or suffix (not both).</p><pre class="programlisting">from("file:bar?doneFileName=${file:name}.done");</pre><p>In this example only files will be polled if there exists a done file with the name
                <span class="emphasis"><em>file name</em></span>.done. For example</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">hello.txt</code> - is the file to be consumed</p></li><li class="listitem"><p><code class="literal">hello.txt.done</code> - is the associated done file</p></li></ul></div><p>You can also use a prefix for the done file, such as:</p><pre class="programlisting">from("file:bar?doneFileName=ready-${file:name}");</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">hello.txt</code> - is the file to be consumed</p></li><li class="listitem"><p><code class="literal">ready-hello.txt</code> - is the associated done file</p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Writingdonefiles"></a>Writing done files</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.6</strong></span></p><p>After you have written af file you may want to write an additional
                <span class="emphasis"><em>done</em></span> file as a kinda of marker, to indicate to others that the
            file is finished and has been written. To do that you can use the
                <code class="literal">doneFileName</code> option on the file producer endpoint. </p><pre class="programlisting">.to("file:bar?doneFileName=done");</pre><p>Will simply create a file named <code class="literal">done</code> in the same directory as the
            target file.</p><p>However its more common to have one done file per target file. This means there is a
            1:1 correlation. To do this you must use dynamic placeholders in the
                <code class="literal">doneFileName</code> option. Currently Camel supports the following two
            dynamic tokens: <code class="literal">file:name</code> and <code class="literal">file:name.noext</code>
            which must be enclosed in <code class="code">${ }</code>. </p><pre class="programlisting">.to("file:bar?doneFileName=done-${file:name}");</pre><p>Will for example create a file named <code class="literal">done-foo.txt</code> if the target
            file was <code class="literal">foo.txt</code> in the same directory as the target file.</p><pre class="programlisting">.to("file:bar?doneFileName=${file:name}.done");</pre><p>Will for example create a file named <code class="literal">foo.txt.done</code> if the target
            file was <code class="literal">foo.txt</code> in the same directory as the target file.</p><pre class="programlisting">.to("file:bar?doneFileName=${file:name.noext}.done");</pre><p>Will for example create a file named <code class="literal">foo.done</code> if the target file
            was <code class="literal">foo.txt</code> in the same directory as the target file.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readfromadirectoryandwritetoanotherdirectory"></a>Read from a directory and write to another directory</h2></div></div></div><pre class="programlisting">from("file://inputdir/?delete=true").to("file://outputdir")</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readfromadirectoryandwritetoanotherdirectoryusingaoverruledynamicname"></a>Read from a directory and write to another directory using a overrule dynamic
            name</h2></div></div></div><p></p><pre class="programlisting">from("file://inputdir/?delete=true").to("file://outputdir?overruleFile=copy-of-${file:name}")</pre><p>Listen on a directory and create a message for each file dropped there. Copy the
            contents to the <code class="literal">outputdir</code> and delete the file in the
                <code class="literal">inputdir</code>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readingrecursivelyfromadirectoryandwritingtoanother"></a>Reading recursively from a directory and writing to another</h2></div></div></div><pre class="programlisting">from("file://inputdir/?recursive=true&amp;delete=true").to("file://outputdir")</pre><p>Listen on a directory and create a message for each file dropped there. Copy the
            contents to the <code class="literal">outputdir</code> and delete the file in the
                <code class="literal">inputdir</code>. Will scan recursively into sub-directories. Will lay
            out the files in the same directory structure in the <code class="literal">outputdir</code> as the
                <code class="literal">inputdir</code>, including any sub-directories.</p><pre class="programlisting">inputdir/foo.txt
inputdir/sub/bar.txt</pre><p>Will result in the following output layout:</p><pre class="programlisting">outputdir/foo.txt
outputdir/sub/bar.txt</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Usingflatten"></a>Using flatten</h2></div></div></div><p>If you want to store the files in the outputdir directory in the same directory,
            disregarding the source directory layout (e.g. to flatten out the path), you just add
            the <code class="literal">flatten=true</code> option on the file producer side:</p><pre class="programlisting">from("file://inputdir/?recursive=true&amp;delete=true").to("file://outputdir?flatten=true")</pre><p>Will result in the following output layout:</p><pre class="programlisting">outputdir/foo.txt
outputdir/bar.txt</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readingfromadirectoryandthedefaultmoveoperation"></a>Reading from a directory and the default move operation</h2></div></div></div><p>Apache Camel will by default move any processed file into a <code class="literal">.camel</code>
            subdirectory in the directory the file was consumed from. </p><pre class="programlisting">from("file://inputdir/?recursive=true&amp;delete=true").to("file://outputdir")</pre><p>Affects the layout as follows: <span class="bold"><strong>before</strong></span>
        </p><pre class="programlisting">inputdir/foo.txt
inputdir/sub/bar.txt</pre><p><span class="bold"><strong>after</strong></span>
        </p><pre class="programlisting">inputdir/.camel/foo.txt
inputdir/sub/.camel/bar.txt
outputdir/foo.txt
outputdir/sub/bar.txt</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readfromadirectoryandprocessthemessageinjava"></a>Read from a directory and process the message in java </h2></div></div></div><pre class="programlisting">from("file://inputdir/").process(new Processor() {
  public void process(Exchange exchange) throws Exception {
    Object body = exchange.getIn().getBody();
    // do some business logic with the input body
  }
});</pre><p>The body will be a <code class="literal">File</code> object that points to the file that was
            just dropped into the <code class="literal">inputdir</code> directory.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Readfilesfromadirectoryandsendthecontenttoajmsqueue"></a>Read files from a directory and send the content to a jms queue</h2></div></div></div><pre class="programlisting">from("file://inputdir/").convertBodyTo(String.class).to("jms:test.queue")</pre><p>By default the file endpoint sends a <code class="literal">FileMessage</code> which contains a
                <code class="literal">File</code> object as the body. If you send this directly to the JMS
            component the JMS message will only contain the <code class="literal">File</code> object but not
            the content. By converting the <code class="literal">File</code> to a <code class="literal">String</code>,
            the message will contain the file contents, which is probably what you want.</p><p>The route above using Spring DSL:</p><pre class="programlisting">   &lt;route&gt;
      &lt;from uri="file://inputdir/"/&gt;
      &lt;convertBodyTo type="java.lang.String"/&gt;
      &lt;to uri="jms:test.queue"/&gt;
   &lt;/route&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Writingtofiles"></a>Writing to files</h2></div></div></div><p>Apache Camel is of course also able to write files, i.e. produce files. In the sample
            below we receive some reports on the SEDA queue that we process before they are written
            to a directory.</p><pre class="programlisting">public void testToFile() throws Exception {
    MockEndpoint mock = getMockEndpoint("mock:result");
    mock.expectedMessageCount(1);
    mock.expectedFileExists("target/test-reports/report.txt");

    template.sendBody("direct:reports", "This is a great report");

    assertMockEndpointsSatisfied();
}

protected JndiRegistry createRegistry() throws Exception {
    // bind our processor in the registry with the given id
    JndiRegistry reg = super.createRegistry();
    reg.bind("processReport", new ProcessReport());
    return reg;
}

protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {
        public void configure() throws Exception {
            // the reports from the seda queue is processed by our processor
            // before they are written to files in the target/reports directory
            from("direct:reports").processRef("processReport").to("file://target/test-reports", "mock:result");
        }
    };
}

private static class ProcessReport implements Processor {

    public void process(Exchange exchange) throws Exception {
        String body = exchange.getIn().getBody(String.class);
        // do some business logic here

        // set the output to the file
        exchange.getOut().setBody(body);

        // set the output filename using java code logic, notice that this is done by setting
        // a special header property of the out exchange
        exchange.getOut().setHeader(Exchange.FILE_NAME, "report.txt");
    }

}</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_WritetosubdirectoryusingExchangeFILENAME"></a>Write to subdirectory using Exchange.FILE_NAME </h2></div></div></div><p>Using a single route, it is possible to write a file to any number of subdirectories.
            If you have a route setup as such:</p><pre class="programlisting">  &lt;route&gt;
    &lt;from uri="bean:myBean"/&gt;
    &lt;to uri="file:/rootDirectory"/&gt;
  &lt;/route&gt; </pre><p>You can have <code class="literal">myBean</code> set the header
                <code class="literal">Exchange.FILE_NAME</code> to values such as:</p><pre class="programlisting">Exchange.FILE_NAME = hello.txt =&gt; /rootDirectory/hello.txt
Exchange.FILE_NAME = foo/bye.txt =&gt; /rootDirectory/foo/bye.txt </pre><p>This allows you to have a single route to write files to multiple destinations.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scroll-bookmark-779"></a>Writing file through the temporary directory relative to the final
            destination</h2></div></div></div><p>Sometime you need to temporarily write the files to some directory relative to the
            destination directory. Such situation usually happens when some external process with
            limited filtering capabilities is reading from the directory you are writing to. In the
            example below files will be written to the <code class="code">/var/myapp/filesInProgress</code>
            directory and after data transfer is done, they will be atomically moved to the<code class="code">
                /var/myapp/finalDirectory </code>directory.</p><div class="informalexample"><pre class="programlisting">from("direct:start").
  to("file:///var/myapp/finalDirectory?tempPrefix=/../filesInProgress/");</pre></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Usingexpressionforfilenames"></a>Using expression for filenames</h2></div></div></div><p>In this sample we want to move consumed files to a backup folder using today's date as
            a sub-folder name:</p><pre class="programlisting">from("file://inbox?move=backup/${date:now:yyyyMMdd}/${file:name}").to("...");</pre><p>See <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> for more samples.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Avoidingreadingthesamefilemorethanonceidempotentconsumer"></a>Avoiding reading the same file more than once (idempotent consumer)</h2></div></div></div><p>Apache Camel supports <span class="phrase">Idempotent
            Consumer</span> directly within the component, so it will skip already processed
            files. This feature can be enabled by setting the <code class="literal">idempotent=true</code>
            option.</p><pre class="programlisting">from("file://inbox?idempotent=true").to("...");</pre><p>Camel uses the absolute file name as the idempotent key, to detect duplicate files.
            From <span class="bold"><strong>Camel 2.11</strong></span> onwards you can customize this key by
            using an expression in the idempotentKey option. For example to use both the name and
            the file size as the key</p><pre class="programlisting">
  &lt;route&gt;
    &lt;from uri="file://inbox?idempotent=true&amp;dempotentKey=${file:name}-${file:size}"/&gt;
    &lt;to uri="bean:processInbox"/&gt;
  &lt;/route&gt;
</pre><p>By default Apache Camel uses an in-memory based store for keeping track of consumed files,
            it uses a least recently used cache holding up to 1000 entries. You can plugin your own
            implementation of this store by using the <code class="literal">idempotentRepository</code> option
            using the <code class="literal">#</code> sign in the value to indicate it's a referring to a bean
            in the Registry with the specified
            <code class="literal">id</code>.</p><pre class="programlisting">   &lt;!-- define our store as a plain spring bean --&gt;
   &lt;bean id="myStore" class="com.mycompany.MyIdempotentStore"/&gt;

  &lt;route&gt;
    &lt;from uri="file://inbox?idempotent=true&amp;dempotentRepository=#myStore"/&gt;
    &lt;to uri="bean:processInbox"/&gt;
  &lt;/route&gt;</pre><p>Apache Camel will log at <code class="literal">DEBUG</code> level if it skips a file because it has
            been consumed before:</p><pre class="programlisting">DEBUG FileConsumer is idempotent and the file has been consumed before. Will skip this file: target\idempotent\report.txt</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Usingafilebasedidempotentrepository"></a>Using a file based idempotent repository</h2></div></div></div><p>In this section we will use the file based idempotent repository
                <code class="literal">org.apache.camel.processor.idempotent.FileIdempotentRepository</code>
            instead of the in-memory based that is used as default. This repository uses a 1st level
            cache to avoid reading the file repository. It will only use the file repository to
            store the content of the 1st level cache. Thereby the repository can survive server
            restarts. It will load the content of the file into the 1st level cache upon startup.
            The file structure is very simple as it stores the key in separate lines in the file. By
            default, the file store has a size limit of 1mb and when the file grows larger, Apache Camel
            will truncate the file store and rebuild the content by flushing the 1st level cache
            into a fresh empty file.</p><p>We configure our repository using Spring XML creating our file idempotent repository
            and define our file consumer to use our repository with the
                <code class="literal">idempotentRepository</code> using <code class="literal">\#</code> sign to indicate
                Registry lookup:</p><pre class="programlisting">&lt;!-- this is our file based idempotent store configured to use the .filestore.dat as file --&gt;
&lt;bean id="fileStore" class="org.apache.camel.processor.idempotent.FileIdempotentRepository"&gt;
    &lt;!-- the filename for the store --&gt;
    &lt;property name="fileStore" value="target/fileidempotent/.filestore.dat"/&gt;
    &lt;!-- the max filesize in bytes for the file. Apache Camel will trunk and flush the cache
         if the file gets bigger --&gt;
    &lt;property name="maxFileStoreSize" value="512000"/&gt;
    &lt;!-- the number of elements in our store --&gt;
    &lt;property name="cacheSize" value="250"/&gt;
&lt;/bean&gt;

&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="file://target/fileidempotent/?idempotent=true&amp;dempotentRepository=#fileStore&amp;ove=done/${file:name}"/&gt;
        &lt;to uri="mock:result"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_UsingaJPAbasedidempotentrepository"></a>Using a JPA based idempotent repository</h2></div></div></div><p>In this section we will use the JPA based idempotent repository instead of the
            in-memory based that is used as default. </p><p>First we need a persistence-unit in <code class="literal">META-INF/persistence.xml</code> where
            we need to use the class
                <code class="literal">org.apache.camel.processor.idempotent.jpa.MessageProcessed</code> as
            model.</p><pre class="programlisting">&lt;persistence-unit name="idempotentDb" transaction-type="RESOURCE_LOCAL"&gt;
  &lt;class&gt;org.apache.camel.processor.idempotent.jpa.MessageProcessed&lt;/class&gt;

  &lt;properties&gt;
    &lt;property name="openjpa.ConnectionURL" value="jdbc:derby:target/idempotentTest;create=true"/&gt;
    &lt;property name="openjpa.ConnectionDriverName" value="org.apache.derby.jdbc.EmbeddedDriver"/&gt;
    &lt;property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema"/&gt;
    &lt;property name="openjpa.Log" value="DefaultLevel=WARN, Tool=INFO"/&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p>Then we need to setup a Spring <code class="literal">jpaTemplate</code> in the spring XML
            file:</p><pre class="programlisting">&lt;!-- this is standard spring JPA configuration --&gt;
&lt;bean id="jpaTemplate" class="org.springframework.orm.jpa.JpaTemplate"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
    &lt;!-- we use idempotentDB as the persitence unit name defined in the persistence.xml file --&gt;
    &lt;property name="persistenceUnitName" value="idempotentDb"/&gt;
&lt;/bean&gt;</pre><p>And finally we can create our JPA idempotent repository in the spring XML file as
            well:</p><pre class="programlisting">&lt;!-- we define our jpa based idempotent repository we want to use in the file consumer --&gt;
&lt;bean id="jpaStore" class="org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository"&gt;
    &lt;!-- Here we refer to the spring jpaTemplate --&gt;
    &lt;constructor-arg index="0" ref="jpaTemplate"/&gt;
    &lt;!-- This 2nd parameter is the name  (= a cateogry name).
         You can have different repositories with different names --&gt;
    &lt;constructor-arg index="1" value="FileConsumer"/&gt;
&lt;/bean&gt;</pre><p>And then we just need to reference the <span class="bold"><strong>jpaStore</strong></span> bean
            in the file consumer endpoint, using the <code class="code">idempotentRepository</code> option and
            the <code class="literal">#</code> syntax:</p><pre class="programlisting">  &lt;route&gt;
    &lt;from uri="file://inbox?idempotent=true&amp;dempotentRepository=#jpaStore"/&gt;
    &lt;to uri="bean:processInbox"/&gt;
  &lt;/route&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_FilterusingorgapachecamelcomponentfileGenericFileFilter"></a>Filter using org.apache.camel.component.file.GenericFileFilter</h2></div></div></div><p>Apache Camel supports pluggable filtering strategies. You can then configure the endpoint
            with such a filter to skip certain files being processed.</p><p>In the sample we have built our own filter that skips files starting with
                <code class="literal">skip</code> in the filename:</p><pre class="programlisting">public class MyFileFilter implements GenericFileFilter {
    public boolean accept(GenericFile pathname) {
        // we dont accept any files starting with skip in the name
        return !pathname.getFileName().startsWith("skip");
    }
}</pre><p>And then we can configure our route using the <span class="bold"><strong>filter</strong></span>
            attribute to reference our filter (using <code class="literal">#</code> notation) that we have
            defined in the spring XML file:</p><pre class="programlisting">   &lt;!-- define our filter as a plain spring bean --&gt;
   &lt;bean id="myFilter" class="com.mycompany.MyFileFilter"/&gt;

  &lt;route&gt;
    &lt;from uri="file://inbox?filter=#myFilter"/&gt;
    &lt;to uri="bean:processInbox"/&gt;
  &lt;/route&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_FilteringusingANTpathmatcher"></a>Filtering using ANT path matcher</h2></div></div></div><p>The ANT path matcher is shipped out-of-the-box in the <span class="bold"><strong>camel-spring</strong></span> jar. So you need to depend on <span class="bold"><strong>camel-spring</strong></span> if you are using Maven. The reasons is that we leverage
            Spring's <a class="link" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/util/AntPathMatcher.html" target="_top">AntPathMatcher</a> to do the actual matching.</p><p>The file paths is matched with the following rules:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">?</code> matches one character</p></li><li class="listitem"><p><code class="literal">*</code> matches zero or more characters</p></li><li class="listitem"><p><code class="literal">**</code> matches zero or more directories in a path</p></li></ul></div><p>The sample below demonstrates how to use it:</p><pre class="programlisting">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;template id="camelTemplate"/&gt;

    &lt;!-- use myFilter as filter to allow setting ANT paths for which files to scan for --&gt;
    &lt;endpoint id="myFileEndpoint" uri="file://target/antpathmatcher?recursive=true&amp;ilter=#myAntFilter"/&gt;

    &lt;route&gt;
        &lt;from ref="myFileEndpoint"/&gt;
        &lt;to uri="mock:result"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;

&lt;!-- we use the antpath file filter to use ant paths for includes and exlucde --&gt;
&lt;bean id="myAntFilter" class="org.apache.camel.component.file.AntPathMatcherGenericFileFilter"&gt;
    &lt;!-- include and file in the subfolder that has day in the name --&gt;
    &lt;property name="includes" value="**/subfolder/**/*day*"/&gt;
    &lt;!-- exclude all files with bad in name or .xml files. Use comma to seperate multiple excludes --&gt;
    &lt;property name="excludes" value="**/*bad*,**/*.xml"/&gt;
&lt;/bean&gt;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_SortingusingComparator"></a>Sorting using Comparator</h2></div></div></div><p>Apache Camel supports pluggable sorting strategies. This strategy it to use the build in
                <code class="literal">java.util.Comparator</code> in Java. You can then configure the endpoint
            with such a comparator and have Apache Camel sort the files before being processed.</p><p>In the sample we have built our own comparator that just sorts by file name:</p><pre class="programlisting">public class MyFileSorter implements Comparator&lt;GenericFile&gt; {
    public int compare(GenericFile o1, GenericFile o2) {
        return o1.getFileName().compareToIgnoreCase(o2.getFileName());
    }
}</pre><p>And then we can configure our route using the <span class="bold"><strong>sorter</strong></span>
            option to reference to our sorter (<code class="literal">mySorter</code>) we have defined in the
            spring XML file:</p><pre class="programlisting">   &lt;!-- define our sorter as a plain spring bean --&gt;
   &lt;bean id="mySorter" class="com.mycompany.MyFileSorter"/&gt;

  &lt;route&gt;
    &lt;from uri="file://inbox?sorter=#mySorter"/&gt;
    &lt;to uri="bean:processInbox"/&gt;
  &lt;/route&gt;</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: URI options can reference beans using the # syntax"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">URI options can reference beans using the # syntax</th></tr><tr><td align="left" valign="top"><p>In the Spring DSL route about notice that we can reference beans in the <a class="link" href="Registry" target="_top">Registry</a> by prefixing the id with
                <code class="literal">#</code>. So writing <code class="literal">sorter=#mySorter</code>, will instruct
                Apache Camel to go look in the Registry for a bean with
                the ID, <code class="literal">mySorter</code>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_SortingusingsortBy"></a>Sorting using sortBy</h2></div></div></div><p>Apache Camel supports pluggable sorting strategies. This strategy it to use the <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> to configure the sorting. The
                <code class="literal">sortBy</code> option is configured as follows:</p><pre class="programlisting">sortBy=group 1;group 2;group 3;...</pre><p>Where each group is separated with semi colon. In the simple situations you just use
            one group, so a simple example could be:</p><pre class="programlisting">sortBy=file:name</pre><p>This will sort by file name, you can reverse the order by prefixing
                <code class="literal">reverse:</code> to the group, so the sorting is now Z..A:</p><pre class="programlisting">sortBy=reverse:file:name</pre><p>As we have the full power of <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> we can
            use some of the other parameters, so if we want to sort by file size we do:</p><pre class="programlisting">sortBy=file:length</pre><p>You can configure to ignore the case, using <code class="literal">ignoreCase:</code> for string
            comparison, so if you want to use file name sorting but to ignore the case then we
            do:</p><pre class="programlisting">sortBy=ignoreCase:file:name</pre><p>You can combine ignore case and reverse, however reverse must be specified
            first:</p><pre class="programlisting">sortBy=reverse:ignoreCase:file:name</pre><p>In the sample below we want to sort by last modified file, so we do:</p><pre class="programlisting">sortBy=file:modified</pre><p>And then we want to group by name as a 2nd option so files with same modifcation is
            sorted by name:</p><pre class="programlisting">sortBy=file:modified;file:name</pre><p>Now there is an issue here, can you spot it? Well the modified timestamp of the file
            is too fine as it will be in milliseconds, but what if we want to sort by date only and
            then subgroup by name? Well as we have the true power of <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a> we can use
            the its date command that supports patterns. So this can be solved as:</p><pre class="programlisting">sortBy=date:file:yyyyMMdd;file:name</pre><p>Yeah, that is pretty powerful, oh by the way you can also use reverse per group, so we
            could reverse the file names:</p><pre class="programlisting">sortBy=date:file:yyyyMMdd;reverse:file:name</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_UsingGenericFileProcessStrategy"></a>Using GenericFileProcessStrategy</h2></div></div></div><p>The option <code class="literal">processStrategy</code> can be used to use a custom
                <code class="literal">GenericFileProcessStrategy</code> that allows you to implement your own
                <span class="emphasis"><em>begin</em></span>, <span class="emphasis"><em>commit</em></span> and
                <span class="emphasis"><em>rollback</em></span> logic. For instance lets assume a system writes a file
            in a folder you should consume. But you should not start consuming the file before
            another <span class="emphasis"><em>ready</em></span> file have been written as well.</p><p>So by implementing our own <code class="literal">GenericFileProcessStrategy</code> we can
            implement this as:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>In the <code class="literal">begin()</code> method we can test whether the special
                        <span class="emphasis"><em>ready</em></span> file exists. The begin method returns a
                        <code class="literal">boolean</code> to indicate if we can consume the file or
                    not.</p></li><li class="listitem"><p>in the <code class="literal">commit()</code> method we can move the actual file and also
                    delete the <span class="emphasis"><em>ready</em></span> file.</p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Important when using consumer.bridgeErrorHandler"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important when using <code class="code">consumer.bridgeErrorHandler</code></th></tr><tr><td align="left" valign="top"><p>When using <code class="code">consumer.bridgeErrorHandler</code>, then <a class="link" href="http://camel.apache.org/intercept.html" target="_top">interceptors</a>, 
                  <a class="link" href="http://camel.apache.org/oncompletion.html" target="_top">OnCompletion</a> does <span class="bold"><strong>not</strong></span> apply. The <a class="link" href="Exchange" target="_top">Exchange</a> is processed directly by the Camel <a class="link" href="http://camel.apache.org/error-handler.html" target="_top">Error Handler</a>, and does not allow prior actions
                such as interceptors, onCompletion to take action.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-File2_HSH_Debuglogging"></a>Debug logging</h2></div></div></div><p>This component has log level <span class="bold"><strong>TRACE</strong></span> that can be
            helpful if you have problems.</p><p>
            See also:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="http://camel.apache.org/file-language.html" target="_top">File Language</a>
                </p></li><li class="listitem"><p>
                    <a href="IDU-FTP2.html" class="olink">FTP2</a>
                </p></li></ul></div></div></div></body></html>