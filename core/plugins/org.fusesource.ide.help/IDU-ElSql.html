<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ElSql</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-ElasticSearch.html" title="ElasticSearch"><link rel="next" href="IDU-EventAdmin.html" title="EventAdmin"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-ElSql"></a>ElSql</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75174"></a>ElSql Component</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.16</strong></span></p><p>The <span class="bold"><strong>elsql:</strong></span> component is an extension to the existing SQL Component that uses <a class="link" href="https://github.com/OpenGamma/ElSql" target="_top">ElSql</a> to define the SQL queries. </p><p>This component uses <code class="code">spring-jdbc</code> behind the scenes for the actual SQL handling.</p><p>Maven users will need to add the following dependency to their <code class="code">pom.xml</code> for this component:</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
    &lt;artifactId&gt;camel-elsql&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
    &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This component can be used as a <a class="link" href="http://camel.apache.org/transactional-client.html" target="_top">Transactional Client</a>.</p></td></tr></table></div><p>The ElSql component uses the following endpoint URI notation:</p><pre class="programlisting">elsql:elSqlName:resourceUri[?options]</pre><p>You can append query options to the URI in the following format, <code class="code">?option=value&amp;option=value&amp;...</code></p><p>The parameters to the SQL queries are named parameters in the elsql mapping files, and maps to corresponding keys from the Camel message, in the given precedence:</p><p>1. <span class="bold"><strong>Camel 2.16.1:</strong></span> from message body if Simple expression.</p><p>2. from message body if its a <code class="code">java.util.Map</code>3. from message headers</p><p>If a named parameter cannot be resolved, then an exception is thrown.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75228"></a>Options</h2></div></div></div><table id="d0e75231"><tbody><tr><th><p>Option</p></th><th><p>Type</p></th><th><p>Default</p></th><th><p>Description</p></th></tr><tr><td><code class="code">resourceUri</code></td><td>String</td><td>null</td><td><span class="bold"><strong>Required</strong></span> The resource file which contains the elsql SQL statements to use. You can specify multiple resources separated by comma. The resources are loaded on the classpath by default, you can prefix with file: to load from file system. Notice you can set this option on the component and then you do not have to configure this on the endpoint.</td></tr><tr><td><code class="code">elSqlConfig</code></td><td> </td><td>null</td><td>To use a specific configured ElSqlConfig. It may be better to use the databaseVendor option instead.</td></tr><tr><td><code class="code">databaseVendor</code></td><td> </td><td>Default</td><td>To use a vendor specific ElSqlConfig. The possible values are: Default, Postgres, HSql, MySql, Oracle, SqlServer2008, Veritca</td></tr><tr><td><p><code class="code">batch</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">false</code></p></td><td><p>Execute SQL batch update statements. See notes below on how the treatment of the inbound message body changes if this is set to <code class="code">true</code>.</p></td></tr><tr><td><p><code class="code">dataSource</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">null</code></p></td><td><p>Reference to a <code class="code">DataSource</code> to look up in the registry.</p></td></tr><tr><td><p><code class="code">template.&lt;xxx&gt;</code></p></td><td><p> </p></td><td><p><code class="code">null</code></p></td><td><p>Sets additional options on the Spring NamedParameterJdbcTemplate that is used behind the scenes to execute the queries. For instance, <code class="code">template.maxRows=10</code>. For detailed documentation, see the NamedParameterJdbcTemplate javadoc documentation.</p></td></tr><tr><td><p><code class="code">consumer.delay</code></p></td><td><p><code class="code">long</code></p></td><td><p><code class="code">500</code></p></td><td><p>Delay in milliseconds between each poll.</p></td></tr><tr><td><p><code class="code">consumer.initialDelay</code></p></td><td><p><code class="code">long</code></p></td><td><p><code class="code">1000</code></p></td><td><p>Milliseconds before polling starts.</p></td></tr><tr><td><p><code class="code">consumer.useFixedDelay</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">false</code></p></td><td><p>Set to <code class="code">true</code> to use fixed delay between polls, otherwise fixed rate is used. See <a class="link" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_top">ScheduledExecutorService</a> in JDK for details.</p></td></tr><tr><td><p><code class="code">maxMessagesPerPoll</code></p></td><td><p><code class="code">int</code></p></td><td><p><code class="code">0</code></p></td><td><p>An integer value to define the maximum number of messages to gather per poll. By default, no maximum is set.</p></td></tr><tr><td><p><code class="code">consumer.useIterator</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">true</code></p></td><td><p>If <code class="code">true</code> each row returned when polling will be processed individually. If <code class="code">false</code> the entire <code class="code">java.util.List</code> of data is set as the IN body.</p></td></tr><tr><td><p><code class="code">consumer.routeEmptyResultSet</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">false</code></p></td><td><p>Whether to route a single empty Exchange if there was no data to poll.</p></td></tr><tr><td><p><code class="code">consumer.onConsume</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">null</code></p></td><td><p>After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.</p></td></tr><tr><td><p><code class="code">consumer.onConsumeFailed</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">null</code></p></td><td><p>After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.</p></td></tr><tr><td><p><code class="code">consumer.onConsumeBatchComplete</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">null</code></p></td><td><p>After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.</p></td></tr><tr><td><p><code class="code">consumer.breakBatchOnConsumeFail</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">false</code></p></td><td><p>If using <code class="code">consumer.onConsume</code> and it fails, then this option controls whether to break out of the batch or continue processing the next row from the batch.</p></td></tr><tr><td><p><code class="code">outputType</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">SelectList</code></p></td><td><p>Make the output of consumer or producer to <code class="code">SelectList</code> as List of Map, or <code class="code">SelectOne</code> as single Java object in the following way: a) If the query has only single column, then that JDBC Column object is returned. (such as <code class="code">SELECT COUNT( * ) FROM PROJECT</code> will return a Long object. b) If the query has more than one column, then it will return a Map of that result. c) If the <code class="code">outputClass</code> is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names. It will assume your class has a default constructor to create instance with. d) If the query resulted in more than one rows, it throws an non-unique result exception.</p><p>Tthe SelectList also supports mapping each row to a Java object as the SelectOne does (only step c).</p></td></tr><tr><td><p><code class="code">outputClass</code></p></td><td><p><code class="code">String</code></p></td><td><p><code class="code">null</code></p></td><td><p>Specify the full package and class name to use as conversion when <code class="code">outputType=SelectOne</code>.</p></td></tr><tr><td><p><code class="code">outputHeader</code></p></td><td><code class="code">String</code></td><td><code class="code">null</code></td><td><p>To store the result as a header instead of the message body. This allows to preserve the existing message body as-is.</p></td></tr><tr><td><p><code class="code">noop</code></p></td><td><p><code class="code">boolean</code></p></td><td><p><code class="code">false</code></p></td><td><p>If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing</p></td></tr><tr><td><code class="code">transacted</code></td><td><code class="code">boolean</code></td><td><code class="code">false</code></td><td><span class="bold"><strong>Camel 2.16.2:</strong></span> <span class="bold"><strong>SQL consumer only:</strong></span>Enables or disables transaction. If enabled then if processing an exchange failed then the consumer break out processing any further exchanges to cause a rollback eager</td></tr></tbody></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75608"></a>Result of the query</h2></div></div></div><p>For <code class="code">select</code> operations, the result is an instance of <code class="code">List&lt;Map&lt;String, Object&gt;&gt;</code> type, as returned by the JdbcTemplate.queryForList() method. For <code class="code">update</code> operations, the result is the number of updated rows, returned as an <code class="code">Integer</code>.</p><p>By default, the result is placed in the message body.  If the outputHeader parameter is set, the result is placed in the header.  This is an alternative to using a full message enrichment pattern to add headers, it provides a concise syntax for querying a sequence or some other small value into a header.  It is convenient to use outputHeader and outputType together:</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75627"></a>Header values</h2></div></div></div><p>When performing <code class="code">update</code> operations, the SQL Component stores the update count in the following message headers:</p><table id="d0e75635"><tbody><tr><th><p>Header</p></th><th><p>Description</p></th></tr><tr><td><p><code class="code">CamelSqlUpdateCount</code></p></td><td><p>The number of rows updated for <code class="code">update</code> operations, returned as an <code class="code">Integer</code> object.</p></td></tr><tr><td><p><code class="code">CamelSqlRowCount</code></p></td><td><p>The number of rows returned for <code class="code">select</code> operations, returned as an <code class="code">Integer</code> object.</p></td></tr></tbody></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75672"></a>Sample</h2></div></div></div><p>In the given route below, we want to get all the projects from the projects table. Notice the SQL query has 2 named parameters, :#lic and :#min.</p><p>Camel will then lookup for these parameters from the message body or message headers. Notice in the example above we set two headers with constant value for the named parameters:</p><pre class="programlisting">   from("direct:projects")
     .setHeader("lic", constant("ASF"))
     .setHeader("min", constant(123))
     .to("elsql:projects:com/foo/orders.elsql")</pre><p>And the <a class="link" href="https://github.com/OpenGamma/ElSql" target="_top">elsql</a> mapping file</p><pre class="programlisting">@NAME(projects)
  SELECT *
  FROM projects
  WHERE license = :lic AND id &gt; :min
  ORDER BY id</pre><p>Though if the message body is a <code class="code">java.util.Map</code> then the named parameters will be taken from the body.</p><pre class="programlisting">   from("direct:projects")
     .to("elsql:projects:com/foo/orders.elsql")</pre><p>In from Camel 2.16.1 onwards you can use Simple expressions as well, which allows to use an OGNL like notation on the message body, where it assumes to have <code class="code">getLicense</code> and <code class="code">getMinimum</code> methods:</p><pre class="programlisting">@NAME(projects)
  SELECT *
  FROM projects
  WHERE license = :${body.license} AND id &gt; :${body.minimum}
  ORDER BY id</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e75705"></a>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>SQL Component</p></li><li class="listitem"><p>MyBatis</p></li><li class="listitem"><p>JDBC</p></li></ul></div></div></div></body></html>