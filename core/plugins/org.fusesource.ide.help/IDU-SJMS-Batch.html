<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SJMS Batch</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-SJMS.html" title="SJMS"><link rel="next" href="IDU-Slack.html" title="Slack"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-SJMS-Batch"></a>SJMS Batch</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e157448"></a>SJMS Batch Component</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.16</strong></span></p><p>SJMS Batch is a specialized component for highly performant, transactional batch consumption from a JMS queue. It can be thought of as a hybrid of a consumer-only component and an aggregator.</p><p>A common use case in Camel is to consume messages from a queue and aggregate them before sending the aggregated state to another endpoint. In order to ensure that data is not lost if the system performing the processing fails, it is typically consumed within a transaction from the queue, and once aggregated stored in a persistent <code class="code">AggregationRepository</code>, such as the one found in the JDBC Component.</p><p>The behavior of the aggregator pattern involves fetching data from the <code class="code">AggregationRepository</code> before an incoming message is aggregated, and writing back the result afterwards. By nature, the reads and writes take progressively longer as the number of aggregated artifacts increases. A rough example of this using arbitrary time units that demonstrates the impact of this is as follows:</p><table id="d0e157466"><tbody><tr><th>Item</th><th>Read Time</th><th>Write Time</th><th>Total Time</th></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td><td>4</td></tr><tr><td>2</td><td>2</td><td>3</td><td>9</td></tr><tr><td>3</td><td>3</td><td>4</td><td>16</td></tr><tr><td>4</td><td>4</td><td>5</td><td>25</td></tr><tr><td>5</td><td>5</td><td>6</td><td>36</td></tr><tr><td>6</td><td>6</td><td>7</td><td>49</td></tr><tr><td>7</td><td>7</td><td>8</td><td>64</td></tr><tr><td>8</td><td>8</td><td>9</td><td>81</td></tr><tr><td>9</td><td>9</td><td>10</td><td>100</td></tr></tbody></table><p>In contrast, consumption performance using the SJMS Batch component is linear. Each message is consumed and aggregated using an <code class="code">AggregationStrategy</code> before the next one is fetched. As all of the consumption and aggregation is performed in a single JMS transaction no external storage is required to persist the intermediate state - this avoids the read and write costs described above. In practice, this yields multiple orders of magnitude higher throughput.</p><p>Once a completion condition is met, either by size or period since first message, the aggregated <code class="code">Exchange</code> is passed into the route. During the processing of this <code class="code">Exchange</code>, if an exception is thrown or the system shuts down, all of the original consumed messages end up back on the queue (or are placed on the dead-letter queue depending on the broker configuration).</p><p>Unlike using a regular aggregator, there is no facility for an aggregation condition, meaning that it is not possible to batch consume into multiple groups of messages at the same time. All consumed messages are aggregated together into a single batch. To get around this, a common design approach is to first sort the different groups of messages to be aggregated onto different queues, and batch consume from each one separately.</p><p>Multiple JMS consumer support is available which allows you to consume in parallel using the one route, and at the same time use facilities like JMS message groups to group related messages.</p><p> </p><p>Maven users will need to add the following dependency to their <code class="code">pom.xml</code> for this component:</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
    &lt;artifactId&gt;camel-sjms&lt;/artifactId&gt;
    &lt;version&gt;2.18.1.redhat-000005&lt;/version&gt;
    &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</pre><p>SJMS Batch is a subcomponent of SJMS, and resides in the same library.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e157595"></a>URI format</h2></div></div></div><pre class="programlisting">sjms:[queue:]destinationName[?options]</pre><p>Where <code class="code">destinationName</code> is a JMS queue. By default, the <code class="code">destinationName</code> is interpreted as a queue name.</p><pre class="programlisting">sjms:FOO.BAR</pre><p>You can include the optional <code class="code">queue:</code> prefix, if you prefer:</p><pre class="programlisting">sjms:queue:FOO.BAR</pre><p>Topic consumption is not supported, as there is no advantage to using batch consumption within that context. Topic messages are usually non-persistent, and loss is acceptable. If consumed within a transaction that fails, a topic message will likely not be redelivered by the broker. A plain SJMS consumer endpoint can be used in conjunction with a regular non-persistence backed aggregator in this scenario.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e157619"></a>Component Options and Configurations</h2></div></div></div><p>The SJMS Batch Component supports the following configuration options:</p><table id="d0e157624"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Required</p></th><th class="confluenceTh"><p>Default Value</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td><p><code class="code">aggregationStrategy</code></p></td><td><p> Yes</p></td><td><p><code class="code">null</code></p></td><td><p>A reference to an <code class="code">AggregationStrategy</code> in the Camel registry (e.g. <code class="code">#myAggregationStrategy</code>)</p></td></tr><tr><td><p><code class="code">completionSize</code></p></td><td><p> </p></td><td><p><code class="code">200</code></p></td><td><p>The size of the batch to aggregate.</p><p>Care should be taken to ensure that this is not larger than the JMS consumer's prefetch buffer, or the maximum page size for a queue on the broker; either of these could cause the consumer to hang if no timeout is used.</p><p>A value of 0 or less indicates that <code class="code">completionTimeout</code> only should be used.</p></td></tr><tr><td><p><code class="code">completionTimeout</code></p></td><td><p> </p></td><td><p><code class="code">500</code></p></td><td><p>The maximum time to wait from the receipt of the first message before emitting the Exchange.</p><p>A value of 0 or less indicates that <code class="code">completionSize</code> only should be used.</p><p>Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.</p></td></tr><tr><td><code class="code">completionTimeout</code></td><td> </td><td> </td><td><span class="bold"><strong>Camel 2.17:</strong></span> The completion interval in millis, which causes batches to be completed in a scheduled fixed rate every interval. The batch may be empty if the timeout triggered and there was no messages in the batch. Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.</td></tr><tr><td><code class="code">sendEmptyMessageWhenIdle</code></td><td> </td><td><code class="code">false</code></td><td><span class="bold"><strong>Camel 2.17:</strong></span> If using completion timeout or interval, then the batch may be empty if the timeout triggered and there was no messages in the batch. If this option is true and the batch is empty then an empty message is added to the batch so an empty message is routed.</td></tr><tr><td><p><code class="code">pollDuration</code></p></td><td><p> </p></td><td><p><code class="code">1000</code></p></td><td><p>The maximum length of a call to <code class="code">MessageConsumer.receive()</code>. The time remaining before timeout takes precedence within a batch.</p><p>This value is effectively the poll time between batches.</p></td></tr><tr><td><code class="code">timeoutCheckerExecutorService</code></td><td> </td><td> </td><td><span class="bold"><strong>Camel 2.17:</strong></span> If using the completionInterval option a background thread is created to trigger the completion interval. Set this option to provide a custom thread pool to be used rather than creating a new thread for every consumer.</td></tr></tbody></table><p>The <code class="code">completionSize</code> endpoint attribute is used in conjunction with <code class="code">completionTimeout</code>, where the first condition to be met will cause the aggregated <code class="code">Exchange</code> to be emitted down the route.</p></div></div></body></html>