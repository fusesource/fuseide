<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Stream Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="Stomp-StompComponent.html" title="Stomp Component"><link rel="next" href="StringTemplate-StringTemplate.html" title="String Template Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="Stream-StreamComponent"></a>Stream Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="Stream-StreamComponent.html#Stream-URIformat">URI format</a></span></dt><dt><span class="section"><a href="Stream-StreamComponent.html#Stream-Options">Options</a></span></dt><dt><span class="section"><a href="Stream-StreamComponent.html#Stream-Messagecontent">Message content</a></span></dt><dt><span class="section"><a href="Stream-StreamComponent.html#Stream-Samples">Samples</a></span></dt><dt><span class="section"><a href="Stream-StreamComponent.html#Stream-SeeAlso">See Also</a></span></dt></dl></div><p>The <span class="strong"><strong>stream:</strong></span> component provides access to the <code class="literal">System.in</code>, <code class="literal">System.out</code>
and <code class="literal">System.err</code> streams as well as allowing streaming of file and URL.</p><p>Maven users will need to add the following dependency to their <code class="literal">pom.xml</code>
for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-stream<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Stream-URIformat"></a>URI format</h2></div></div></div><pre class="programlisting">stream:in[?options]
stream:out[?options]
stream:err[?options]
stream:header[?options]</pre><p>In addition, the <code class="literal">file</code> and <code class="literal">url</code> endpoint URIs are supported:</p><pre class="programlisting">stream:file?fileName=/foo/bar.txt
stream:url[?options]</pre><p>If the <code class="literal">stream:header</code> URI is specified, the <code class="literal">stream</code> header is used to
find the stream to write to. This option is available only for stream
producers (that is, it cannot appear in <code class="literal">from()</code>).</p><p>You can append query options to the URI in the following format,
<code class="literal">?option=value&amp;option=value&amp;&#8230;&#8203;</code></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Stream-Options"></a>Options</h2></div></div></div><p>The Stream component has no options.</p><p>The Stream component supports 19 endpoint options which are listed below:</p><p>{% raw %}</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="10%" class="col_2"><col width="11%" class="col_3"><col width="10%" class="col_4"><col width="50%" class="col_5"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Group</th><th align="left" valign="top">Default</th><th align="left" valign="top">Java Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>kind</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> Kind of stream to use such as System.in or System.out.</p></td></tr><tr><td align="left" valign="top"><p>encoding</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>You can configure the encoding (is a charset name) to use text-based streams (for example message body is a String object). If not provided Camel uses the JVM default Charset.</p></td></tr><tr><td align="left" valign="top"><p>fileName</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>When using the stream:file URI format this option specifies the filename to stream to/from.</p></td></tr><tr><td align="left" valign="top"><p>url</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>When using the stream:url URI format this option specifies the URL to stream to/from. The input/output stream will be opened using the JDK URLConnection facility.</p></td></tr><tr><td align="left" valign="top"><p>bridgeErrorHandler</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>groupLines</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>To group X number of lines in the consumer. For example to group 10 lines and therefore only spit out an Exchange with 10 lines instead of 1 Exchange per line.</p></td></tr><tr><td align="left" valign="top"><p>groupStrategy</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">GroupStrategy</code></p></td><td align="left" valign="top"><p>Allows to use a custom GroupStrategy to control how to group lines.</p></td></tr><tr><td align="left" valign="top"><p>initialPromptDelay</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">2000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Initial delay in milliseconds before showing the message prompt. This delay occurs only once. Can be used during system startup to avoid message prompts being written while other logging is done to the system out.</p></td></tr><tr><td align="left" valign="top"><p>promptDelay</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Optional delay in milliseconds before showing the message prompt.</p></td></tr><tr><td align="left" valign="top"><p>promptMessage</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Message prompt to use when reading from stream:in; for example you could set this to Enter a command:</p></td></tr><tr><td align="left" valign="top"><p>retry</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Will retry opening the file if it&#8217;s overwritten somewhat like tail --retry</p></td></tr><tr><td align="left" valign="top"><p>scanStream</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>To be used for continuously reading a stream such as the unix tail command.</p></td></tr><tr><td align="left" valign="top"><p>scanStreamDelay</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Delay in milliseconds between read attempts when using scanStream.</p></td></tr><tr><td align="left" valign="top"><p>exceptionHandler</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExceptionHandler</code></p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>exchangePattern</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExchangePattern</code></p></td><td align="left" valign="top"><p>Sets the exchange pattern when the consumer creates an exchange.</p></td></tr><tr><td align="left" valign="top"><p>autoCloseCount</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Number of messages to process before closing stream on Producer side. Never close stream by default (only when Producer is stopped). If more messages are sent the stream is reopened for another autoCloseCount batch.</p></td></tr><tr><td align="left" valign="top"><p>closeOnDone</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>This option is used in combination with Splitter and streaming to the same file. The idea is to keep the stream open and only close when the Splitter is done to improve performance. Mind this requires that you only stream to the same file and not 2 or more files.</p></td></tr><tr><td align="left" valign="top"><p>delay</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Initial delay in milliseconds before producing the stream.</p></td></tr><tr><td align="left" valign="top"><p>synchronous</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).</p></td></tr></tbody></table></div><p>{% endraw %}</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Stream-Messagecontent"></a>Message content</h2></div></div></div><p>The <span class="strong"><strong>stream:</strong></span> component supports either <code class="literal">String</code> or <code class="literal">byte[]</code> for writing
to streams. Just add either <code class="literal">String</code> or <code class="literal">byte[]</code> content to the
<code class="literal">message.in.body</code>. Messages sent to the <span class="strong"><strong>stream:</strong></span> producer in binary
mode are not followed by the newline character (as opposed to the
<code class="literal">String</code> messages). Message with <code class="literal">null</code> body will not be appended to the
output stream.
 The special <code class="literal">stream:header</code> URI is used for custom output streams. Just
add a <code class="literal">java.io.OutputStream</code> object to <code class="literal">message.in.header</code> in the key
<code class="literal">header</code>.
 See samples for an example.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Stream-Samples"></a>Samples</h2></div></div></div><p>In the following sample we route messages from the <code class="literal">direct:in</code> endpoint
to the <code class="literal">System.out</code> stream:</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// Route messages to the standard output.</em>
from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:in"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"stream:out"</em></strong>);

<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// Send String payload to the standard output.</em>
<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// Message will be followed by the newline.</em>
template.sendBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:in"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Hello Text World"</em></strong>);

<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// Send byte[] payload to the standard output.</em>
<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// No newline will be added after the message.</em>
template.sendBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:in"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Hello Bytes World"</em></strong>.getBytes());</pre><p>The following sample demonstrates how the header type can be used to
determine which stream to use. In the sample we use our own output
stream, <code class="literal">MyOutputStream</code>.</p><p>The following sample demonstrates how to continuously read a file stream
(analogous to the UNIX <code class="literal">tail</code> command):</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"stream:file?fileName=/server/logs/server.log&amp;scanStream=true&amp;scanStreamDelay=1000"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:logService?method=parseLogLine"</em></strong>);</pre><p>One gotcha with scanStream (pre Camel 2.7) or scanStream + retry is the
file will be re-opened and scanned with each iteration of
scanStreamDelay. Until NIO2 is available we cannot reliably detect when
a file is deleted/recreated.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Stream-SeeAlso"></a>See Also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="configuring-camel.html" target="_top">Configuring Camel</a></li><li class="listitem"><a class="link" href="component.html" target="_top">Component</a></li><li class="listitem"><a class="link" href="endpoint.html" target="_top">Endpoint</a></li><li class="listitem"><a class="link" href="getting-started.html" target="_top">Getting Started</a></li></ul></div></div></div></body></html>