<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Lucene</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-Log.html" title="Log"><link rel="next" href="IDU-Lumberjack.html" title="Lumberjack"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-Lucene"></a>Lucene</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_LuceneIndexerandSearchComponent"></a>Lucene (Indexer and Search) Component</h2></div></div></div><p><span class="bold"><strong>Available as of Apache Camel 2.2</strong></span>
    </p><p>The <span class="bold"><strong>lucene</strong></span> component is based on the Apache Lucene
      project. Apache Lucene is a powerful high-performance, full-featured text search engine
      library written entirely in Java. For more details about Lucene, please see the following
      links:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://lucene.apache.org/java/docs/" target="_top">http://lucene.apache.org/java/docs/</a></p></li><li class="listitem"><p><a class="link" href="http://lucene.apache.org/java/docs/features.html" target="_top">http://lucene.apache.org/java/docs/features.html</a></p></li></ul></div><p>The lucene component in camel facilitates integration and utilization of Lucene endpoints
      in enterprise integration patterns and scenarios. The lucene component does the
      following</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>builds a searchable index of documents when payloads are sent to the Lucene
          Endpoint</p></li><li class="listitem"><p>facilitates performing of indexed searches in Apache Camel</p></li></ul></div><p>This component only supports producer endpoints. </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e124535"></a>Camel on EAP deployment</h2></div></div></div><p>This component is supported by the Camel on EAP (Wildfly Camel) framework, which
            offers a simplified deployment model on the Red Hat JBoss Enterprise Application Platform (JBoss EAP) container.
 </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_URIformat"></a>URI format</h2></div></div></div><pre class="programlisting">lucene:searcherName:insert[?options]
lucene:searcherName:query[?options]</pre><p>You can append query options to the URI in the following format,
        <code class="literal">?option=value&amp;option=value&amp;...</code>
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_InsertOptions"></a>Insert Options</h2></div></div></div><table id="d0e124555"><tr>
        <th> Name </th>
        <th> Default Value </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">analyzer</code>
        </td>
        <td><code class="literal">StandardAnalyzer</code>
        </td>
        <td> An Analyzer builds TokenStreams, which analyze text. It thus represents a policy for
          extracting index terms from text. The value for analyzer can be any class that extends the
          abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a rich set of
          analyzers out of the box </td>
      </tr><tr>
        <td><code class="literal">indexDir</code>
        </td>
        <td><code class="literal">./indexDirectory</code>
        </td>
        <td> A file system directory in which index files are created upon analysis of the document
          by the specified analyzer </td>
      </tr><tr>
        <td><code class="literal">srcDir</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td> An optional directory containing files to be used to be analyzed and added to the index
          at producer startup. </td>
      </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_QueryOptions"></a>Query Options</h2></div></div></div><table id="d0e124616"><tr>
        <th> Name </th>
        <th> Default Value </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">analyzer</code>
        </td>
        <td><code class="literal">StandardAnalyzer</code>
        </td>
        <td> An Analyzer builds TokenStreams, which analyze text. It thus represents a policy for
          extracting index terms from text. The value for analyzer can be any class that extends the
          abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a rich set of
          analyzers out of the box </td>
      </tr><tr>
        <td><code class="literal">indexDir</code>
        </td>
        <td><code class="literal">./indexDirectory</code>
        </td>
        <td> A file system directory in which index files are created upon analysis of the document
          by the specified analyzer </td>
      </tr><tr>
        <td><code class="literal">maxHits</code>
        </td>
        <td><code class="literal">10</code>
        </td>
        <td> An integer value that limits the result set of the search operation </td>
      </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_MessageHeaders"></a>Message Headers</h2></div></div></div><table id="d0e124677"><tr>
        <th> Header </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">QUERY</code>
        </td>
        <td> The Lucene Query to performed on the index. The query may include wildcards and
                    phrases.</td>
      </tr><tr>
                <td><code class="literal">RETURN_LUCENE_DOCS</code>
                </td>
                <td>
                    <span class="bold"><strong>Camel 2.15:</strong></span> Set this header to true to include
                    the actual Lucene documentation when returning hit information. </td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_LuceneProducers"></a>Lucene Producers </h2></div></div></div><p>This component supports 2 producer endpoints.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>insert</strong></span> - The insert producer builds a searchable
          index by analyzing the body in incoming exchanges and associating it with a token
          ("content"). </p></li><li class="listitem"><p><span class="bold"><strong>query</strong></span> - The query producer performs searches on a
          pre-created index. The query uses the searchable index to perform score &amp; relevance
          based searches. Queries are sent via the incoming exchange contains a header property name
          called 'QUERY'. The value of the header property 'QUERY' is a Lucene Query. For more
          details on how to create Lucene Queries check out <a class="link" href="http://lucene.apache.org/java/3_0_0/queryparsersyntax.html" target="_top">
            http://lucene.apache.org/java/3_0_0/queryparsersyntax.html
          </a>
        </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_LuceneProcessor"></a>Lucene Processor </h2></div></div></div><p>There is a processor called LuceneQueryProcessor available to perform queries against
      lucene without the need to create a producer.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_Example1CreatingaLuceneindex"></a>Example 1: Creating a Lucene index</h2></div></div></div><pre class="programlisting">RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from("direct:start").
           to("lucene:whitespaceQuotesIndex:insert?analyzer=#whitespaceAnalyzer&amp;indexDir=#whitespace&amp;srcDir=#load_dir").
           to("mock:result");
    }
};</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_Example2LoadingpropertiesintotheJNDIregistryintheCamelContext"></a>Example 2: Loading properties into the JNDI registry in the Camel Context </h2></div></div></div><pre class="programlisting">@Override
protected JndiRegistry createRegistry() throws Exception {
  JndiRegistry registry =
         new JndiRegistry(createJndiContext());
  registry.bind("whitespace", new File("./whitespaceIndexDir"));
  registry.bind("load_dir",
        new File("src/test/resources/sources"));
  registry.bind("whitespaceAnalyzer",
        new WhitespaceAnalyzer());
  return registry;
}
...
CamelContext context = new DefaultCamelContext(createRegistry());</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_Example2PerformingsearchesusingaQueryProducer"></a>Example 2: Performing searches using a Query Producer</h2></div></div></div><pre class="programlisting">RouteBuilder builder = new RouteBuilder() {
    public void configure() {
       from("direct:start").
          setHeader("QUERY", constant("Seinfeld")).
          to("lucene:searchIndex:query?analyzer=#whitespaceAnalyzer&amp;indexDir=#whitespace&amp;maxHits=20").
          to("direct:next");
                
       from("direct:next").process(new Processor() {
          public void process(Exchange exchange) throws Exception {
             Hits hits = exchange.getIn().getBody(Hits.class);
             printResults(hits);
          }

          private void printResults(Hits hits) {
              LOG.debug("Number of hits: " + hits.getNumberOfHits());
              for (int i = 0; i &lt; hits.getNumberOfHits(); i++) {
                 LOG.debug("Hit " + i + " Index Location:" + hits.getHit().get(i).getHitLocation());
                 LOG.debug("Hit " + i + " Score:" + hits.getHit().get(i).getScore());
                 LOG.debug("Hit " + i + " Data:" + hits.getHit().get(i).getData());
              }
           }
       }).to("mock:searchResult");
   }
};</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-Lucene_HSH_Example3PerformingsearchesusingaQueryProcessor"></a>Example 3: Performing searches using a Query Processor </h2></div></div></div><pre class="programlisting">RouteBuilder builder = new RouteBuilder() {
    public void configure() {            
        try {
            from("direct:start").
                setHeader("QUERY", constant("Rodney Dangerfield")).
                process(new LuceneQueryProcessor("target/stdindexDir", analyzer, null, 20)).
                to("direct:next");
        } catch (Exception e) {
            e.printStackTrace();
        }
                
        from("direct:next").process(new Processor() {
            public void process(Exchange exchange) throws Exception {
                Hits hits = exchange.getIn().getBody(Hits.class);
                printResults(hits);
            }
                    
            private void printResults(Hits hits) {
                LOG.debug("Number of hits: " + hits.getNumberOfHits());
                for (int i = 0; i &lt; hits.getNumberOfHits(); i++) {
                    LOG.debug("Hit " + i + " Index Location:" + hits.getHit().get(i).getHitLocation());
                    LOG.debug("Hit " + i + " Score:" + hits.getHit().get(i).getScore());
                    LOG.debug("Hit " + i + " Data:" + hits.getHit().get(i).getData());
                }
            }
       }).to("mock:searchResult");
   }
};</pre></div></div></body></html>