<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>CXFRS Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="IDU-CXF.html" title="CXF"><link rel="next" href="CamelTransportforCXF-WhatstheCamelTransportforCXF.html" title="CXF Component with Camel Transport"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="CXFRS-CXFRSComponent"></a>CXFRS Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-URIformat">URI format</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-Options">Options</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-HowtoconfiguretheRESTendpointinCamel">How to configure the REST endpoint in Camel</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-HowtooverridetheCXFproduceraddressfrommessageheader">How to override the CXF producer address from message header</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-ConsumingaRESTRequest-SimpleBindingStyle">Consuming a REST Request - Simple Binding Style</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-ConsumingaRESTRequest-DefaultBindingStyle">Consuming a REST Request - Default Binding Style</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-HowtoinvoketheRESTservicethroughcamel-cxfrsproducer">How to invoke the REST service through camel-cxfrs producer</a></span></dt></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When using CXF as a consumer, the <a class="link" href="cxf-bean-component.html" target="_top">CXF Bean
Component</a> allows you to factor out how message payloads are received
from their processing as a RESTful or SOAP web service. This has the
potential of using a multitude of transports to consume web services.
The bean component&#8217;s configuration is also simpler and provides the
fastest method to implement web services using Camel and CXF.</p></td></tr></table></div><p>The <span class="strong"><strong>cxfrs:</strong></span> component provides integration with
<a class="link" href="http://cxf.apache.org" target="_top">Apache CXF</a> for connecting to JAX-RS 1.1 and 2.0
services hosted in CXF.</p><p>Maven users will need to add the following dependency to their pom.xml
for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
   <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
   <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-cxf<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
   <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>  <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-URIformat"></a>URI format</h2></div></div></div><pre class="programlisting">cxfrs:<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">//address?options</em></pre><p>Where <span class="strong"><strong>address</strong></span> represents the CXF endpoint&#8217;s address</p><pre class="programlisting">cxfrs:bean:rsEndpoint</pre><p>Where <span class="strong"><strong>rsEndpoint</strong></span> represents the spring bean&#8217;s name which presents the
CXFRS client or server</p><p>For either style above, you can append options to the URI as follows:</p><pre class="programlisting">cxfrs:bean:cxfEndpoint?resourceClasses=org.apache.camel.rs.Example</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-Options"></a>Options</h2></div></div></div><p>The CXF-RS component supports 1 options which are listed below.</p><p>{% raw %}</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="11%" class="col_2"><col width="70%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Java Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>headerFilterStrategy</p></td><td align="left" valign="top"><p><code class="literal">HeaderFilterStrategy</code></p></td><td align="left" valign="top"><p>To use a custom HeaderFilterStrategy to filter header to and from Camel message.</p></td></tr></tbody></table></div><p>{% endraw %}</p><p>The CXF-RS component supports 29 endpoint options which are listed below:</p><p>{% raw %}</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="10%" class="col_2"><col width="11%" class="col_3"><col width="10%" class="col_4"><col width="50%" class="col_5"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Group</th><th align="left" valign="top">Default</th><th align="left" valign="top">Java Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>beanId</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>To lookup an existing configured CxfRsEndpoint. Must used bean: as prefix.</p></td></tr><tr><td align="left" valign="top"><p>address</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The service publish address.</p></td></tr><tr><td align="left" valign="top"><p>features</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">List</code></p></td><td align="left" valign="top"><p>Set the feature list to the CxfRs endpoint.</p></td></tr><tr><td align="left" valign="top"><p>loggingFeatureEnabled</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>This option enables CXF Logging Feature which writes inbound and outbound REST messages to log.</p></td></tr><tr><td align="left" valign="top"><p>loggingSizeLimit</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>To limit the total size of number of bytes the logger will output when logging feature has been enabled.</p></td></tr><tr><td align="left" valign="top"><p>modelRef</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>This option is used to specify the model file which is useful for the resource class without annotation. When using this option then the service class can be omitted to emulate document-only endpoints</p></td></tr><tr><td align="left" valign="top"><p>providers</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Set custom JAX-RS provider(s) list to the CxfRs endpoint. You can specify a string with a list of providers to lookup in the registy separated by comma.</p></td></tr><tr><td align="left" valign="top"><p>resourceClasses</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">List</code></p></td><td align="left" valign="top"><p>The resource classes which you want to export as REST service. Multiple classes can be separated by comma.</p></td></tr><tr><td align="left" valign="top"><p>schemaLocations</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">List</code></p></td><td align="left" valign="top"><p>Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.</p></td></tr><tr><td align="left" valign="top"><p>skipFaultLogging</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.</p></td></tr><tr><td align="left" valign="top"><p>bindingStyle</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">Default</code></p></td><td align="left" valign="top"><p><code class="literal">BindingStyle</code></p></td><td align="left" valign="top"><p>Sets how requests and responses will be mapped to/from Camel. Two values are possible: SimpleConsumer: This binding style processes request parameters multiparts etc. and maps them to IN headers IN attachments and to the message body. It aims to eliminate low-level processing of org.apache.cxf.message.MessageContentsList. It also also adds more flexibility and simplicity to the response mapping. Only available for consumers. Default: The default style. For consumers this passes on a MessageContentsList to the route requiring low-level processing in the route. This is the traditional binding style which simply dumps the org.apache.cxf.message.MessageContentsList coming in from the CXF stack onto the IN message body. The user is then responsible for processing it according to the contract defined by the JAX-RS method signature. Custom: allows you to specify a custom binding through the binding option.</p></td></tr><tr><td align="left" valign="top"><p>bridgeErrorHandler</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>exceptionHandler</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExceptionHandler</code></p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>exchangePattern</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExchangePattern</code></p></td><td align="left" valign="top"><p>Sets the exchange pattern when the consumer creates an exchange.</p></td></tr><tr><td align="left" valign="top"><p>hostnameVerifier</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">HostnameVerifier</code></p></td><td align="left" valign="top"><p>The hostname verifier to be used. Use the notation to reference a HostnameVerifier from the registry.</p></td></tr><tr><td align="left" valign="top"><p>sslContextParameters</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">SSLContextParameters</code></p></td><td align="left" valign="top"><p>The Camel SSL setting reference. Use the notation to reference the SSL Context.</p></td></tr><tr><td align="left" valign="top"><p>throwExceptionOnFailure</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>This option tells the CxfRsProducer to inspect return codes and will generate an Exception if the return code is larger than 207.</p></td></tr><tr><td align="left" valign="top"><p>httpClientAPI</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If it is true the CxfRsProducer will use the HttpClientAPI to invoke the service. If it is false the CxfRsProducer will use the ProxyClientAPI to invoke the service</p></td></tr><tr><td align="left" valign="top"><p>ignoreDeleteMethodMessageBody</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>This option is used to tell CxfRsProducer to ignore the message body of the DELETE method when using HTTP API.</p></td></tr><tr><td align="left" valign="top"><p>maxClientCacheSize</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">10</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>This option allows you to configure the maximum size of the cache. The implementation caches CXF clients or ClientFactoryBean in CxfProvider and CxfRsProvider.</p></td></tr><tr><td align="left" valign="top"><p>binding</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">CxfRsBinding</code></p></td><td align="left" valign="top"><p>To use a custom CxfBinding to control the binding between Camel Message and CXF Message.</p></td></tr><tr><td align="left" valign="top"><p>bus</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">Bus</code></p></td><td align="left" valign="top"><p>To use a custom configured CXF Bus.</p></td></tr><tr><td align="left" valign="top"><p>continuationTimeout</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">30000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.</p></td></tr><tr><td align="left" valign="top"><p>cxfRsEndpointConfigurer</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">CxfRsEndpointConfigurer</code></p></td><td align="left" valign="top"><p>This option could apply the implementation of org.apache.camel.component.cxf.jaxrs.CxfRsEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configureServer/Client method of CxfEndpointConfigurer.</p></td></tr><tr><td align="left" valign="top"><p>defaultBus</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Will set the default bus when CXF endpoint create a bus by itself</p></td></tr><tr><td align="left" valign="top"><p>headerFilterStrategy</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">HeaderFilterStrategy</code></p></td><td align="left" valign="top"><p>To use a custom HeaderFilterStrategy to filter header to and from Camel message.</p></td></tr><tr><td align="left" valign="top"><p>performInvocation</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When the option is true Camel will perform the invocation of the resource class instance and put the response object into the exchange for further processing.</p></td></tr><tr><td align="left" valign="top"><p>propagateContexts</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When the option is true JAXRS UriInfo HttpHeaders Request and SecurityContext contexts will be available to custom CXFRS processors as typed Camel exchange properties. These contexts can be used to analyze the current requests using JAX-RS API.</p></td></tr><tr><td align="left" valign="top"><p>synchronous</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).</p></td></tr></tbody></table></div><p>{% endraw %}</p><p>You can also configure the CXF REST endpoint through the spring
configuration. Since there are lots of difference between the CXF REST
client and CXF REST Server, we provide different configuration for
them. Please check out the
<a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">schema
file</a> and <a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS" target="_top">CXF JAX-RS
documentation</a> for more information.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-HowtoconfiguretheRESTendpointinCamel"></a>How to configure the REST endpoint in Camel</h2></div></div></div><p>In
<a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">camel-cxf
schema file</a>, there are two elements for the REST endpoint definition.
<span class="strong"><strong>cxf:rsServer</strong></span> for REST consumer, <span class="strong"><strong>cxf:rsClient</strong></span> for REST producer.
 You can find a Camel REST service route configuration example here.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-HowtooverridetheCXFproduceraddressfrommessageheader"></a>How to override the CXF producer address from message header</h2></div></div></div><p>The&nbsp;<code class="literal">camel-cxfrs</code>&nbsp;producer supports to override the services address by
setting the message with the key of "CamelDestinationOverrideUrl".</p><pre class="programlisting"> <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// set up the service address from the message header to override the setting of CXF endpoint</em>
 exchange.getIn().setHeader(Exchange.DESTINATION_OVERRIDE_URL, constant(getServiceAddress()));</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-ConsumingaRESTRequest-SimpleBindingStyle"></a>Consuming a REST Request - Simple Binding Style</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-EnablingtheSimpleBindingStyle">Enabling the Simple Binding Style</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-Examplesofrequestbindingwithdifferentmethodsignatures">Examples of request binding with different method signatures</a></span></dt><dt><span class="section"><a href="CXFRS-CXFRSComponent.html#CXFRS-MoreexamplesoftheSimpleBindingStyle">More examples of the Simple Binding Style</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel 2.11</strong></span></p><p>The <code class="literal">Default</code> binding style is rather low-level, requiring the user to
manually process the <code class="literal">MessageContentsList</code> object coming into the route.
Thus, it tightly couples the route logic with the method signature and
parameter indices of the JAX-RS operation. Somewhat inelegant, difficult
and error-prone.</p><p>In contrast, the <code class="literal">SimpleConsumer</code> binding style performs the following
mappings, in order to <span class="strong"><strong>make the request data more accessible</strong></span> to you
within the Camel Message:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">JAX-RS Parameters (@HeaderParam, @QueryParam, etc.) are injected as IN
message headers. The header name matches the value of the annotation.</li><li class="listitem">The request entity (POJO or other type) becomes the IN message body.
If a single entity cannot be identified in the JAX-RS method signature,
it falls back to the original <code class="literal">MessageContentsList</code>.</li><li class="listitem">Binary <code class="literal">@Multipart</code> body parts become IN message attachments,
supporting <code class="literal">DataHandler</code>, <code class="literal">InputStream</code>, <code class="literal">DataSource</code> and CXF&#8217;s
<code class="literal">Attachment</code> class.</li><li class="listitem">Non-binary <code class="literal">@Multipart</code> body parts are mapped as IN message headers.
The header name matches the Body Part name.</li></ul></div><p>Additionally, the following rules apply to the <span class="strong"><strong>Response mapping</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">If the message body type is different to <code class="literal">javax.ws.rs.core.Response</code>
(user-built response), a new <code class="literal">Response</code> is created and the message body
is set as the entity (so long it&#8217;s not null). The response status code
is taken from the <code class="literal">Exchange.HTTP_RESPONSE_CODE</code> header, or defaults to
200 OK if not present.</li><li class="listitem">If the message body type is equal to <code class="literal">javax.ws.rs.core.Response</code>, it
means that the user has built a custom response, and therefore it is
respected and it becomes the final response.</li><li class="listitem">In all cases, Camel headers permitted by custom or default
<code class="literal">HeaderFilterStrategy</code> are added to the HTTP response.</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CXFRS-EnablingtheSimpleBindingStyle"></a>Enabling the Simple Binding Style</h3></div></div></div><p>This binding style can be activated by setting the <code class="literal">bindingStyle</code>
parameter in the consumer endpoint to value <code class="literal">SimpleConsumer</code>:</p><pre class="programlisting">  from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"cxfrs:bean:rsServer?bindingStyle=SimpleConsumer"</em></strong>)
    .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"log:TEST?showAll=true"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CXFRS-Examplesofrequestbindingwithdifferentmethodsignatures"></a>Examples of request binding with different method signatures</h3></div></div></div><p>Below is a list of method signatures along with the expected result from
the Simple binding.</p><p><span class="strong"><strong><code class="literal">public Response doAction(BusinessObject request);</code></strong></span>
 Request payload is placed in IN message body, replacing the original
MessageContentsList.</p><p><span class="strong"><strong><code class="literal">public Response doAction(BusinessObject request, @HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);</code></strong></span>
 Request payload placed in IN message body, replacing the original
MessageContentsList. Both request params mapped as IN message headers
with names abcd and defg.</p><p><span class="strong"><strong><code class="literal">public Response doAction(@HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);</code></strong></span>
 Both request params mapped as IN message headers with names abcd and
defg. The original MessageContentsList is preserved, even though it only
contains the 2 parameters.</p><p><span class="strong"><strong><code class="literal">public Response doAction(@Multipart(value="body1") BusinessObject request, @Multipart(value="body2") BusinessObject request2);</code></strong></span>
 The first parameter is transferred as a header with name body1, and the
second one is mapped as header body2. The original MessageContentsList
is preserved as the IN message body.</p><p><span class="strong"><strong><code class="literal">public Response doAction(InputStream abcd);</code></strong></span>
 The InputStream is unwrapped from the MessageContentsList and preserved
as the IN message body.</p><p><span class="strong"><strong><code class="literal">public Response doAction(DataHandler abcd);</code></strong></span>
 The DataHandler is unwrapped from the MessageContentsList and preserved
as the IN message body.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CXFRS-MoreexamplesoftheSimpleBindingStyle"></a>More examples of the Simple Binding Style</h3></div></div></div><p>Given a JAX-RS resource class with this method:</p><pre class="programlisting">    <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@POST</span></em> <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Path("/customers/{type}")</span></em>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> Response newCustomer(Customer customer, <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@PathParam("type")</span></em> String type, <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@QueryParam("active")</span></em> <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@DefaultValue("true")</span></em> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">boolean</strong> active) {
        <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</strong> null;
    }</pre><p>Serviced by the following route:</p><pre class="programlisting">    from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"cxfrs:bean:rsServer?bindingStyle=SimpleConsumer"</em></strong>)
        .recipientList(simple(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:${header.operationName}"</em></strong>));

    from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:newCustomer"</em></strong>)
        .log(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Request: type=${header.type}, active=${header.active}, customerData=${body}"</em></strong>);</pre><p>The following HTTP request with XML payload (given that the Customer DTO
is JAXB-annotated):</p><pre class="programlisting">POST /customers/gold?active=true

Payload:
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;Customer&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;fullName&gt;</strong>Raul Kripalani<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/fullName&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;country&gt;</strong>Spain<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/country&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;project&gt;</strong>Apache Camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/project&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/Customer&gt;</strong></pre><p>Will print the message:</p><pre class="programlisting">Request: type=gold, active=true, customerData=<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;Customer.toString()</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">representation&gt;</span></pre><p>For more examples on how to process requests and write responses can be
found
<a class="link" href="https://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/simplebinding/" target="_top">here</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-ConsumingaRESTRequest-DefaultBindingStyle"></a>Consuming a REST Request - Default Binding Style</h2></div></div></div><p>The&nbsp;<a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS" target="_top">CXF JAXRS front end</a>
implements the <a class="link" href="https://jsr311.java.net/" target="_top">JAX-RS (JSR-311) API</a>, so we can
export the resources classes as a REST service. And we leverage the
<a class="link" href="http://cwiki.apache.org/confluence/display/CXF20DOC/Invokers" target="_top">CXF Invoker
API</a> to turn a REST request into a normal Java object method
invocation.
 Unlike the <a class="link" href="restlet.html" target="_top">Camel Restlet</a>&nbsp;component, you don&#8217;t need
to specify the URI template within your endpoint, CXF takes care of the
REST request URI to resource class method mapping according to the
JSR-311 specification. All you need to do in Camel is delegate this
method request to a right processor or endpoint.</p><p>Here is an example of a CXFRS route&#8230;&#8203;</p><p>And the corresponding resource class used to configure the endpoint&#8230;&#8203;</p><p>INFO:*Note about resource classes*</p><p>By default, JAX-RS resource classes are <span class="strong"><strong>only*used to configure JAX-RS
properties. Methods will *not</strong></span> be executed during routing of messages to
the endpoint. Instead, it is the responsibility of the route to do all
processing.</p><p>Note that starting from Camel 2.15 it is also sufficient to provide an
interface only as opposed to a no-op service implementation class for
the default mode.</p><p>Starting from Camel 2.15, if a <span class="strong"><strong>performInvocation</strong></span> option is enabled,
the service implementation will be invoked first, the response will be
set on the Camel exchange and the route execution will continue as
usual. This can be useful for integrating the existing JAX-RS implementations into Camel routes and
for post-processing JAX-RS Responses in custom processors.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CXFRS-HowtoinvoketheRESTservicethroughcamel-cxfrsproducer"></a>How to invoke the REST service through camel-cxfrs producer</h2></div></div></div><p>The&nbsp;<a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS" target="_top">CXF JAXRS front end</a>
implements
<a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-Proxy-basedAPI" target="_top">a
proxy-based client API</a>, with this API you can invoke the remote REST
service through a proxy. The&nbsp;<code class="literal">camel-cxfrs</code> producer is based on this
<a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-Proxy-basedAPI" target="_top">proxy
API</a>.
 You just need to specify the operation name in the message header and
prepare the parameter in the message body, the camel-cxfrs&nbsp;producer will
generate right REST request for you.</p><p>Here is an example:</p><p>The&nbsp;<a class="link" href="https://cwiki.apache.org/CXF20DOC/JAX-RS" target="_top">CXF JAXRS front end</a> also
provides
<a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS+Client+API#JAX-RSClientAPI-CXFWebClientAPI" target="_top">a
http centric client API</a>.&nbsp;You can also invoke this API from
<code class="literal">camel-cxfrs</code> producer. You need to specify the
<a class="link" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/Exchange.html#HTTP_PATH" target="_top">HTTP_PATH</a>
and
the&nbsp;<a class="link" href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/Exchange.html#HTTP_METHOD" target="_top">HTTP_METHOD</a>&nbsp;and
let the&nbsp;producer use the http centric client API by using the URI option
<span class="strong"><strong>httpClientAPI</strong></span> or by setting the message header
<a class="link" href="http://camel.apache.org/maven/current/camel-cxf/apidocs/org/apache/camel/component/cxf/CxfConstants.html#CAMEL_CXF_RS_USING_HTTP_API" target="_top">CxfConstants.CAMEL_CXF_RS_USING_HTTP_API</a>.
You can turn the response object to the type class specified with the
message
header&nbsp;<a class="link" href="http://camel.apache.org/maven/current/camel-cxf/apidocs/org/apache/camel/component/cxf/CxfConstants.html#CAMEL_CXF_RS_RESPONSE_CLASS" target="_top">CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS</a>.</p><p>From Camel 2.1, we also support to specify the query parameters from
cxfrs URI for the CXFRS http centric client.</p><p>Error formatting macro: snippet: java.lang.IndexOutOfBoundsException:
Index: 20, Size: 20</p><p>To support the Dynamical routing, you can override the URI&#8217;s query
parameters by using the CxfConstants.CAMEL_CXF_RS_QUERY_MAP header to
set the parameter map for it.</p></div></div></body></html>