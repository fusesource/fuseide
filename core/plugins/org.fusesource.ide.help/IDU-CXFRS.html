<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>CXFRS</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-CXFBeanComponent.html" title="CXF Bean Component"><link rel="next" href="IDU-DataFormatComponent.html" title="DataFormat Component"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-CXFRS"></a>CXFRS</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_CXFRSComponent"></a>CXFRS Component</h2></div></div></div><p>The <span class="bold"><strong>cxfrs:</strong></span> component provides integration with <a class="link" href="http://incubator.apache.org/cxf/" target="_top">Apache CXF</a> for connecting to
            JAX-RS services hosted in CXF.</p><p>Maven users will need to add the following dependency to their <code class="code">pom.xml</code>
            for this component:</p><pre class="programlisting">&lt;dependency&gt;
   &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
   &lt;artifactId&gt;camel-cxf&lt;/artifactId&gt;
   &lt;version&gt;x.x.x&lt;/version&gt;  &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When using CXF as a consumer, the CXF Bean
                    Component allows you to factor out how message payloads are received
                from their processing as a RESTful or SOAP web service. This has the potential of
                using a multitude of transports to consume web services. The bean component's
                configuration is also simpler and provides the fastest method to implement web
                services using Camel and CXF.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_URIformat"></a>URI format</h2></div></div></div><pre class="programlisting">cxfrs://address?options</pre><p>Where <span class="bold"><strong>address</strong></span> represents the CXF endpoint's
            address</p><pre class="programlisting">cxfrs:bean:rsEndpoint</pre><p>Where <span class="bold"><strong>rsEndpoint</strong></span> represents the Spring bean's name
            which represents the CXFRS client or server</p><p>For either style above, you can append options to the URI as follows:</p><pre class="programlisting">cxfrs:bean:cxfEndpoint?resourceClasses=org.apache.camel.rs.Example</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_Options"></a>Options</h2></div></div></div><table id="d0e68528"><tr>
                <th> Name </th>
                <th> Description </th>
                <th> Example </th>
                <th> Required? </th>
                <th> default value </th>
            </tr><tr>
                <td><code class="literal">resourceClasses</code>
                </td>
                <td> The resource classes which you want to export as REST service. Multiple classes
                    can be separated by a comma.</td>
                <td>
                    <p><code class="literal">resourceClasses=org.apache.camel.rs.Example1,</code><code class="literal">org.apache.camel.rs.Exchange2</code>
                    </p>
                </td>
                <td>No</td>
                <td><span class="emphasis"><em>None</em></span>
                </td>
            </tr><tr>
                <td><code class="literal">httpClientAPI</code>
                </td>
                <td><span class="bold"><strong>New to Apache Camel 2.1</strong></span> If true, the
                    CxfRsProducer will use the HttpClientAPI to invoke the service </td>
                <td><code class="code">httpClientAPI=true</code>
                </td>
                <td>No </td>
                <td><code class="code">true</code>
                </td>
            </tr><tr>
                <td><code class="code">synchronous</code></td>
                <td> New in 2.5, this option will let CxfRsConsumer decide to use sync or async API
                    to do the underlying work. The default value is false which means it will try to
                    use async API by default.</td>
                <td>
                    <code class="code">synchronous=true</code></td>
                <td>No</td>
                <td>
                    <code class="code">false</code></td>
            </tr><tr>
                <td><code class="code">throwExceptionOnFailure</code></td>
                <td> New in 2.6, this option tells the CxfRsProducer to inspect return codes and
                    will generate an Exception if the return code is larger than 207.</td>
                <td><code class="code">throwExceptionOnFailure=true</code>
                </td>
                <td> No </td>
                <td>
                    <code class="code">true</code></td>
            </tr><tr>
                <td><code class="literal">maxClientCacheSize</code>
                </td>
                <td> New in 2.6, you can set the <span class="emphasis"><em>In</em></span> message header,
                        <code class="code">CamelDestinationOverrideUrl</code>, to dynamically override the target
                    destination Web Service or REST Service defined in your routes. The
                    implementation caches CXF clients or <code class="code">ClientFactoryBean</code> in
                        <code class="code">CxfProvider</code> and <code class="code">CxfRsProvider</code>. This option allows
                    you to configure the maximum size of the cache.</td>
                <td>
                    <code class="code">maxClientCacheSize=5</code></td>
                <td> No </td>
                <td> 10 </td>
            </tr><tr>
                <td><code class="literal">setDefaultBus</code>
                </td>
                <td>
                    <span class="bold"><strong>Deprecated:</strong></span> Use <code class="code">defaultBus</code> option
                    from Camel 2.16 onwards. Will set the default bus when CXF endpoint create a bus
                    by itself </td>
                <td><code class="literal">setDefaultBus=true</code>
                </td>
                <td> No </td>
                <td><code class="literal">false</code>
                </td>
            </tr><tr>
                <td><code class="literal">defaultBus</code>
                </td>
                <td> Will set the default bus when CXF endpoint create a bus by itself </td>
                <td><code class="literal">defaultBus=true</code>
                </td>
                <td> No </td>
                <td><code class="literal">false</code>
                </td>
            </tr><tr>
                <td><code class="literal">bus</code>
                </td>
                <td> New in 2.9.0. A default bus created by CXF Bus Factory. Use <code class="literal">\#</code> notation to reference a bus object from the registry. The referenced object must be an instance of <code class="literal">org.apache.cxf.Bus</code>. </td>
                <td><code class="literal">bus=#busName</code>
                </td>
                <td> No </td>
                <td><span class="emphasis"><em>None</em></span></td>
            </tr><tr>
                <td><code class="literal">bindingStyle</code>
                </td>
                <td>
                    <p><span class="bold"><strong>As of 2.11</strong></span>. Sets how requests and responses will be mapped to/from Camel. Two values are possible: </p>
                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">SimpleConsumer</code> =&gt; see the <a class="link" href="IDU-CXFRS_HSH_ConsumingaRESTRequestSimpleBindingStyle" target="_top">Consuming a REST Request with the Simple Binding Style</a> below.</p></li><li class="listitem"><p><code class="literal">Default</code> =&gt; the default style. For consumers this passes on a <code class="literal">MessageContentsList</code> to the route, requiring low-level processing in the route. </p></li><li class="listitem"><p>Custom =&gt; allows you to specify a custom binding
                                through the <code class="code">binding</code> option.</p></li></ul></div>
                </td>
                <td><code class="literal">bindingStyle=SimpleConsumer</code>
                </td>
                <td> No </td>
                <td><span class="emphasis"><em>Default</em></span>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">binding</code></p>
                </td>
                <td>
                    <p>Allows you to specify a custom <code class="code">CxfRsBinding</code>
                        implementation to perform low-level processing of the raw CXF
                        request and response objects. The implementation must be bound in
                        the Camel registry, and you must use the hash (#) notation to refer
                        to it.</p>
                </td>
                <td>
                    <p><code class="code">binding=#myBinding</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><code class="code">DefaultCxfRsBinding</code></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">providers</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.2</strong></span> set custom
                        JAX-RS providers list to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">providers=#MyProviders</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">schemaLocations</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.2</strong></span> Sets the
                        locations of the schemas which can be used to validate the incoming
                        XML or JAXB-driven JSON.</p>
                </td>
                <td>
                    <p><code class="code">schemaLocations=#MySchemaLocations</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">features</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.3</strong></span> Set the
                        feature list to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">features=#MyFeatures</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">properties</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.4</strong></span> Set the
                        properties to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">properties=#MyProperties</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">inInterceptors</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.4</strong></span> Set the
                        inInterceptors to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">inInterceptors=#MyInterceptors</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">outInterceptors</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.4</strong></span> Set the
                        outInterceptor to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">outInterceptors=#MyInterceptors</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">inFaultInterceptors</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.4</strong></span> Set the
                        inFaultInterceptors to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">inFaultInterceptors=#MyInterceptors</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">outFaultIntercetpros</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since Camel 2.12.4</strong></span> Set the
                        outFaultInterceptors to the CxfRs endpoint.</p>
                </td>
                <td>
                    <p><code class="code">outFaultInterceptors=#MyInterceptors</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">continuationTimeout</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.14.0 </strong></span>This option is used
                        to set the CXF continuation timeout which could be used in
                        CxfConsumer by default when the CXF server is using Jetty or Servlet
                        transport. (Before <span class="strong"><strong>Camel 2.14.0</strong></span>,
                        CxfConsumer just set the continuation timeout to be 0, which means
                        the continuation suspend operation never timeout.)</p>
                </td>
                <td>
                    <p><code class="code">continuationTimeout=800000</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">30000</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">ignoreDeleteMethodMessageBody</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.14.1</strong></span> This option is used to tell
                            <code class="code">CxfRsProducer</code> to ignore the message body of the
                            <code class="code">DELETE</code> method when using HTTP API.</p>
                </td>
                <td>
                    <p><code class="code">ignoreDeleteMethodMessageBody=true</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">false</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">modelRef</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.14.2</strong></span> This option is used to
                        specify the <a class="link" href="http://cxf.apache.org/docs/jax-rs-advanced-features.html#JAX-RSAdvancedFeatures-RESTfulserviceswithoutannotations" target="_top">model file</a> which is useful for the resource class without
                        annotation.</p>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.15</strong></span> This option can point to a
                        model file without specifying a service class for emulating document-only
                        endpoints.</p>
                </td>
                <td>
                    <p><code class="code">modelRef=classpath:/CustomerServiceModel.xml</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">None</span></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">performInvocation</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.15</strong></span> When the option is true, camel
                        will perform the invocation of the resource class instance and put the
                        response object into the exchange for further processing.</p>
                </td>
                <td>
                    <p><code class="code">performInvocation=true</code></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><span class="italics">false</span></p>
                </td>
            </tr><tr>
                <td><code class="literal">loggingFeatureEnabled</code>
                </td>
                <td>This option enables CXF logging feature which writes inbound and outbound REST messages to log</td>
                <td>-
                </td>
                <td>No </td>
                <td><code class="code">false</code>
                </td>
            </tr><tr>
                <td><code class="literal">skipFaultLogging</code>
                </td>
                <td>This option controls whether the <em class="parameter"><code>PhaseInterceptorChain</code></em> skips logging the Fault that it catches</td>
                <td>-
                </td>
                <td>No </td>
                <td><code class="code">false</code>
                </td>
            </tr><tr>
                <td><code class="literal">loggingSizeLimit</code>
                </td>
                <td>When you enable the logging feature, this option is used to limit the total size of number of bytes the logger will output</td>
                <td>-
                </td>
                <td>No </td>
                <td><code class="code">0</code>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">propagateContexts</code></p>
                </td>
                <td>
                    <p><span class="strong"><strong>Since</strong></span>
                        <span class="strong"><strong>Camel 2.15</strong></span> When <code class="code">true</code>, JAXRS
                        UriInfo, HttpHeaders, Request and SecurityContext contexts will be available
                        to custom CXFRS processors as typed Camel exchange properties. These
                        contexts can be used to analyze the current requests using JAX-RS
                        API.</p>
                </td>
                <td>
                    <p></p>
                </td>
                <td>
                    <p></p>
                </td>
                <td>
                    <p></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">loggingFeatureEnabled</code></p>
                </td>
                <td>
                    <p>This option enables CXF Logging Feature which writes inbound and outbound
                        REST messages to log.</p>
                </td>
                <td>
                    <p></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><code class="code">false</code></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">skipFaultLogging</code></p>
                </td>
                <td>
                    <p>This option controls whether the PhaseInterceptorChain skips logging the
                        Fault that it catches.</p>
                </td>
                <td>
                    <p></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><code class="code">false</code></p>
                </td>
            </tr><tr>
                <td>
                    <p><code class="code">loggingSizeLimit</code></p>
                </td>
                <td>
                    <p>To limit the total size of number of bytes the logger will output when
                        logging feature has been enabled.</p>
                </td>
                <td>
                    <p></p>
                </td>
                <td>
                    <p>No</p>
                </td>
                <td>
                    <p><code class="code">0</code></p>
                </td>
            </tr></table><p>You can also configure the CXF REST endpoint through the Spring configuration. Since
            there are lots of differences between the CXF REST client and CXF REST Server, we
            provide different configurations for them. Please check out the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">schema file</a> and the <a class="link" href="https://cxf.apache.org/docs/jax-rs.html" target="_top">CXF JAX-RS documentation</a> for more information.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_HowtoconfiguretheRESTendpointinCamel"></a>How to configure the REST endpoint in Apache Camel</h2></div></div></div><p>In <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">camel-cxf schema file</a>, there are two elements for the REST endpoint
            definition. <span class="bold"><strong>cxf:rsServer</strong></span> for REST consumer, <span class="bold"><strong>cxf:rsClient</strong></span> for REST producer. You can find a Apache Camel REST
            service route configuration example here.</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://camel.apache.org/schema/cxf"
       xmlns:jaxrs="http://cxf.apache.org/jaxrs"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
       http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
    "&gt;
  &lt;!-- Defined the real JAXRS back end service  --&gt;
  &lt;jaxrs:server id="restService"
		        address="http://localhost:9002/rest" 
		        staticSubresourceResolution="true"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="customerService"/&gt;
    &lt;/jaxrs:serviceBeans&gt;       
  &lt;/jaxrs:server&gt;
  
  &lt;!--bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.JSONProvider"/--&gt;

  &lt;bean id="customerService" class="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService" /&gt;
   
  &lt;!-- Defined the server endpoint to create the cxf-rs consumer --&gt; 
  &lt;cxf:rsServer id="rsServer" address="http://localhost:9000/route"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService" 
      loggingFeatureEnabled="true" loggingSizeLimit="20" skipFaultLogging="true"/&gt;

  &lt;!-- Defined the client endpoint to create the cxf-rs consumer --&gt;
  &lt;cxf:rsClient id="rsClient" address="http://localhost:9002/rest"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService"
      loggingFeatureEnabled="true" skipFaultLogging="true"/&gt;
  
  &lt;!-- The camel route context --&gt;
  &lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
       &lt;from uri="cxfrs://bean://rsServer"/&gt;
       &lt;!-- We can remove this configure as the CXFRS producer is using the HttpAPI by default --&gt;
       &lt;setHeader headerName="CamelCxfRsUsingHttpAPI"&gt;
         &lt;constant&gt;True&lt;/constant&gt;        
       &lt;/setHeader&gt;
       &lt;to uri="cxfrs://bean://rsClient"/&gt;
    &lt;/route&gt;
  &lt;/camelContext&gt;
  
&lt;/beans&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e69553"></a>How to override the CXF producer address from message header</h2></div></div></div><p>The camel-cxfrs producer supports to override the services address by setting the
            message with the key of "CamelDestinationOverrideUrl".</p><pre class="programlisting">// set up the service address from the message header to override the setting of CXF endpoint
exchange.getIn().setHeader(Exchange.DESTINATION_OVERRIDE_URL, constant(getServiceAddress()));</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_ConsumingaRESTRequestSimpleBindingStyle"></a>Consuming a REST Request - Simple Binding Style</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.11</strong></span>
        </p><p>The <code class="literal">Default</code> binding style is rather low-level, requiring the user to manually process the <code class="literal">MessageContentsList</code> object coming into the route. Thus, it tightly couples the route logic with the method signature and parameter indices of the JAX-RS operation. Somewhat inelegant, difficult and error-prone.</p><p>In contrast, the <code class="literal">SimpleConsumer</code> binding style performs the following mappings, in order to <span class="bold"><strong>make the request data more accessible</strong></span> to you within the Camel Message:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JAX-RS Parameters (@HeaderParam, @QueryParam, etc.) are injected as IN message headers. The header name matches the value of the annotation.</p></li><li class="listitem"><p>The request entity (POJO or other type) becomes the IN message body. If a single entity cannot be identified in the JAX-RS method signature, it falls back to the original <code class="literal">MessageContentsList</code>.</p></li><li class="listitem"><p>Binary <code class="literal">@Multipart</code> body parts become IN message attachments, supporting <code class="literal">DataHandler</code>, <code class="literal">InputStream</code>, <code class="literal">DataSource</code> and CXF's <code class="literal">Attachment</code> class.</p></li><li class="listitem"><p>Non-binary <code class="literal">@Multipart</code> body parts are mapped as IN message headers. The header name matches the Body Part name.</p></li></ul></div><p>Additionally, the following rules apply to the <span class="bold"><strong>Response mapping</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If the message body type is different to <code class="literal">javax.ws.rs.core.Response</code> (user-built response), a new <code class="literal">Response</code> is created and the message body is set as the entity (so long it's not null). The response status code is taken from the <code class="literal">Exchange.HTTP_RESPONSE_CODE</code> header, or defaults to 200 OK if not present.</p></li><li class="listitem"><p>If the message body type is equal to <code class="literal">javax.ws.rs.core.Response</code>, it means that the user has built a custom response, and therefore it is respected and it becomes the final response.</p></li><li class="listitem"><p>In all cases, Camel headers permitted by custom or default <code class="literal">HeaderFilterStrategy</code> are added to the HTTP response.</p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_EnablingtheSimpleBindingStyle"></a>Enabling the Simple Binding Style</h2></div></div></div><p>This binding style can be activated by setting the <code class="literal">bindingStyle</code> parameter in the consumer endpoint to value <code class="literal">SimpleConsumer</code>:</p><pre class="programlisting">
  from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
    .to("log:TEST?showAll=true");
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_Examplesofrequestbindingwithdifferentmethodsignatures"></a>Examples of request binding with different method signatures</h2></div></div></div><p></p><p>Below is a list of method signatures along with the expected result from the Simple binding.</p><p><span class="bold"><strong><code class="literal">public Response doAction(BusinessObject request);</code></strong></span>
            Request payload is placed in IN message body, replacing the original MessageContentsList.</p><p><span class="bold"><strong><code class="literal">public Response doAction(BusinessObject request, @HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);</code></strong></span>
            Request payload placed in IN message body, replacing the original MessageContentsList. Both request params mapped as IN message headers with names abcd and defg.</p><p><span class="bold"><strong><code class="literal">public Response doAction(@HeaderParam("abcd") String abcd, @QueryParam("defg") String defg);</code></strong></span>
            Both request params mapped as IN message headers with names abcd and defg. The original MessageContentsList is preserved, even though it only contains the 2 parameters.</p><p><span class="bold"><strong><code class="literal">public Response doAction(@Multipart(value="body1") BusinessObject request, @Multipart(value="body2") BusinessObject request2);</code></strong></span>
            The first parameter is transferred as a header with name body1, and the second one is mapped as header body2. The original MessageContentsList is preserved as the IN message body.</p><p><span class="bold"><strong><code class="literal">public Response doAction(InputStream abcd);</code></strong></span>
            The InputStream is unwrapped from the MessageContentsList and preserved as the IN message body. </p><p><span class="bold"><strong><code class="literal">public Response doAction(DataHandler abcd);</code></strong></span>
            The DataHandler is unwrapped from the MessageContentsList and preserved as the IN message body. </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_MoreexamplesoftheSimpleBindingStyle"></a>More examples of the Simple Binding Style</h2></div></div></div><p></p><p>Given a JAX-RS resource class with this method:</p><pre class="programlisting">
    @POST @Path("/customers/{type}")
    public Response newCustomer(Customer customer, @PathParam("type") String type, @QueryParam("active") @DefaultValue("true") boolean active) {
        return null;
    }
</pre><p>Serviced by the following route:</p><pre class="programlisting">
    from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
        .recipientList(simple("direct:${header.operationName}"));

    from("direct:newCustomer")
        .log("Request: type=${header.type}, active=${header.active}, customerData=${body}");
</pre><p>The following HTTP request with XML payload (given that the Customer DTO is JAXB-annotated):</p><pre class="programlisting">
POST /customers/gold?active=true

Payload:
&lt;Customer&gt;
  &lt;fullName&gt;Raul Kripalani&lt;/fullName&gt;
  &lt;country&gt;Spain&lt;/country&gt;
  &lt;project&gt;Apache Camel&lt;/project&gt;
&lt;/Customer&gt;
</pre><p>Will print the message:</p><pre class="programlisting">
Request: type=gold, active=true, customerData=&lt;Customer.toString() representation&gt;
</pre><p>For more examples on how to process requests and write responses can be found <a class="link" href="https://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/simplebinding/" target="_top">here</a>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_ConsumingaRESTRequestDefaultBindingStyle"></a>Consuming a REST Request - Default Binding Style</h2></div></div></div><p> The <a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS" target="_top">CXF JAX-RS front
                end</a> implements the <a class="link" href="https://jsr311.dev.java.net/" target="_top">JAX-RS
                (JSR-311) API</a>, so we can export the resources classes as a REST service. And
            we leverage the <a class="link" href="http://cwiki.apache.org/confluence/display/CXF20DOC/Invokers" target="_top">CXF Invoker
                API</a> to turn a REST request into a normal Java object method invocation.
            Unlike the <code class="literal">camel-restlet</code> component, you don't need to specify the URI
            template within your endpoint, CXF takes care of the REST request URI to resource class
            method mapping according to the JSR-311 specification. All you need to do in Apache Camel is
            delegate this method request to a right processor or endpoint.</p><p>Here is an example of a CXFRS route:</p><pre class="programlisting">private static final String CXF_RS_ENDPOINT_URI = "cxfrs://http://localhost:" + CXT + "/rest?resourceClasses=org.apache.camel.component.cxf.jaxrs.testbean.CustomerServiceResource";
 
 protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {
        public void configure() {
            errorHandler(new NoErrorHandlerBuilder());
            from(CXF_RS_ENDPOINT_URI).process(new Processor() {

                public void process(Exchange exchange) throws Exception {
                    Message inMessage = exchange.getIn();                        
                    // Get the operation name from in message
                    String operationName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);
                    if ("getCustomer".equals(operationName)) {
                        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);
                        assertEquals("Get a wrong http method", "GET", httpMethod);
                        String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);
                        // The parameter of the invocation is stored in the body of in message
                        String id = inMessage.getBody(String.class);
                        if ("/customerservice/customers/126".equals(path)) {                            
                            Customer customer = new Customer();
                            customer.setId(Long.parseLong(id));
                            customer.setName("Willem");
                            // We just put the response Object into the out message body
                            exchange.getOut().setBody(customer);
                        } else {
                            if ("/customerservice/customers/400".equals(path)) {
                                // We return the remote client IP address this time
                                org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);
                                ServletRequest request = (ServletRequest) cxfMessage.get("HTTP.REQUEST");
                                String remoteAddress = request.getRemoteAddr();
                                Response r = Response.status(200).entity("The remoteAddress is " + remoteAddress).build();
                                exchange.getOut().setBody(r);
                                return;
                            }
                            if ("/customerservice/customers/123".equals(path)) {
                                 // send a customer response back
                                 Response r = Response.status(200).entity("customer response back!").build();
                                 exchange.getOut().setBody(r);
                                 return;
                            }
                            if ("/customerservice/customers/456".equals(path)) {
                                Response r = Response.status(404).entity("Can't found the customer with uri " + path).build();
                                throw new WebApplicationException(r);
                            } else {
                                throw new RuntimeCamelException("Can't found the customer with uri " + path);
                            }
                        }
                    }
                    if ("updateCustomer".equals(operationName)) {
                        assertEquals("Get a wrong customer message header", "header1;header2", inMessage.getHeader("test"));
                        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);
                        assertEquals("Get a wrong http method", "PUT", httpMethod);
                        Customer customer = inMessage.getBody(Customer.class);
                        assertNotNull("The customer should not be null.", customer);
                        // Now you can do what you want on the customer object
                        assertEquals("Get a wrong customer name.", "Mary", customer.getName());
                        // set the response back
                        exchange.getOut().setBody(Response.ok().build());
                }
                }
                
            });
        }
    };
}
        </pre><p>The corresponding resource class used to configure the endpoint is defined as an interface:</p><pre class="programlisting">@Path("/customerservice/")
public interface CustomerServiceResource {
 
    @GET
    @Path("/customers/{id}/")
    Customer getCustomer(@PathParam("id") String id);
 
    @PUT
    @Path("/customers/")
    Response updateCustomer(Customer customer);
 }
 </pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>By default, JAX-RS resource classes are used to configure the JAX-RS properties
                    <span class="emphasis"><em>only</em></span>. The methods will <span class="emphasis"><em>not</em></span> be executed
                during the routing of messages to the endpoint, the route itself is responsible for
                all processing instead.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Note that starting from Camel 2.15, it is also sufficient to provide an interface
                only, as opposed to a no-op service implementation class for the default mode.
                Starting from Camel 2.15, if the <code class="code">performInvocation</code> option is enabled,
                the service implementation will be invoked first, the response will be set on the
                Camel exchange and the route execution will continue as usual. This can be useful
                for integrating the existing JAX-RS implementations into Camel routes and for
                post-processing JAX-RS Responses in custom processors.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-CXFRS_HSH_HowtoinvoketheRESTservicethroughcamelcxfrsproducer"></a>How to invoke the REST service through camel-cxfrs producer ?</h2></div></div></div><p>The <a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS" target="_top">CXF JAXRS front
                end</a> implements <a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS#JAX-RS-ProxybasedAPI" target="_top">a
                proxy-based client API</a>, with this API you can invoke the remote REST service
            through a proxy. The <code class="literal">camel-cxfrs</code> producer is based on this <a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS#JAX-RS-ProxybasedAPI" target="_top">proxy
                API</a>. You just need to specify the operation name in the message header and
            prepare the parameter in the message body, the <code class="code">camel-cxfrs</code> producer will
            generate the right REST request for you.</p><p>Here is an example:</p><pre class="programlisting">Exchange exchange = template.send("direct://proxy", new Processor() {

    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(ExchangePattern.InOut);
        Message inMessage = exchange.getIn();
        setupDestinationURL(inMessage);
        // set the operation name 
        inMessage.setHeader(CxfConstants.OPERATION_NAME, "getCustomer");
        // using the proxy client API
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_USING_HTTP_API, Boolean.FALSE);
        // set a customer header
        inMessage.setHeader("key", "value");
        // set the parameters , if you just have one parameter 
        // camel will put this object into an Object[] itself
        inMessage.setBody("123");
    }
    
});
     
// get the response message 
Customer response = (Customer) exchange.getOut().getBody();

assertNotNull("The response should not be null ", response);
assertEquals("Get a wrong customer id ", String.valueOf(response.getId()), "123");
assertEquals("Get a wrong customer name", response.getName(), "John");
assertEquals("Get a wrong response code", 200, exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));
assertEquals("Get a wrong header value", "value", exchange.getOut().getHeader("key"));</pre><p>
            <a class="link" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS" target="_top">CXF JAXRS front end</a>
            also provides <a class="link" href="http://cxf.apache.org/docs/jax-rs.html#JAX-RS-HTTPcentricclients" target="_top">a http
                centric client API</a>, You can also invoke this API from
                <code class="literal">camel-cxfrs</code> producer. You need to specify the HTTP_PATH and Http
            method and let the the producer know to use the HTTP centric client by using the URI
            option <span class="bold"><strong>httpClientAPI</strong></span> or set the message header with
                <code class="code">CxfConstants.CAMEL_CXF_RS_USING_HTTP_API</code>. You can turn the response
            object to the type class that you specify with
                <code class="code">CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS</code>.</p><pre class="programlisting">Exchange exchange = template.send("direct://http", new Processor() {

    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(ExchangePattern.InOut);
        Message inMessage = exchange.getIn();
        setupDestinationURL(inMessage);
        // using the http central client API
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_USING_HTTP_API, Boolean.TRUE);
        // set the Http method
        inMessage.setHeader(Exchange.HTTP_METHOD, "GET");
        // set the relative path
        inMessage.setHeader(Exchange.HTTP_PATH, "/customerservice/customers/123");                
        // Specify the response class , cxfrs will use InputStream as the response object type 
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS, Customer.class);
        // set a customer header
        inMessage.setHeader("key", "value");
        // since we use the Get method, so we don't need to set the message body
        inMessage.setBody(null);                
    }
    
});
     
// get the response message 
Customer response = (Customer) exchange.getOut().getBody();

assertNotNull("The response should not be null ", response);
assertEquals("Get a wrong customer id ", String.valueOf(response.getId()), "123");
assertEquals("Get a wrong customer name", response.getName(), "John");
assertEquals("Get a wrong response code", 200, exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));
assertEquals("Get a wrong header value", "value", exchange.getOut().getHeader("key"));</pre><p>From Apache Camel 2.1, we also support to specify the query parameters from CXFRS URI for
            the CXFRS HTTP centric client.</p><pre class="programlisting">Exchange exchange = template.send("cxfrs://http://localhost:" + getPort2() + "/" + getClass().getSimpleName() + "/testQuery?httpClientAPI=true&amp;q1=12&amp;q2=13"</pre><p> To support the Dynamical routing, you can override the URI's query parameters by
            using the <code class="code">CxfConstants.CAMEL_CXF_RS_QUERY_MAP</code> header to set the parameter
            map for it.</p><pre class="programlisting">Map&lt;String, String&gt; queryMap = new LinkedHashMap&lt;String, String&gt;();                    
queryMap.put("q1", "new");
queryMap.put("q2", "world");                    
inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_QUERY_MAP, queryMap);</pre></div></div></body></html>