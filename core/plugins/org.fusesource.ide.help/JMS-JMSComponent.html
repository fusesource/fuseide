<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>JMS Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="JIRA-JIRA.html" title="JIRA Component"><link rel="next" href="CamelJMX-CamelJMX.html" title="JMX Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="JMS-JMSComponent"></a>JMS Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-URIformat">URI format</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Notes">Notes</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Options">Options</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-MessageMappingbetweenJMSandCamel">Message Mapping between JMS and Camel</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Messageformatwhensending">Message format when sending</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Messageformatwhenreceiving">Message format when receiving</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-AboutusingCameltosendandreceivemessagesandJMSReplyTo">About using Camel to send and receive messages and JMSReplyTo</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Reuseendpointandsendtodifferentdestinationscomputedatruntime">Reuse endpoint and send to different destinations computed at runtime</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-ConfiguringdifferentJMSproviders">Configuring different JMS providers</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-ConcurrentConsuming">Concurrent Consuming</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Request-replyoverJMS">Request-reply over JMS</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Synchronizingclocksbetweensendersandreceivers">Synchronizing clocks between senders and receivers</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Abouttimetolive">About time to live</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-EnablingTransactedConsumption">Enabling Transacted Consumption</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingJMSReplyToforlatereplies">Using JMSReplyTo for late replies</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Usingarequesttimeout">Using a request timeout</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Samples">Samples</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-SendinganInOnlymessageandkeepingtheJMSReplyToheader">Sending an InOnly message and keeping the JMSReplyTo header</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-SettingJMSprovideroptionsonthedestination">Setting JMS provider options on the destination</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-SeeAlso">See Also</a></span></dt></dl></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Using ActiveMQ</strong></span></p><p>If you are using <a class="link" href="http://activemq.apache.org/" target="_top">Apache ActiveMQ</a>, you
should prefer the <a class="link" href="activemq.html" target="_top">ActiveMQ</a> component as it has been
optimized for <a class="link" href="activemq.html" target="_top">ActiveMQ</a>. All of the options and
samples on this page are also valid for the <a class="link" href="activemq.html" target="_top">ActiveMQ</a>
component.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Transacted and caching</strong></span></p><p>See section <span class="emphasis"><em>Transactions and Cache Levels</em></span> below if you are using
transactions with <a class="link" href="jms.html" target="_top">JMS</a> as it can impact performance.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Request/Reply over JMS</strong></span></p><p>Make sure to read the section <span class="emphasis"><em>Request-reply over JMS</em></span> further below on
this page for important notes about request/reply, as Camel offers a
number of options to configure for performance, and clustered
environments.</p></td></tr></table></div><p>This&nbsp;component allows messages to be sent to (or consumed from) a
<a class="link" href="http://java.sun.com/products/jms/" target="_top">JMS</a> Queue or Topic. It uses Spring&#8217;s
JMS support for declarative transactions, including Spring&#8217;s
<code class="literal">JmsTemplate</code> for sending and a <code class="literal">MessageListenerContainer</code> for
consuming.</p><p>Maven users will need to add the following dependency to their <code class="literal">pom.xml</code>
for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-jms<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-URIformat"></a>URI format</h2></div></div></div><pre class="screen">jms:[queue:|topic:]destinationName[?options]</pre><p>Where <code class="literal">destinationName</code> is a JMS queue or topic name. By default, the
<code class="literal">destinationName</code> is interpreted as a queue name. For example, to
connect to the queue, <code class="literal">FOO.BAR</code> use:</p><pre class="screen">jms:FOO.BAR</pre><p>You can include the optional <code class="literal">queue:</code> prefix, if you prefer:</p><pre class="screen">jms:queue:FOO.BAR</pre><p>To connect to a topic, you <span class="emphasis"><em>must</em></span> include the <code class="literal">topic:</code> prefix. For
example, to
 connect to the topic, <code class="literal">Stocks.Prices</code>, use:</p><pre class="screen">jms:topic:Stocks.Prices</pre><p>You append query options to the URI using the following format,
<code class="literal">?option=value&amp;option=value&amp;&#8230;&#8203;</code></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Notes"></a>Notes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingActiveMQ">Using ActiveMQ</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-TransactionsandCacheLevels">Transactions and Cache Levels</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-DurableSubscriptions">Durable Subscriptions</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-MessageHeaderMapping">Message Header Mapping</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingActiveMQ"></a>Using ActiveMQ</h3></div></div></div><p>The JMS component reuses Spring 2&#8217;s <code class="literal">JmsTemplate</code> for sending messages.
This is not ideal for use in a non-J2EE container and typically requires
some caching in the JMS provider to avoid
<a class="link" href="http://activemq.apache.org/jmstemplate-gotchas.html" target="_top">poor performance</a>.</p><p>If you intend to use <a class="link" href="http://activemq.apache.org/" target="_top">Apache ActiveMQ</a> as
your Message Broker - which is a good choice as ActiveMQ rocks,
then we recommend that you either:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Use the <a class="link" href="activemq.html" target="_top">ActiveMQ</a> component, which is already
optimized to use ActiveMQ efficiently</li><li class="listitem">Use the <code class="literal">PoolingConnectionFactory</code> in ActiveMQ.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-TransactionsandCacheLevels"></a>Transactions and Cache Levels</h3></div></div></div><p>If you are consuming messages and using transactions
(<code class="literal">transacted=true</code>) then the default settings for cache level can impact
performance.</p><p>If you are using XA transactions then you cannot cache as it can cause
the XA transaction to not work properly.</p><p>If you are <span class="strong"><strong>not</strong></span> using XA, then you should consider caching as it speeds
up performance, such as setting <code class="literal">cacheLevelName=CACHE_CONSUMER</code>.</p><p>Through Camel 2.7.x, the default setting for <code class="literal">cacheLevelName</code> is
<code class="literal">CACHE_CONSUMER</code>. You will need to explicitly set
<code class="literal">cacheLevelName=CACHE_NONE</code>.</p><p>In Camel 2.8 onwards, the default setting for <code class="literal">cacheLevelName</code> is
<code class="literal">CACHE_AUTO</code>. This default auto detects the mode and sets the cache
level accordingly to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">CACHE_CONSUMER</code> if <code class="literal">transacted=false</code></li><li class="listitem"><code class="literal">CACHE_NONE</code> if <code class="literal">transacted=true</code></li></ul></div><p>So you can say the default setting is conservative. Consider using
<code class="literal">cacheLevelName=CACHE_CONSUMER</code> if you are using non-XA transactions.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-DurableSubscriptions"></a>Durable Subscriptions</h3></div></div></div><p>If you wish to use durable topic subscriptions, you need to specify both
<code class="literal">clientId</code> and <code class="literal">durableSubscriptionName</code>. The value of the <code class="literal">clientId</code>
must be unique and can only be used by a single JMS connection instance
in your entire network. You may prefer to use
<a class="link" href="http://activemq.apache.org/virtual-destinations.html" target="_top">Virtual Topics</a>
instead to avoid this limitation. More background on durable messaging
<a class="link" href="http://activemq.apache.org/how-do-durable-queues-and-topics-work.html" target="_top">here</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-MessageHeaderMapping"></a>Message Header Mapping</h3></div></div></div><p>When using message headers, the JMS specification states that header
names must be valid Java identifiers. So try to name your headers to be
valid Java identifiers. One benefit of doing this is that you can then
use your headers inside a JMS Selector (whose SQL92 syntax mandates Java
identifier syntax for headers).</p><p>A simple strategy for mapping header names is used by default. The
strategy is to replace any dots and hyphens in the header name as shown
below and to reverse the replacement when the header name is restored
from a JMS message sent over the wire. What does this mean? No more
losing method names to invoke on a bean component, no more losing the
filename header for the File Component, and so on.</p><p>The current header name strategy for accepting header names in Camel is
as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Dots are replaced by <code class="literal">_DOT_</code> and the replacement is reversed when
Camel consume the message</li><li class="listitem">Hyphen is replaced by <code class="literal">_HYPHEN_</code> and the replacement is reversed when
Camel consumes the message</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Options"></a>Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Componentoptions">Component options</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Endpointoptions">Endpoint options</a></span></dt></dl></div><p>You can configure many different properties on the JMS endpoint which
map to properties on the
<a class="link" href="http://camel.apache.org/maven/current/camel-jms/apidocs/org/apache/camel/component/jms/JmsConfiguration.html" target="_top">JMSConfiguration
POJO</a>.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="imagesdb/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>Mapping to Spring JMS</strong></span></p><p>Many of these properties map to properties on Spring JMS, which Camel
uses for sending and receiving messages. So you can get more information
about these properties by consulting the relevant Spring documentation.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Componentoptions"></a>Component options</h3></div></div></div><p>The JMS component supports 74 options which are listed below.</p><p>{% raw %}</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="11%" class="col_2"><col width="70%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Java Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>configuration</p></td><td align="left" valign="top"><p><code class="literal">JmsConfiguration</code></p></td><td align="left" valign="top"><p>To use a shared JMS configuration</p></td></tr><tr><td align="left" valign="top"><p>acceptMessagesWhileStopping</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option if you start and stop JMS routes at runtime while there are still messages enqued on the queue. If this option is false and you stop the JMS route then messages may be rejected and the JMS broker would have to attempt redeliveries which yet again may be rejected and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.</p></td></tr><tr><td align="left" valign="top"><p>allowReplyManagerQuickStop</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfigurationisAcceptMessagesWhileStopping is enabled and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.</p></td></tr><tr><td align="left" valign="top"><p>acknowledgementMode</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The JMS acknowledgement mode defined as an Integer. Allows you to set vendor-specific extensions to the acknowledgment mode. For the regular modes it is preferable to use the acknowledgementModeName instead.</p></td></tr><tr><td align="left" valign="top"><p>eagerLoadingOfProperties</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Enables eager loading of JMS properties as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties</p></td></tr><tr><td align="left" valign="top"><p>acknowledgementModeName</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS acknowledgement name which is one of: SESSION_TRANSACTED CLIENT_ACKNOWLEDGE AUTO_ACKNOWLEDGE DUPS_OK_ACKNOWLEDGE</p></td></tr><tr><td align="left" valign="top"><p>autoStartup</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the consumer container should auto-startup.</p></td></tr><tr><td align="left" valign="top"><p>cacheLevel</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.</p></td></tr><tr><td align="left" valign="top"><p>cacheLevelName</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO CACHE_CONNECTION CACHE_CONSUMER CACHE_NONE and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.</p></td></tr><tr><td align="left" valign="top"><p>replyToCacheLevelName</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.</p></td></tr><tr><td align="left" valign="top"><p>clientId</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the JMS client ID to use. Note that this value if specified must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.</p></td></tr><tr><td align="left" valign="top"><p>concurrentConsumers</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.</p></td></tr><tr><td align="left" valign="top"><p>replyToConcurrentConsumers</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.</p></td></tr><tr><td align="left" valign="top"><p>connectionFactory</p></td><td align="left" valign="top"><p><code class="literal">ConnectionFactory</code></p></td><td align="left" valign="top"><p>Sets the default connection factory to be use</p></td></tr><tr><td align="left" valign="top"><p>username</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.</p></td></tr><tr><td align="left" valign="top"><p>password</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.</p></td></tr><tr><td align="left" valign="top"><p>deliveryPersistent</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether persistent delivery is used by default.</p></td></tr><tr><td align="left" valign="top"><p>deliveryMode</p></td><td align="left" valign="top"><p><code class="literal">Integer</code></p></td><td align="left" valign="top"><p>Specifies the delivery mode to be used. Possible values are Possibles values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.</p></td></tr><tr><td align="left" valign="top"><p>durableSubscriptionName</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.</p></td></tr><tr><td align="left" valign="top"><p>exceptionListener</p></td><td align="left" valign="top"><p><code class="literal">ExceptionListener</code></p></td><td align="left" valign="top"><p>Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.</p></td></tr><tr><td align="left" valign="top"><p>errorHandler</p></td><td align="left" valign="top"><p><code class="literal">ErrorHandler</code></p></td><td align="left" valign="top"><p>Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure than having to code a custom errorHandler.</p></td></tr><tr><td align="left" valign="top"><p>errorHandlerLoggingLevel</p></td><td align="left" valign="top"><p><code class="literal">LoggingLevel</code></p></td><td align="left" valign="top"><p>Allows to configure the default errorHandler logging level for logging uncaught exceptions.</p></td></tr><tr><td align="left" valign="top"><p>errorHandlerLogStackTrace</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Allows to control whether stacktraces should be logged or not by the default errorHandler.</p></td></tr><tr><td align="left" valign="top"><p>explicitQosEnabled</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Set if the deliveryMode priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring&#8217;s JmsTemplate. The deliveryMode priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option which operates at message granularity reading QoS properties exclusively from the Camel In message headers.</p></td></tr><tr><td align="left" valign="top"><p>exposeListenerSession</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the listener session should be exposed when consuming messages.</p></td></tr><tr><td align="left" valign="top"><p>idleTaskExecutionLimit</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the limit for idle executions of a receive task not having received any message within its execution. If this limit is reached the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.</p></td></tr><tr><td align="left" valign="top"><p>idleConsumerLimit</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specify the limit for the number of consumers that are allowed to be idle at any given time.</p></td></tr><tr><td align="left" valign="top"><p>maxConcurrentConsumers</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.</p></td></tr><tr><td align="left" valign="top"><p>replyToMaxConcurrentConsumers</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.</p></td></tr><tr><td align="left" valign="top"><p>replyOnTimeoutToMaxConcurrentConsumers</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.</p></td></tr><tr><td align="left" valign="top"><p>maxMessagesPerTask</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max) then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.</p></td></tr><tr><td align="left" valign="top"><p>messageConverter</p></td><td align="left" valign="top"><p><code class="literal">MessageConverter</code></p></td><td align="left" valign="top"><p>To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message.</p></td></tr><tr><td align="left" valign="top"><p>mapJmsMessage</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether Camel should auto map the received JMS message to a suited payload type such as javax.jms.TextMessage to a String etc. See section about how mapping works below for more details.</p></td></tr><tr><td align="left" valign="top"><p>messageIdEnabled</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When sending specifies whether message IDs should be added.</p></td></tr><tr><td align="left" valign="top"><p>messageTimestampEnabled</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether timestamps should be enabled by default on sending messages.</p></td></tr><tr><td align="left" valign="top"><p>alwaysCopyMessage</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If true Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations such as when a replyToDestinationSelectorName is set (incidentally Camel will set the alwaysCopyMessage option to true if a replyToDestinationSelectorName is set)</p></td></tr><tr><td align="left" valign="top"><p>useMessageIDAsCorrelationID</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.</p></td></tr><tr><td align="left" valign="top"><p>priority</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.</p></td></tr><tr><td align="left" valign="top"><p>pubSubNoLocal</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to inhibit the delivery of messages published by its own connection.</p></td></tr><tr><td align="left" valign="top"><p>receiveTimeout</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The timeout for receiving messages (in milliseconds).</p></td></tr><tr><td align="left" valign="top"><p>recoveryInterval</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Specifies the interval between recovery attempts i.e. when a connection is being refreshed in milliseconds. The default is 5000 ms that is 5 seconds.</p></td></tr><tr><td align="left" valign="top"><p>subscriptionDurable</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Deprecated: Enabled by default if you specify a durableSubscriptionName and a clientId.</p></td></tr><tr><td align="left" valign="top"><p>taskExecutor</p></td><td align="left" valign="top"><p><code class="literal">TaskExecutor</code></p></td><td align="left" valign="top"><p>Allows you to specify a custom task executor for consuming messages.</p></td></tr><tr><td align="left" valign="top"><p>timeToLive</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>When sending messages specifies the time-to-live of the message (in milliseconds).</p></td></tr><tr><td align="left" valign="top"><p>transacted</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to use transacted mode</p></td></tr><tr><td align="left" valign="top"><p>lazyCreateTransactionManager</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If true Camel will create a JmsTransactionManager if there is no transactionManager injected when option transacted=true.</p></td></tr><tr><td align="left" valign="top"><p>transactionManager</p></td><td align="left" valign="top"><p><code class="literal">PlatformTransactionManager</code></p></td><td align="left" valign="top"><p>The Spring transaction manager to use.</p></td></tr><tr><td align="left" valign="top"><p>transactionName</p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The name of the transaction to use.</p></td></tr><tr><td align="left" valign="top"><p>transactionTimeout</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The timeout value of the transaction (in seconds) if using transacted mode.</p></td></tr><tr><td align="left" valign="top"><p>testConnectionOnStartup</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.</p></td></tr><tr><td align="left" valign="top"><p>asyncStartListener</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to startup the JmsConsumer message listener asynchronously when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true you will let routes startup while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used then beware that if the connection could not be established then an exception is logged at WARN level and the consumer will not be able to receive messages; You can then restart the route to retry.</p></td></tr><tr><td align="left" valign="top"><p>asyncStopListener</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to stop the JmsConsumer message listener asynchronously when stopping a route.</p></td></tr><tr><td align="left" valign="top"><p>forceSendOriginalMessage</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.</p></td></tr><tr><td align="left" valign="top"><p>requestTimeout</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.</p></td></tr><tr><td align="left" valign="top"><p>requestTimeoutCheckerInterval</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs then you can lower this interval to check more frequently. The timeout is determined by the option requestTimeout.</p></td></tr><tr><td align="left" valign="top"><p>transferExchange</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body Out body Fault body In headers Out headers Fault headers exchange properties exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side so Camel knows the payloads is an Exchange and not a regular payload.</p></td></tr><tr><td align="left" valign="top"><p>transferException</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer.</p></td></tr><tr><td align="left" valign="top"><p>transferFault</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If enabled and you are using Request Reply messaging (InOut) and an Exchange failed with a SOAP fault (not exception) on the consumer side then the fault flag on link org.apache.camel.MessageisFault() will be send back in the response as a JMS header with the key link JmsConstantsJMS_TRANSFER_FAULT. If the client is Camel the returned fault flag will be set on the link org.apache.camel.MessagesetFault(boolean). You may want to enable this when using Camel components that support faults such as SOAP based such as cxf or spring-ws.</p></td></tr><tr><td align="left" valign="top"><p>jmsOperations</p></td><td align="left" valign="top"><p><code class="literal">JmsOperations</code></p></td><td align="left" valign="top"><p>Allows you to use your own implementation of the org.springframework.jms.core.JmsOperations interface. Camel uses JmsTemplate as default. Can be used for testing purpose but not used much as stated in the spring API docs.</p></td></tr><tr><td align="left" valign="top"><p>destinationResolver</p></td><td align="left" valign="top"><p><code class="literal">DestinationResolver</code></p></td><td align="left" valign="top"><p>A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example to lookup the real destination in a JNDI registry).</p></td></tr><tr><td align="left" valign="top"><p>replyToType</p></td><td align="left" valign="top"><p><code class="literal">ReplyToType</code></p></td><td align="left" valign="top"><p>Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary Shared or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details and especially the notes about the implications if running in a clustered environment and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.</p></td></tr><tr><td align="left" valign="top"><p>preserveMessageQos</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Set to true if you want to send message using the QoS settings specified on the message instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority JMSDeliveryMode and JMSExpiration. You can provide all or only some of them. If not provided Camel will fall back to use the values from the endpoint instead. So when using this option the headers override the values from the endpoint. The explicitQosEnabled option by contrast will only use options set on the endpoint and not values from the message header.</p></td></tr><tr><td align="left" valign="top"><p>asyncConsumer</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100 strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled then asyncConsumer=true does not run asynchronously as transaction must be executed synchronously (Camel 3.0 may support async transactions).</p></td></tr><tr><td align="left" valign="top"><p>allowNullBody</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to allow sending messages with no body. If this option is false and the message body is null then an JMSException is thrown.</p></td></tr><tr><td align="left" valign="top"><p>includeSentJMSMessageID</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.</p></td></tr><tr><td align="left" valign="top"><p>includeAllJMSXProperties</p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.</p></td></tr><tr><td align="left" valign="top"><p>defaultTaskExecutorType</p></td><td align="left" valign="top"><p><code class="literal">DefaultTaskExecutorType</code></p></td><td align="left" valign="top"><p>Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring&#8217;s SimpleAsyncTaskExecutor) or ThreadPool (uses Spring&#8217;s ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set it defaults to the previous behaviour which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.</p></td></tr><tr><td align="left" valign="top"><p>jmsKeyFormatStrategy</p></td><td align="left" valign="top"><p><code class="literal">JmsKeyFormatStrategy</code></p></td><td align="left" valign="top"><p>Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the notation.</p></td></tr><tr><td align="left" valign="top"><p>applicationContext</p></td><td align="left" valign="top"><p><code class="literal">ApplicationContext</code></p></td><td align="left" valign="top"><p>Sets the Spring ApplicationContext to use</p></td></tr><tr><td align="left" valign="top"><p>queueBrowseStrategy</p></td><td align="left" valign="top"><p><code class="literal">QueueBrowseStrategy</code></p></td><td align="left" valign="top"><p>To use a custom QueueBrowseStrategy when browsing queues</p></td></tr><tr><td align="left" valign="top"><p>headerFilterStrategy</p></td><td align="left" valign="top"><p><code class="literal">HeaderFilterStrategy</code></p></td><td align="left" valign="top"><p>To use a custom HeaderFilterStrategy to filter header to and from Camel message.</p></td></tr><tr><td align="left" valign="top"><p>messageCreatedStrategy</p></td><td align="left" valign="top"><p><code class="literal">MessageCreatedStrategy</code></p></td><td align="left" valign="top"><p>To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.</p></td></tr><tr><td align="left" valign="top"><p>waitForProvisionCorrelationToBeUpdatedCounter</p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.</p></td></tr><tr><td align="left" valign="top"><p>waitForProvisionCorrelationToBeUpdatedThreadSleepingTime</p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Interval in millis to sleep each time while waiting for provisional correlation id to be updated.</p></td></tr></tbody></table></div><p>{% endraw %}</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Endpointoptions"></a>Endpoint options</h3></div></div></div><p>The JMS component supports 83 endpoint options which are listed below:</p><p>{% raw %}</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="10%" class="col_2"><col width="11%" class="col_3"><col width="10%" class="col_4"><col width="50%" class="col_5"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Group</th><th align="left" valign="top">Default</th><th align="left" valign="top">Java Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>destinationType</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top"><p><code class="literal">queue</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The kind of destination to use</p></td></tr><tr><td align="left" valign="top"><p>destinationName</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> Name of the queue or topic to use as destination</p></td></tr><tr><td align="left" valign="top"><p>clientId</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the JMS client ID to use. Note that this value if specified must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.</p></td></tr><tr><td align="left" valign="top"><p>connectionFactory</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ConnectionFactory</code></p></td><td align="left" valign="top"><p>Sets the default connection factory to be used if a connection factory is not specified for either link setTemplateConnectionFactory(ConnectionFactory) or link setListenerConnectionFactory(ConnectionFactory)</p></td></tr><tr><td align="left" valign="top"><p>disableReplyTo</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If true a producer will behave like a InOnly exchange with the exception that JMSReplyTo header is sent out and not be suppressed like in the case of InOnly. Like InOnly the producer will not wait for a reply. A consumer with this flag will behave like InOnly. This feature can be used to bridge InOut requests to another queue so that a route on the other queue will send its response directly back to the original JMSReplyTo.</p></td></tr><tr><td align="left" valign="top"><p>durableSubscriptionName</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.</p></td></tr><tr><td align="left" valign="top"><p>jmsMessageType</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">JmsMessageType</code></p></td><td align="left" valign="top"><p>Allows you to force the use of a specific javax.jms.Message implementation for sending JMS messages. Possible values are: Bytes Map Object Stream Text. By default Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.</p></td></tr><tr><td align="left" valign="top"><p>testConnectionOnStartup</p></td><td align="left" valign="top"><p>common</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.</p></td></tr><tr><td align="left" valign="top"><p>acknowledgementModeName</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">AUTO_ACKNOWLEDGE</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS acknowledgement name which is one of: SESSION_TRANSACTED CLIENT_ACKNOWLEDGE AUTO_ACKNOWLEDGE DUPS_OK_ACKNOWLEDGE</p></td></tr><tr><td align="left" valign="top"><p>asyncConsumer</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100 strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled then asyncConsumer=true does not run asynchronously as transaction must be executed synchronously (Camel 3.0 may support async transactions).</p></td></tr><tr><td align="left" valign="top"><p>autoStartup</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the consumer container should auto-startup.</p></td></tr><tr><td align="left" valign="top"><p>bridgeErrorHandler</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler which mean any exceptions occurred while the consumer is trying to pickup incoming messages or the likes will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>cacheLevelName</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">CACHE_AUTO</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO CACHE_CONNECTION CACHE_CONSUMER CACHE_NONE and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.</p></td></tr><tr><td align="left" valign="top"><p>concurrentConsumers</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.</p></td></tr><tr><td align="left" valign="top"><p>maxConcurrentConsumers</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.</p></td></tr><tr><td align="left" valign="top"><p>replyTo</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Provides an explicit ReplyTo destination which overrides any incoming value of Message.getJMSReplyTo().</p></td></tr><tr><td align="left" valign="top"><p>replyToDeliveryPersistent</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to use persistent delivery by default for replies.</p></td></tr><tr><td align="left" valign="top"><p>selector</p></td><td align="left" valign="top"><p>consumer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the JMS selector to use</p></td></tr><tr><td align="left" valign="top"><p>acceptMessagesWhileStopping</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option if you start and stop JMS routes at runtime while there are still messages enqued on the queue. If this option is false and you stop the JMS route then messages may be rejected and the JMS broker would have to attempt redeliveries which yet again may be rejected and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.</p></td></tr><tr><td align="left" valign="top"><p>allowReplyManagerQuickStop</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case link JmsConfigurationisAcceptMessagesWhileStopping() is enabled and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.</p></td></tr><tr><td align="left" valign="top"><p>consumerType</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">Default</code></p></td><td align="left" valign="top"><p><code class="literal">ConsumerType</code></p></td><td align="left" valign="top"><p>The consumer type to use which can be one of: Simple Default or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.</p></td></tr><tr><td align="left" valign="top"><p>defaultTaskExecutorType</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DefaultTaskExecutorType</code></p></td><td align="left" valign="top"><p>Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring&#8217;s SimpleAsyncTaskExecutor) or ThreadPool (uses Spring&#8217;s ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set it defaults to the previous behaviour which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.</p></td></tr><tr><td align="left" valign="top"><p>eagerLoadingOfProperties</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Enables eager loading of JMS properties as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties</p></td></tr><tr><td align="left" valign="top"><p>exceptionHandler</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExceptionHandler</code></p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions that will be logged at WARN/ERROR level and ignored.</p></td></tr><tr><td align="left" valign="top"><p>exchangePattern</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExchangePattern</code></p></td><td align="left" valign="top"><p>Sets the exchange pattern when the consumer creates an exchange.</p></td></tr><tr><td align="left" valign="top"><p>exposeListenerSession</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether the listener session should be exposed when consuming messages.</p></td></tr><tr><td align="left" valign="top"><p>replyToSameDestinationAllowed</p></td><td align="left" valign="top"><p>consumer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.</p></td></tr><tr><td align="left" valign="top"><p>deliveryMode</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">Integer</code></p></td><td align="left" valign="top"><p>Specifies the delivery mode to be used. Possibles values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.</p></td></tr><tr><td align="left" valign="top"><p>deliveryPersistent</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether persistent delivery is used by default.</p></td></tr><tr><td align="left" valign="top"><p>explicitQosEnabled</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top"><p>Set if the deliveryMode priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring&#8217;s JmsTemplate. The deliveryMode priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option which operates at message granularity reading QoS properties exclusively from the Camel In message headers.</p></td></tr><tr><td align="left" valign="top"><p>preserveMessageQos</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Set to true if you want to send message using the QoS settings specified on the message instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority JMSDeliveryMode and JMSExpiration. You can provide all or only some of them. If not provided Camel will fall back to use the values from the endpoint instead. So when using this option the headers override the values from the endpoint. The explicitQosEnabled option by contrast will only use options set on the endpoint and not values from the message header.</p></td></tr><tr><td align="left" valign="top"><p>priority</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">4</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.</p></td></tr><tr><td align="left" valign="top"><p>replyToConcurrentConsumers</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.</p></td></tr><tr><td align="left" valign="top"><p>replyToMaxConcurrentConsumers</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.</p></td></tr><tr><td align="left" valign="top"><p>replyToOnTimeoutMaxConcurrentConsumers</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.</p></td></tr><tr><td align="left" valign="top"><p>replyToOverride</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Provides an explicit ReplyTo destination in the JMS message which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.</p></td></tr><tr><td align="left" valign="top"><p>replyToType</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ReplyToType</code></p></td><td align="left" valign="top"><p>Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary Shared or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details and especially the notes about the implications if running in a clustered environment and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.</p></td></tr><tr><td align="left" valign="top"><p>requestTimeout</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">20000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.</p></td></tr><tr><td align="left" valign="top"><p>timeToLive</p></td><td align="left" valign="top"><p>producer</p></td><td align="left" valign="top"><p><code class="literal">-1</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>When sending messages specifies the time-to-live of the message (in milliseconds).</p></td></tr><tr><td align="left" valign="top"><p>allowNullBody</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to allow sending messages with no body. If this option is false and the message body is null then an JMSException is thrown.</p></td></tr><tr><td align="left" valign="top"><p>alwaysCopyMessage</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If true Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations such as when a replyToDestinationSelectorName is set (incidentally Camel will set the alwaysCopyMessage option to true if a replyToDestinationSelectorName is set)</p></td></tr><tr><td align="left" valign="top"><p>disableTimeToLive</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Use this option to force disabling time to live. For example when you do request/reply over JMS then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.</p></td></tr><tr><td align="left" valign="top"><p>forceSendOriginalMessage</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.</p></td></tr><tr><td align="left" valign="top"><p>includeSentJMSMessageID</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.</p></td></tr><tr><td align="left" valign="top"><p>replyToCacheLevelName</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.</p></td></tr><tr><td align="left" valign="top"><p>replyToDestinationSelectorName</p></td><td align="left" valign="top"><p>producer (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is if you are not using a temporary reply queue).</p></td></tr><tr><td align="left" valign="top"><p>asyncStartListener</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to startup the JmsConsumer message listener asynchronously when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true you will let routes startup while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used then beware that if the connection could not be established then an exception is logged at WARN level and the consumer will not be able to receive messages; You can then restart the route to retry.</p></td></tr><tr><td align="left" valign="top"><p>asyncStopListener</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to stop the JmsConsumer message listener asynchronously when stopping a route.</p></td></tr><tr><td align="left" valign="top"><p>destinationResolver</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">DestinationResolver</code></p></td><td align="left" valign="top"><p>A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example to lookup the real destination in a JNDI registry).</p></td></tr><tr><td align="left" valign="top"><p>errorHandler</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ErrorHandler</code></p></td><td align="left" valign="top"><p>Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure than having to code a custom errorHandler.</p></td></tr><tr><td align="left" valign="top"><p>errorHandlerLoggingLevel</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">WARN</code></p></td><td align="left" valign="top"><p><code class="literal">LoggingLevel</code></p></td><td align="left" valign="top"><p>Allows to configure the default errorHandler logging level for logging uncaught exceptions.</p></td></tr><tr><td align="left" valign="top"><p>errorHandlerLogStackTrace</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Allows to control whether stacktraces should be logged or not by the default errorHandler.</p></td></tr><tr><td align="left" valign="top"><p>exceptionListener</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">ExceptionListener</code></p></td><td align="left" valign="top"><p>Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.</p></td></tr><tr><td align="left" valign="top"><p>headerFilterStrategy</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">HeaderFilterStrategy</code></p></td><td align="left" valign="top"><p>To use a custom HeaderFilterStrategy to filter header to and from Camel message.</p></td></tr><tr><td align="left" valign="top"><p>idleConsumerLimit</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specify the limit for the number of consumers that are allowed to be idle at any given time.</p></td></tr><tr><td align="left" valign="top"><p>idleTaskExecutionLimit</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Specifies the limit for idle executions of a receive task not having received any message within its execution. If this limit is reached the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.</p></td></tr><tr><td align="left" valign="top"><p>includeAllJMSXProperties</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.</p></td></tr><tr><td align="left" valign="top"><p>jmsKeyFormatStrategy</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the notation.</p></td></tr><tr><td align="left" valign="top"><p>mapJmsMessage</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether Camel should auto map the received JMS message to a suited payload type such as javax.jms.TextMessage to a String etc.</p></td></tr><tr><td align="left" valign="top"><p>maxMessagesPerTask</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">-1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max) then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.</p></td></tr><tr><td align="left" valign="top"><p>messageConverter</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">MessageConverter</code></p></td><td align="left" valign="top"><p>To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message.</p></td></tr><tr><td align="left" valign="top"><p>messageCreatedStrategy</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">MessageCreatedStrategy</code></p></td><td align="left" valign="top"><p>To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.</p></td></tr><tr><td align="left" valign="top"><p>messageIdEnabled</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>When sending specifies whether message IDs should be added. This is just an hint to the JMS Broker. If the JMS provider accepts this hint these messages must have the message ID set to null; if the provider ignores the hint the message ID must be set to its normal unique value</p></td></tr><tr><td align="left" valign="top"><p>messageListenerContainerFactory</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">MessageListenerContainerFactory</code></p></td><td align="left" valign="top"><p>Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.</p></td></tr><tr><td align="left" valign="top"><p>messageTimestampEnabled</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS Broker. If the JMS provider accepts this hint these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value</p></td></tr><tr><td align="left" valign="top"><p>pubSubNoLocal</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to inhibit the delivery of messages published by its own connection.</p></td></tr><tr><td align="left" valign="top"><p>receiveTimeout</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">1000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The timeout for receiving messages (in milliseconds).</p></td></tr><tr><td align="left" valign="top"><p>recoveryInterval</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">5000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Specifies the interval between recovery attempts i.e. when a connection is being refreshed in milliseconds. The default is 5000 ms that is 5 seconds.</p></td></tr><tr><td align="left" valign="top"><p>requestTimeoutCheckerInterval</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">1000</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs then you can lower this interval to check more frequently. The timeout is determined by the option requestTimeout.</p></td></tr><tr><td align="left" valign="top"><p>synchronous</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).</p></td></tr><tr><td align="left" valign="top"><p>transferException</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer.</p></td></tr><tr><td align="left" valign="top"><p>transferExchange</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body Out body Fault body In headers Out headers Fault headers exchange properties exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side so Camel knows the payloads is an Exchange and not a regular payload.</p></td></tr><tr><td align="left" valign="top"><p>transferFault</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If enabled and you are using Request Reply messaging (InOut) and an Exchange failed with a SOAP fault (not exception) on the consumer side then the fault flag on link org.apache.camel.MessageisFault() will be send back in the response as a JMS header with the key link JmsConstantsJMS_TRANSFER_FAULT. If the client is Camel the returned fault flag will be set on the link org.apache.camel.MessagesetFault(boolean). You may want to enable this when using Camel components that support faults such as SOAP based such as cxf or spring-ws.</p></td></tr><tr><td align="left" valign="top"><p>useMessageIDAsCorrelationID</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.</p></td></tr><tr><td align="left" valign="top"><p>waitForProvisionCorrelationToBeUpdatedCounter</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">50</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.</p></td></tr><tr><td align="left" valign="top"><p>waitForProvisionCorrelationToBeUpdatedThreadSleepingTime</p></td><td align="left" valign="top"><p>advanced</p></td><td align="left" valign="top"><p><code class="literal">100</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>Interval in millis to sleep each time while waiting for provisional correlation id to be updated.</p></td></tr><tr><td align="left" valign="top"><p>password</p></td><td align="left" valign="top"><p>security</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.</p></td></tr><tr><td align="left" valign="top"><p>username</p></td><td align="left" valign="top"><p>security</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.</p></td></tr><tr><td align="left" valign="top"><p>transacted</p></td><td align="left" valign="top"><p>transaction</p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Specifies whether to use transacted mode</p></td></tr><tr><td align="left" valign="top"><p>lazyCreateTransactionManager</p></td><td align="left" valign="top"><p>transaction (advanced)</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>If true Camel will create a JmsTransactionManager if there is no transactionManager injected when option transacted=true.</p></td></tr><tr><td align="left" valign="top"><p>transactionManager</p></td><td align="left" valign="top"><p>transaction (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">PlatformTransactionManager</code></p></td><td align="left" valign="top"><p>The Spring transaction manager to use.</p></td></tr><tr><td align="left" valign="top"><p>transactionName</p></td><td align="left" valign="top"><p>transaction (advanced)</p></td><td align="left" valign="top">&nbsp;</td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The name of the transaction to use.</p></td></tr><tr><td align="left" valign="top"><p>transactionTimeout</p></td><td align="left" valign="top"><p>transaction (advanced)</p></td><td align="left" valign="top"><p><code class="literal">-1</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The timeout value of the transaction (in seconds) if using transacted mode.</p></td></tr></tbody></table></div><p>{% endraw %}</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-MessageMappingbetweenJMSandCamel"></a>Message Mapping between JMS and Camel</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Disablingauto-mappingofJMSmessages">Disabling auto-mapping of JMS messages</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingacustomMessageConverter">Using a custom MessageConverter</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Controllingthemappingstrategyselected">Controlling the mapping strategy selected</a></span></dt></dl></div><p>Camel automatically maps messages between <code class="literal">javax.jms.Message</code> and
<code class="literal">org.apache.camel.Message</code>.</p><p>When sending a JMS message, Camel converts the message body to the
following JMS message types:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Body Type</th><th align="left" valign="top">JMS Message</th><th align="left" valign="top">Comment</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.TextMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.w3c.dom.Node</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.TextMessage</code></p></td><td align="left" valign="top"><p>The DOM will be converted
to <code class="literal">String</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Map</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.MapMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">java.io.Serializable</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.ObjectMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">byte[]</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">java.io.File</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">java.io.Reader</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">java.io.InputStream</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">java.nio.ByteBuffer</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p>&nbsp;</p></td></tr></tbody></table></div><p>When receiving a JMS message, Camel converts the JMS message to the
following body type:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="50%" class="col_1"><col width="50%" class="col_2"></colgroup><thead><tr><th align="left" valign="top">JMS Message</th><th align="left" valign="top">Body Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">javax.jms.TextMessage</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">javax.jms.BytesMessage</code></p></td><td align="left" valign="top"><p><code class="literal">byte[]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">javax.jms.MapMessage</code></p></td><td align="left" valign="top"><p><code class="literal">Map&lt;String, Object&gt;</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">javax.jms.ObjectMessage</code></p></td><td align="left" valign="top"><p><code class="literal">Object</code></p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Disablingauto-mappingofJMSmessages"></a>Disabling auto-mapping of JMS messages</h3></div></div></div><p>You can use the <code class="literal">mapJmsMessage</code> option to disable the auto-mapping
above. If disabled, Camel will not try to map the received JMS message,
but instead uses it directly as the payload. This allows you to avoid
the overhead of mapping and let Camel just pass through the JMS message.
For instance, it even allows you to route <code class="literal">javax.jms.ObjectMessage</code> JMS
messages with classes you do <span class="strong"><strong>not</strong></span> have on the classpath.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingacustomMessageConverter"></a>Using a custom MessageConverter</h3></div></div></div><p>You can use the <code class="literal">messageConverter</code> option to do the mapping yourself in
a Spring <code class="literal">org.springframework.jms.support.converter.MessageConverter</code>
class.</p><p>For example, in the route below we use a custom message converter when
sending a message to the JMS order queue:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"file://inbox/order"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:order?messageConverter=#myMessageConverter"</em></strong>);</pre><p>You can also use a custom message converter when consuming from a JMS
destination.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Controllingthemappingstrategyselected"></a>Controlling the mapping strategy selected</h3></div></div></div><p>You can use the <code class="literal">jmsMessageType</code> option on the endpoint URL to force a
specific message type for all messages.</p><p>In the route below, we poll files from a folder and send them as
<code class="literal">javax.jms.TextMessage</code> as we have forced the JMS producer endpoint to
use text messages:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"file://inbox/order"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:order?jmsMessageType=Text"</em></strong>);</pre><p>You can also specify the message type to use for each message by setting
the header with the key <code class="literal">CamelJmsMessageType</code>. For example:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"file://inbox/order"</em></strong>).setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"CamelJmsMessageType"</em></strong>, JmsMessageType.Text).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:order"</em></strong>);</pre><p>The possible values are defined in the <code class="literal">enum</code> class,
<code class="literal">org.apache.camel.jms.JmsMessageType</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Messageformatwhensending"></a>Message format when sending</h2></div></div></div><p>The exchange that is sent over the JMS wire must conform to the
<a class="link" href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="_top">JMS Message
spec</a>.</p><p>For the <code class="literal">exchange.in.header</code> the following rules apply for the header
<span class="strong"><strong>keys</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Keys starting with <code class="literal">JMS</code> or <code class="literal">JMSX</code> are reserved.</li><li class="listitem"><code class="literal">exchange.in.headers</code> keys must be literals and all be valid Java
identifiers (do not use dots in the key name).</li><li class="listitem">Camel replaces dots &amp; hyphens and the reverse when when consuming JMS
messages:
 <code class="literal">.</code> is replaced by <code class="literal">_DOT_</code> and the reverse replacement when Camel
consumes the message.
 <code class="literal">-</code> is replaced by <code class="literal">_HYPHEN_</code> and the reverse replacement when Camel
consumes the message.</li><li class="listitem">See also the option <code class="literal">jmsKeyFormatStrategy</code>, which allows use of your
own custom strategy for formatting keys.</li></ul></div><p>For the <code class="literal">exchange.in.header</code>, the following rules apply for the header
<span class="strong"><strong>values</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The values must be primitives or their counter objects (such as
<code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">Character</code>). The types, <code class="literal">String</code>, <code class="literal">CharSequence</code>,
<code class="literal">Date</code>, <code class="literal">BigDecimal</code> and <code class="literal">BigInteger</code> are all converted to their
<code class="literal">toString()</code> representation. All other types are dropped.</li></ul></div><p>Camel will log with category <code class="literal">org.apache.camel.component.jms.JmsBinding</code>
at <span class="strong"><strong>DEBUG</strong></span> level if it drops a given header value. For example:</p><pre class="screen">2008-07-09 06:43:04,046 [main           ] DEBUG JmsBinding
  - Ignoring non primitive header: order of class: org.apache.camel.component.jms.issues.DummyOrder with value: DummyOrder{orderId=333, itemId=4444, quantity=2}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Messageformatwhenreceiving"></a>Message format when receiving</h2></div></div></div><p>Camel adds the following properties to the <code class="literal">Exchange</code> when it receives a
message:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Property</th><th align="left" valign="top">Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">org.apache.camel.jms.replyDestination</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.Destination</code></p></td><td align="left" valign="top"><p>The
reply destination.</p></td></tr></tbody></table></div><p>Camel adds the following JMS properties to the In message headers when
it receives a JMS message:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Header</th><th align="left" valign="top">Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">JMSCorrelationID</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS correlation ID.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSDeliveryMode</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The JMS delivery mode.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSDestination</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.Destination</code></p></td><td align="left" valign="top"><p>The JMS destination.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSExpiration</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The JMS expiration.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSMessageID</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS unique message ID.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSPriority</code></p></td><td align="left" valign="top"><p><code class="literal">int</code></p></td><td align="left" valign="top"><p>The JMS priority (with 0 as the lowest priority
and 9 as the highest).</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSRedelivered</code></p></td><td align="left" valign="top"><p><code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Is the JMS message redelivered.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSReplyTo</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.Destination</code></p></td><td align="left" valign="top"><p>The JMS reply-to destination.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSTimestamp</code></p></td><td align="left" valign="top"><p><code class="literal">long</code></p></td><td align="left" valign="top"><p>The JMS timestamp.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSType</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS type.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">JMSXGroupID</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The JMS group ID.</p></td></tr></tbody></table></div><p>As all the above information is standard JMS you can check the
<a class="link" href="http://java.sun.com/javaee/5/docs/api/javax/jms/Message.html" target="_top">JMS
documentation</a> for further details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-AboutusingCameltosendandreceivemessagesandJMSReplyTo"></a>About using Camel to send and receive messages and JMSReplyTo</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-JmsProducer">JmsProducer</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-JmsConsumer">JmsConsumer</a></span></dt></dl></div><p>The JMS component is complex and you have to pay close attention to how
it works in some cases. So this is a short summary of some of the
areas/pitfalls to look for.</p><p>When Camel sends a message using its <code class="literal">JMSProducer</code>, it checks the
following conditions:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The message exchange pattern,</li><li class="listitem">Whether a <code class="literal">JMSReplyTo</code> was set in the endpoint or in the message
headers,</li><li class="listitem">Whether any of the following options have been set on the JMS
endpoint: <code class="literal">disableReplyTo</code>, <code class="literal">preserveMessageQos</code>, <code class="literal">explicitQosEnabled</code>.</li></ul></div><p>All this can be a tad complex to understand and configure to support
your use case.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-JmsProducer"></a>JmsProducer</h3></div></div></div><p>The <code class="literal">JmsProducer</code> behaves as follows, depending on configuration:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Exchange Pattern</th><th align="left" valign="top">Other options</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOut</em></span></p></td><td align="left" valign="top"><p>-</p></td><td align="left" valign="top"><p>Camel will expect a reply, set a temporary <code class="literal">JMSReplyTo</code>,
and after sending the message, it will start to listen for the reply
message on the temporary queue.</p></td></tr><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOut</em></span></p></td><td align="left" valign="top"><p><code class="literal">JMSReplyTo</code> is set</p></td><td align="left" valign="top"><p>Camel will expect a reply and, after
sending the message, it will start to listen for the reply message on
the specified <code class="literal">JMSReplyTo</code> queue.</p></td></tr><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOnly</em></span></p></td><td align="left" valign="top"><p>-</p></td><td align="left" valign="top"><p>Camel will send the message and <span class="strong"><strong>not</strong></span> expect a reply.</p></td></tr><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOnly</em></span></p></td><td align="left" valign="top"><p><code class="literal">JMSReplyTo</code> is set</p></td><td align="left" valign="top"><p>By default, Camel discards the
<code class="literal">JMSReplyTo</code> destination and clears the <code class="literal">JMSReplyTo</code> header before
sending the message. Camel then sends the message and does <span class="strong"><strong>not</strong></span> expect
a reply. Camel logs this in the log at <code class="literal">WARN</code> level (changed to <code class="literal">DEBUG</code>
level from <span class="strong"><strong>Camel 2.6</strong></span> onwards. You can use <code class="literal">preserveMessageQuo=true</code> to
instruct Camel to keep the <code class="literal">JMSReplyTo</code>. In all situations the
<code class="literal">JmsProducer</code> does <span class="strong"><strong>not</strong></span> expect any reply and thus continue after
sending the message.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-JmsConsumer"></a>JmsConsumer</h3></div></div></div><p>The <code class="literal">JmsConsumer</code> behaves as follows, depending on configuration:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Exchange Pattern</th><th align="left" valign="top">Other options</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOut</em></span></p></td><td align="left" valign="top"><p>-</p></td><td align="left" valign="top"><p>Camel will send the reply back to the <code class="literal">JMSReplyTo</code> queue.</p></td></tr><tr><td align="left" valign="top"><p><span class="emphasis"><em>InOnly</em></span></p></td><td align="left" valign="top"><p>-</p></td><td align="left" valign="top"><p>Camel will not send a reply back, as the pattern is
<span class="emphasis"><em>InOnly</em></span>.</p></td></tr><tr><td align="left" valign="top"><p>-</p></td><td align="left" valign="top"><p><code class="literal">disableReplyTo=true</code></p></td><td align="left" valign="top"><p>This option suppresses replies.</p></td></tr></tbody></table></div><p>So pay attention to the message exchange pattern set on your exchanges.</p><p>If you send a message to a JMS destination in the middle of your route
you can specify the exchange pattern to use, see more at
<a class="link" href="request-reply.html" target="_top">Request Reply</a>.
 This is useful if you want to send an <code class="literal">InOnly</code> message to a JMS topic:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:in"</em></strong>)
   .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:validateOrder"</em></strong>)
   .to(ExchangePattern.InOnly, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:topic:order"</em></strong>)
   .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:handleOrder"</em></strong>);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Reuseendpointandsendtodifferentdestinationscomputedatruntime"></a>Reuse endpoint and send to different destinations computed at runtime</h2></div></div></div><p>If you need to send messages to a lot of different JMS destinations, it
makes sense to reuse a JMS endpoint and specify the real destination in
a message header. This allows Camel to reuse the same endpoint, but send
to different destinations. This greatly reduces the number of endpoints
created and economizes on memory and thread resources.</p><p>You can specify the destination in the following headers:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Header</th><th align="left" valign="top">Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">CamelJmsDestination</code></p></td><td align="left" valign="top"><p><code class="literal">javax.jms.Destination</code></p></td><td align="left" valign="top"><p>A destination object.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">CamelJmsDestinationName</code></p></td><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>The destination name.</p></td></tr></tbody></table></div><p>For example, the following route shows how you can compute a destination
at run time and use it to override the destination appearing in the JMS
URL:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"file://inbox"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:computeDestination"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:dummy"</em></strong>);</pre><p>The queue name, <code class="literal">dummy</code>, is just a placeholder. It must be provided as
part of the JMS endpoint URL, but it will be ignored in this example.</p><p>In the <code class="literal">computeDestination</code> bean, specify the real destination by
setting the <code class="literal">CamelJmsDestinationName</code> header as follows:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> setJmsHeader(Exchange exchange) {
   String id = ....
   exchange.getIn().setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"CamelJmsDestinationName"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"order:"</em></strong> + id<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">");
</em></strong>}</pre><p>Then Camel will read this header and use it as the destination instead
of the one configured on the endpoint. So, in this example Camel sends
the message to <code class="literal">activemq:queue:order:2</code>, assuming the <code class="literal">id</code> value was 2.</p><p>If both the <code class="literal">CamelJmsDestination</code> and the <code class="literal">CamelJmsDestinationName</code>
headers are set, <code class="literal">CamelJmsDestination</code> takes priority. Keep in mind that
the JMS producer removes both <code class="literal">CamelJmsDestination</code> and
<code class="literal">CamelJmsDestinationName</code> headers from the exchange and do not propagate
them to the created JMS message&nbsp;in order to avoid the accidental loops
in the routes (in scenarios when the message will be forwarded to the
another JMS endpoint).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-ConfiguringdifferentJMSproviders"></a>Configuring different JMS providers</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingJNDItofindtheConnectionFactory">Using JNDI to find the ConnectionFactory</a></span></dt></dl></div><p>You can configure your JMS provider in <a class="link" href="spring.html" target="_top">Spring</a> XML as
follows:</p><p>Basically, you can configure as many JMS component instances as you wish
and give them <span class="strong"><strong>a unique name using the</strong></span> <code class="literal">id</code> <span class="strong"><strong>attribute</strong></span>. The
preceding example configures an <code class="literal">activemq</code> component. You could do the
same to configure MQSeries, TibCo, BEA, Sonic and so on.</p><p>Once you have a named JMS component, you can then refer to endpoints
within that component using URIs. For example for the component name,
<code class="literal">activemq</code>, you can then refer to destinations using the URI format,
<code class="literal">activemq:[queue:|topic:]destinationName</code>. You can use the same approach
for all other JMS providers.</p><p>This works by the SpringCamelContext lazily fetching components from the
spring context for the scheme name you use for
<a class="link" href="endpoint.html" target="_top">Endpoint</a> <a class="link" href="uris.html" target="_top">URIs</a> and having the
<a class="link" href="component.html" target="_top">Component</a> resolve the endpoint URIs.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingJNDItofindtheConnectionFactory"></a>Using JNDI to find the ConnectionFactory</h3></div></div></div><p>If you are using a J2EE container, you might need to look up JNDI to
find the JMS <code class="literal">ConnectionFactory</code> rather than use the usual <code class="literal">&lt;bean&gt;</code>
mechanism in Spring. You can do this using Spring&#8217;s factory bean or the
new Spring XML namespace. For example:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;bean</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">id</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"weblogic"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">class</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"org.apache.camel.component.jms.JmsComponent"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;property</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"connectionFactory"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">ref</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"myConnectionFactory"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong>

<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;jee:jndi-lookup</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">id</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"myConnectionFactory"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">jndi-name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"jms/connectionFactory"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong></pre><p>See
<a class="link" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html#xsd-config-body-schemas-jee" target="_top">The
jee schema</a> in the Spring reference documentation for more details about
JNDI lookup.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-ConcurrentConsuming"></a>Concurrent Consuming</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-ConcurrentConsumingwithasyncconsumer">Concurrent Consuming with async consumer</a></span></dt></dl></div><p>A common requirement with JMS is to consume messages concurrently in
multiple threads in order to make an application more responsive. You
can set the <code class="literal">concurrentConsumers</code> option to specify the number of
threads servicing the JMS endpoint, as follows:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:SomeQueue?concurrentConsumers=20"</em></strong>).
  bean(MyClass.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>);</pre><p>You can configure this option in one of the following ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">On the <code class="literal">JmsComponent</code>,</li><li class="listitem">On the endpoint URI or,</li><li class="listitem">By invoking <code class="literal">setConcurrentConsumers()</code> directly on the <code class="literal">JmsEndpoint</code>.</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-ConcurrentConsumingwithasyncconsumer"></a>Concurrent Consuming with async consumer</h3></div></div></div><p>Notice that each concurrent consumer will only pickup the next available
message from the JMS broker, when the current message has been fully
processed. You can set the option <code class="literal">asyncConsumer=true</code> to let the
consumer pickup the next message from the JMS queue, while the previous
message is being processed asynchronously (by the
<a class="link" href="asynchronous-routing-engine.html" target="_top">Asynchronous Routing Engine</a>). See
more details in the table on top of the page about the <code class="literal">asyncConsumer</code>
option.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:SomeQueue?concurrentConsumers=20&amp;asyncConsumer=true"</em></strong>).
  bean(MyClass.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Request-replyoverJMS"></a>Request-reply over JMS</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Request-replyoverJMSandusingasharedfixedreplyqueue">Request-reply over JMS and using a shared fixed reply queue</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Request-replyoverJMSandusinganexclusivefixedreplyqueue">Request-reply over JMS and using an exclusive fixed reply queue</a></span></dt></dl></div><p>Camel supports <a class="link" href="request-reply.html" target="_top">Request Reply</a> over JMS. In
essence the MEP of the Exchange should be <code class="literal">InOut</code> when you send a
message to a JMS queue.</p><p>Camel offers a number of options to configure request/reply over JMS
that influence performance and clustered environments. The table below
summaries the options.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="10%" class="col_3"><col width="70%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Option</th><th align="left" valign="top">Performance</th><th align="left" valign="top">Cluster</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Temporary</code></p></td><td align="left" valign="top"><p>Fast</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p>A temporary queue is used as reply queue, and
automatic created by Camel. To use this do <span class="strong"><strong>not</strong></span> specify a replyTo queue
name. And you can optionally configure <code class="literal">replyToType=Temporary</code> to make
it stand out that temporary queues are in use.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Shared</code></p></td><td align="left" valign="top"><p>Slow</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p>A shared persistent queue is used as reply queue.
The queue must be created beforehand, although some brokers can create
them on the fly such as Apache ActiveMQ. To use this you must specify
the replyTo queue name. And you can optionally configure
<code class="literal">replyToType=Shared</code> to make it stand out that shared queues are in use.
A shared queue can be used in a clustered environment with multiple
nodes running this Camel application at the same time. All using the
same shared reply queue. This is possible because JMS Message selectors
are used to correlate expected reply messages; this impacts performance
though. JMS Message selectors is slower, and therefore not as fast as
<code class="literal">Temporary</code> or <code class="literal">Exclusive</code> queues. See further below how to tweak this
for better performance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Exclusive</code></p></td><td align="left" valign="top"><p>Fast</p></td><td align="left" valign="top"><p>No (*Yes)</p></td><td align="left" valign="top"><p>An exclusive persistent queue is used as
reply queue. The queue must be created beforehand, although some brokers
can create them on the fly such as Apache ActiveMQ. To use this you must
specify the replyTo queue name. And you <span class="strong"><strong>must</strong></span> configure
<code class="literal">replyToType=Exclusive</code> to instruct Camel to use exclusive queues, as
<code class="literal">Shared</code> is used by default, if a <code class="literal">replyTo</code> queue name was configured.
When using exclusive reply queues, then JMS Message selectors are <span class="strong"><strong>not</strong></span>
in use, and therefore other applications must not use this queue as
well. An exclusive queue <span class="strong"><strong>cannot</strong></span> be used in a clustered environment
with multiple nodes running this Camel application at the same time; as
we do not have control if the reply queue comes back to the same node
that sent the request message; that is why shared queues use JMS Message
selectors to make sure of this. <span class="strong"><strong>Though</strong></span> if you configure each Exclusive
reply queue with an unique name per node, then you can run this in a
clustered environment. As then the reply message will be sent back to
that queue for the given node, that awaits the reply message.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">concurrentConsumers</code></p></td><td align="left" valign="top"><p>Fast</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p><span class="strong"><strong>Camel 2.10.3:</strong></span> Allows to process
reply messages concurrently using concurrent message listeners in use.
You can specify a range using the <code class="literal">concurrentConsumers</code> and
<code class="literal">maxConcurrentConsumers</code> options. <span class="strong"><strong>Notice:</strong></span> That using <code class="literal">Shared</code> reply
queues may not work as well with concurrent listeners, so use this
option with care.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">maxConcurrentConsumers</code></p></td><td align="left" valign="top"><p>Fast</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><p><span class="strong"><strong>Camel 2.10.3:</strong></span> Allows to process
reply messages concurrently using concurrent message listeners in use.
You can specify a range using the <code class="literal">concurrentConsumers</code> and
<code class="literal">maxConcurrentConsumers</code> options. <span class="strong"><strong>Notice:</strong></span> That using <code class="literal">Shared</code> reply
queues may not work as well with concurrent listeners, so use this
option with care.</p></td></tr></tbody></table></div><p>The <code class="literal">JmsProducer</code> detects the <code class="literal">InOut</code> and provides a <code class="literal">JMSReplyTo</code> header
with the reply destination to be used. By default Camel uses a temporary
queue, but you can use the <code class="literal">replyTo</code> option on the endpoint to specify a
fixed reply queue (see more below about fixed reply queue).</p><p>Camel will automatic setup a consumer which listen on the reply queue,
so you should <span class="strong"><strong>not</strong></span> do anything.
 This consumer is a Spring <code class="literal">DefaultMessageListenerContainer</code> which
listen for replies. However it&#8217;s fixed to 1 concurrent consumer.
 That means replies will be processed in sequence as there are only 1
thread to process the replies. If you want to process replies faster,
then we need to use concurrency. But <span class="strong"><strong>not</strong></span> using the
<code class="literal">concurrentConsumer</code> option. We should use the <code class="literal">threads</code> from the Camel
DSL instead, as shown in the route below:</p><p>Instead of using threads, then use concurrentConsumers option if using
Camel 2.10.3 or better. See further below.</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo"</em></strong>)
.threads(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">5</span>)
.to(yyy)
.to(zzz);</pre><p>In this route we instruct Camel to route replies
<a class="link" href="async.html" target="_top">asynchronously</a> using a thread pool with 5 threads.</p><p>From <span class="strong"><strong>Camel 2.10.3</strong></span> onwards you can now configure the listener to use
concurrent threads using the <code class="literal">concurrentConsumers</code> and
<code class="literal">maxConcurrentConsumers</code> options. This allows you to easier configure
this in Camel as shown below:</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?concurrentConsumers=5"</em></strong>)
.to(yyy)
.to(zzz);</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Request-replyoverJMSandusingasharedfixedreplyqueue"></a>Request-reply over JMS and using a shared fixed reply queue</h3></div></div></div><p>If you use a fixed reply queue when doing
<a class="link" href="request-reply.html" target="_top">Request Reply</a> over JMS as shown in the example
below, then pay attention.</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?replyTo=bar"</em></strong>)
.to(yyy)</pre><p>In this example the fixed reply queue named "bar" is used. By default
Camel assumes the queue is shared when using fixed reply queues, and
therefore it uses a <code class="literal">JMSSelector</code> to only pickup the expected reply
messages (eg based on the <code class="literal">JMSCorrelationID</code>). See next section for
exclusive fixed reply queues. That means its not as fast as temporary
queues. You can speedup how often Camel will pull for reply messages
using the <code class="literal">receiveTimeout</code> option. By default its 1000 millis. So to
make it faster you can set it to 250 millis to pull 4 times per second
as shown:</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?replyTo=bar&amp;receiveTimeout=250"</em></strong>)
.to(yyy)</pre><p>Notice this will cause the Camel to send pull requests to the message
broker more frequent, and thus require more network traffic.
 It is generally recommended to use temporary queues if possible.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Request-replyoverJMSandusinganexclusivefixedreplyqueue"></a>Request-reply over JMS and using an exclusive fixed reply queue</h3></div></div></div><p><span class="strong"><strong>Available as of Camel 2.9</strong></span></p><p>In the previous example, Camel would anticipate the fixed reply queue
named "bar" was shared, and thus it uses a <code class="literal">JMSSelector</code> to only consume
reply messages which it expects. However there is a drawback doing this
as JMS selectos is slower. Also the consumer on the reply queue is
slower to update with new JMS selector ids. In fact it only updates when
the <code class="literal">receiveTimeout</code> option times out, which by default is 1 second. So
in theory the reply messages could take up till about 1 sec to be
detected. On the other hand if the fixed reply queue is exclusive to the
Camel reply consumer, then we can avoid using the JMS selectors, and
thus be more performant. In fact as fast as using temporary queues. So
in <span class="strong"><strong>Camel 2.9</strong></span> onwards we introduced the <code class="literal">ReplyToType</code> option which you
can configure to <code class="literal">Exclusive</code>
 to tell Camel that the reply queue is exclusive as shown in the example
below:</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive"</em></strong>)
.to(yyy)</pre><p>Mind that the queue must be exclusive to each and every endpoint. So if
you have two routes, then they each need an unique reply queue as shown
in the next example:</p><pre class="programlisting">from(xxx)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive"</em></strong>)
.to(yyy)

from(aaa)
.inOut().to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:order?replyTo=order.reply&amp;replyToType=Exclusive"</em></strong>)
.to(bbb)</pre><p>The same applies if you run in a clustered environment. Then each node
in the cluster must use an unique reply queue name. As otherwise each
node in the cluster may pickup messages which was intended as a reply on
another node. For clustered environments its recommended to use shared
reply queues instead.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Synchronizingclocksbetweensendersandreceivers"></a>Synchronizing clocks between senders and receivers</h2></div></div></div><p>When doing messaging between systems, its desirable that the systems
have synchronized clocks. For example when sending a <a class="link" href="jms.html" target="_top">JMS</a>
message, then you can set a time to live value on the message. Then the
receiver can inspect this value, and determine if the message is already
expired, and thus drop the message instead of consume and process it.
However this requires that both sender and receiver have synchronized
clocks. If you are using <a class="link" href="http://activemq.apache.org/" target="_top">ActiveMQ</a> then you
can use the <a class="link" href="http://activemq.apache.org/timestampplugin.html" target="_top">timestamp
plugin</a> to synchronize clocks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Abouttimetolive"></a>About time to live</h2></div></div></div><p>Read first above about synchronized clocks.</p><p>When you do request/reply (InOut) over <a class="link" href="jms.html" target="_top">JMS</a> with Camel
then Camel uses a timeout on the sender side, which is default 20
seconds from the <code class="literal">requestTimeout</code> option. You can control this by
setting a higher/lower value. However the time to live value is still
set on the <a class="link" href="jms.html" target="_top">JMS</a> message being send. So that requires the
clocks to be synchronized between the systems. If they are not, then you
may want to disable the time to live value being set. This is now
possible using the <code class="literal">disableTimeToLive</code> option from <span class="strong"><strong>Camel 2.8</strong></span> onwards.
So if you set this option to <code class="literal">disableTimeToLive=true</code>, then Camel does
<span class="strong"><strong>not</strong></span> set any time to live value when sending <a class="link" href="jms.html" target="_top">JMS</a>
messages. <span class="strong"><strong>But</strong></span> the request timeout is still active. So for example if
you do request/reply over <a class="link" href="jms.html" target="_top">JMS</a> and have disabled time to
live, then Camel will still use a timeout by 20 seconds (the
<code class="literal">requestTimeout</code> option). That option can of course also be configured.
So the two options <code class="literal">requestTimeout</code> and <code class="literal">disableTimeToLive</code> gives you
fine grained control when doing request/reply.</p><p>From <span class="strong"><strong>Camel 2.13/2.12.3</strong></span> onwards you can provide a header in the message
to override and use as the request timeout value instead of the endpoint
configured value. For example:</p><pre class="programlisting">   from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:someWhere"</em></strong>)
     .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:foo?replyTo=bar&amp;requestTimeout=30s"</em></strong>)
     .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:processReply"</em></strong>);</pre><p>In the route above we have a endpoint configured <code class="literal">requestTimeout</code> of 30
seconds. So Camel will wait up till 30 seconds for that reply message to
come back on the bar queue. If no reply message is received then a
<code class="literal">org.apache.camel.ExchangeTimedOutException</code> is set on the
<a class="link" href="exchange.html" target="_top">Exchange</a> and Camel continues routing the message,
which would then fail due the exception, and Camel&#8217;s error handler
reacts.</p><p>If you want to use a per message timeout value, you can set the header
with key
<code class="literal">org.apache.camel.component.jms.JmsConstants#JMS_REQUEST_TIMEOUT</code> which
has constant value <code class="literal">"CamelJmsRequestTimeout"</code> with a timeout value as
long type.</p><p>For example we can use a bean to compute the timeout value per
individual message, such as calling the <code class="literal">"whatIsTheTimeout"</code> method on
the service bean as shown below:</p><pre class="programlisting">   from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:someWhere"</em></strong>)
     .setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"CamelJmsRequestTimeout"</em></strong>, method(ServiceBean.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"whatIsTheTimeout"</em></strong>))
     .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:foo?replyTo=bar&amp;requestTimeout=30s"</em></strong>)
     .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:processReply"</em></strong>);</pre><p>When you do fire and forget (InOut) over <a class="link" href="jms.html" target="_top">JMS</a> with Camel
then Camel by default does <span class="strong"><strong>not</strong></span> set any time to live value on the
message. You can configure a value by using the <code class="literal">timeToLive</code> option. For
example to indicate a 5 sec., you set <code class="literal">timeToLive=5000</code>. The option
<code class="literal">disableTimeToLive</code> can be used to force disabling the time to live,
also for InOnly messaging. The <code class="literal">requestTimeout</code> option is not being used
for InOnly messaging.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-EnablingTransactedConsumption"></a>Enabling Transacted Consumption</h2></div></div></div><p>A common requirement is to consume from a queue in a transaction and
then process the message using the Camel route. To do this, just ensure
that you set the following properties on the component/endpoint:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">transacted</code> = true</li><li class="listitem"><code class="literal">transactionManager</code> = a <span class="emphasis"><em>Transsaction Manager</em></span> - typically the
<code class="literal">JmsTransactionManager</code></li></ul></div><p>See the <a class="link" href="transactional-client.html" target="_top">Transactional Client</a> EIP pattern
for further details.</p><p>Transactions and [Request Reply] over JMS</p><p>When using <a class="link" href="request-reply.html" target="_top">Request Reply</a> over JMS you cannot
use a single transaction; JMS will not send any messages until a commit
is performed, so the server side won&#8217;t receive anything at all until the
transaction commits. Therefore to use <a class="link" href="request-reply.html" target="_top">Request
Reply</a> you must commit a transaction after sending the request and then
use a separate transaction for receiving the response.</p><p>To address this issue the JMS component uses different properties to
specify transaction use for oneway messaging and request reply
messaging:</p><p>The <code class="literal">transacted</code> property applies <span class="strong"><strong>only</strong></span> to the InOnly message
<a class="link" href="exchange-pattern.html" target="_top">Exchange Pattern</a> (MEP).</p><p>The <code class="literal">transactedInOut</code> property applies to the
InOut(<a class="link" href="request-reply.html" target="_top">Request Reply</a>) message
<a class="link" href="exchange-pattern.html" target="_top">Exchange Pattern</a> (MEP).</p><p>If you want to use transactions for <a class="link" href="request-reply.html" target="_top">Request
Reply</a>(InOut MEP), you <span class="strong"><strong>must</strong></span> set <code class="literal">transactedInOut=true</code>.</p><p><span class="strong"><strong>Available as of Camel 2.10</strong></span></p><p>You can leverage the
<a class="link" href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.html#setSessionTransacted(boolean)" target="_top">DMLC
transacted session API</a> using the following properties on
component/endpoint:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">transacted</code> = true</li><li class="listitem"><code class="literal">lazyCreateTransactionManager</code> = false</li></ul></div><p>The benefit of doing so is that the cacheLevel setting will be honored
when using local transactions without a configured TransactionManager.
When a TransactionManager is configured, no caching happens at DMLC
level and its necessary to rely on a pooled connection factory. For more
details about this kind of setup see
<a class="link" href="http://tmielke.blogspot.com/2012/03/camel-jms-with-transactions-lessons.html" target="_top">here</a>
and
<a class="link" href="http://forum.springsource.org/showthread.php?123631-JMS-DMLC-not-caching%20connection-when-using-TX-despite-cacheLevel-CACHE_CONSUMER&amp;p=403530&amp;posted=1#post403530" target="_top">here</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-UsingJMSReplyToforlatereplies"></a>Using JMSReplyTo for late replies</h2></div></div></div><p>When using Camel as a JMS listener, it sets an Exchange property with
the value of the ReplyTo <code class="literal">javax.jms.Destination</code> object, having the key
<code class="literal">ReplyTo</code>. You can obtain this <code class="literal">Destination</code> as follows:</p><pre class="programlisting">Destination replyDestination = exchange.getIn().getHeader(JmsConstants.JMS_REPLY_DESTINATION, Destination.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>);</pre><p>And then later use it to send a reply using regular JMS or Camel.</p><pre class="programlisting">    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// we need to pass in the JMS component, and in this sample we use ActiveMQ</em>
    JmsEndpoint endpoint = JmsEndpoint.newInstance(replyDestination, activeMQComponent);
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// now we have the endpoint we can use regular Camel API to send a message to it</em>
    template.sendBody(endpoint, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Here is the late reply."</em></strong>);</pre><p>A different solution to sending a reply is to provide the
<code class="literal">replyDestination</code> object in the same Exchange property when sending.
Camel will then pick up this property and use it for the real
destination. The endpoint URI must include a dummy destination, however.
For example:</p><pre class="programlisting">    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// we pretend to send it to some non existing dummy queue</em>
    template.send(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:dummy, new Processor() {
</em></strong>        <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> process(Exchange exchange) <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">throws</strong> Exception {
            <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// and here we override the destination with the ReplyTo destination object so the message is sent to there instead of dummy</em>
            exchange.getIn().setHeader(JmsConstants.JMS_DESTINATION, replyDestination);
            exchange.getIn().setBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Here is the late reply."</em></strong>);
        }
    }</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Usingarequesttimeout"></a>Using a request timeout</h2></div></div></div><p>In the sample below we send a <a class="link" href="request-reply.html" target="_top">Request Reply</a>
style message <a class="link" href="exchange.html" target="_top">Exchange</a> (we use the <code class="literal">requestBody</code>
method = <code class="literal">InOut</code>) to the slow queue for further processing in Camel and
we wait for a return reply:</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-Samples"></a>Samples</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-ReceivingfromJMS">Receiving from JMS</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-SendingtoJMS">Sending to JMS</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingAnnotations">Using Annotations</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-SpringDSLsample">Spring DSL sample</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-Othersamples">Other samples</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingJMSasaDeadLetterQueuestoringExchange">Using JMS as a Dead Letter Queue storing Exchange</a></span></dt><dt><span class="section"><a href="JMS-JMSComponent.html#JMS-UsingJMSasaDeadLetterChannelstoringerroronly">Using JMS as a Dead Letter Channel storing error only</a></span></dt></dl></div><p>JMS is used in many examples for other components as well. But we
provide a few samples below to get started.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-ReceivingfromJMS"></a>Receiving from JMS</h3></div></div></div><p>In the following sample we configure a route that receives JMS messages
and routes the message to a POJO:</p><pre class="programlisting">   from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:foo"</em></strong>).
     to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:myBusinessLogic"</em></strong>);</pre><p>You can of course use any of the EIP patterns so the route can be
context based. For example, here&#8217;s how to filter an order topic for the
big spenders:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:topic:OrdersTopic"</em></strong>).
  filter().method(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"myBean"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"isGoldCustomer"</em></strong>).
    to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:BigSpendersQueue"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-SendingtoJMS"></a>Sending to JMS</h3></div></div></div><p>In the sample below we poll a file folder and send the file content to a
JMS topic. As we want the content of the file as a <code class="literal">TextMessage</code> instead
of a <code class="literal">BytesMessage</code>, we need to convert the body to a <code class="literal">String</code>:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"file://orders"</em></strong>).
  convertBodyTo(String.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>).
  to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:topic:OrdersTopic"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingAnnotations"></a>Using <a class="link" href="bean-integration.html" target="_top">Annotations</a></h3></div></div></div><p>Camel also has annotations so you can use <a class="link" href="pojo-consuming.html" target="_top">POJO
Consuming</a> and <a class="link" href="pojo-producing.html" target="_top">POJO Producing</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-SpringDSLsample"></a>Spring DSL sample</h3></div></div></div><p>The preceding examples use the Java DSL. Camel also supports Spring XML
DSL. Here is the big spender sample using Spring DSL:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;route&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;from</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"jms:topic:OrdersTopic"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;filter&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;method</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">bean</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"myBean"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">method</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"isGoldCustomer"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;to</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"jms:queue:BigSpendersQueue"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/filter&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/route&gt;</strong></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-Othersamples"></a>Other samples</h3></div></div></div><p>JMS appears in many of the examples for other components and EIP
patterns, as well in this Camel documentation. So feel free to browse
the documentation. If you have time, check out the this tutorial that
uses JMS but focuses on how well Spring Remoting and Camel works
together <a class="link" href="tutorial-jmsremoting.html" target="_top">Tutorial-JmsRemoting</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingJMSasaDeadLetterQueuestoringExchange"></a>Using JMS as a Dead Letter Queue storing Exchange</h3></div></div></div><p>Normally, when using <a class="link" href="jms.html" target="_top">JMS</a> as the transport, it only
transfers the body and headers as the payload. If you want to use
<a class="link" href="jms.html" target="_top">JMS</a> with a <a class="link" href="dead-letter-channel.html" target="_top">Dead Letter
Channel</a>, using a JMS queue as the Dead Letter Queue, then normally the
caused Exception is not stored in the JMS message. You can, however, use
the <code class="literal">transferExchange</code> option on the JMS dead letter queue to instruct
Camel to store the entire <a class="link" href="exchange.html" target="_top">Exchange</a> in the queue as a
<code class="literal">javax.jms.ObjectMessage</code> that holds a
<code class="literal">org.apache.camel.impl.DefaultExchangeHolder</code>. This allows you to
consume from the Dead Letter Queue and retrieve the caused exception
from the Exchange property with the key <code class="literal">Exchange.EXCEPTION_CAUGHT</code>. The
demo below illustrates this:</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// setup error handler to use JMS as queue and store the entire Exchange</em>
errorHandler(deadLetterChannel(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:dead?transferExchange=true"</em></strong>));</pre><p>Then you can consume from the JMS queue and analyze the problem:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:dead"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bean:myErrorAnalyzer"</em></strong>);

<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// and in our bean</em>
String body = exchange.getIn().getBody();
Exception cause = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>);
<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// the cause message is</em>
String problem = cause.getMessage();</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="JMS-UsingJMSasaDeadLetterChannelstoringerroronly"></a>Using JMS as a Dead Letter Channel storing error only</h3></div></div></div><p>You can use JMS to store the cause error message or to store a custom
body, which you can initialize yourself. The following example uses the
<a class="link" href="message-translator.html" target="_top">Message Translator</a> EIP to do a
transformation on the failed exchange before it is moved to the
<a class="link" href="jms.html" target="_top">JMS</a> dead letter queue:</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// we sent it to a seda dead queue first</em>
errorHandler(deadLetterChannel(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"seda:dead"</em></strong>));

<em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// and on the seda dead queue we can do the custom transformation before its sent to the JMS queue</em>
from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"seda:dead"</em></strong>).transform(exceptionMessage()).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jms:queue:dead"</em></strong>);</pre><p>Here we only store the original cause error message in the transform.
You can, however, use any <a class="link" href="expression.html" target="_top">Expression</a> to send
whatever you like. For example, you can invoke a method on a Bean or use
a custom processor.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-SendinganInOnlymessageandkeepingtheJMSReplyToheader"></a>Sending an InOnly message and keeping the JMSReplyTo header</h2></div></div></div><p>When sending to a <a class="link" href="jms.html" target="_top">JMS</a> destination using <span class="strong"><strong>camel-jms</strong></span> the
producer will use the MEP to detect if its <span class="emphasis"><em>InOnly</em></span> or <span class="emphasis"><em>InOut</em></span> messaging.
However there can be times where you want to send an <span class="emphasis"><em>InOnly</em></span> message but
keeping the <code class="literal">JMSReplyTo</code> header. To do so you have to instruct Camel to
keep it, otherwise the <code class="literal">JMSReplyTo</code> header will be dropped.</p><p>For example to send an <span class="emphasis"><em>InOnly</em></span> message to the foo queue, but with a
<code class="literal">JMSReplyTo</code> with bar queue you can do as follows:</p><pre class="programlisting">        template.send(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:queue:foo?preserveMessageQos=true"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> Processor() {
            <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> process(Exchange exchange) <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">throws</strong> Exception {
                exchange.getIn().setBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"World"</em></strong>);
                exchange.getIn().setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"JMSReplyTo"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bar"</em></strong>);
            }
        });</pre><p>Notice we use <code class="literal">preserveMessageQos=true</code> to instruct Camel to keep the
<code class="literal">JMSReplyTo</code> header.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-SettingJMSprovideroptionsonthedestination"></a>Setting JMS provider options on the destination</h2></div></div></div><p>Some JMS providers, like IBM&#8217;s WebSphere MQ need options to be set on
the JMS destination. For example, you may need to specify the
<code class="literal">targetClient</code> option. Since <code class="literal">targetClient</code> is a WebSphere MQ option and not
a Camel URI option, you need to set that on the JMS destination name
like so:</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">// ...</em>
.setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"CamelJmsDestinationName"</em></strong>, constant(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"queue:///MY_QUEUE?targetClient=1"</em></strong>))
.to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"wmq:queue:MY_QUEUE?useMessageIDAsCorrelationID=true"</em></strong>);</pre><p>Some versions of WMQ won&#8217;t accept this option on the destination name
and you will get an exception like:</p><pre class="screen">com.ibm.msg.client.jms.DetailedJMSException: JMSCC0005: The specified
value 'MY_QUEUE?targetClient=1' is not allowed for
'XMSC_DESTINATION_NAME'</pre><p>A workaround is to use a custom DestinationResolver:</p><pre class="programlisting">JmsComponent wmq = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> JmsComponent(connectionFactory);

wmq.setDestinationResolver(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> DestinationResolver() {
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> Destination resolveDestinationName(Session session, String destinationName, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">boolean</strong> pubSubDomain) <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">throws</strong> JMSException {
        MQQueueSession wmqSession = (MQQueueSession) session;
        <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</strong> wmqSession.createQueue(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"queue:///"</em></strong> + destinationName + <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"?targetClient=1"</em></strong>);
    }
});</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JMS-SeeAlso"></a>See Also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="configuring-camel.html" target="_top">Configuring Camel</a></li><li class="listitem"><a class="link" href="component.html" target="_top">Component</a></li><li class="listitem"><a class="link" href="endpoint.html" target="_top">Endpoint</a></li><li class="listitem"><a class="link" href="getting-started.html" target="_top">Getting Started</a></li><li class="listitem"><a class="link" href="transactional-client.html" target="_top">Transactional Client</a></li><li class="listitem"><a class="link" href="bean-integration.html" target="_top">Bean Integration</a></li><li class="listitem"><a class="link" href="tutorial-jmsremoting.html" target="_top">Tutorial-JmsRemoting</a></li><li class="listitem"><a class="link" href="http://activemq.apache.org/jmstemplate-gotchas.html" target="_top">JMSTemplate
gotchas</a></li></ul></div></div></div></body></html>