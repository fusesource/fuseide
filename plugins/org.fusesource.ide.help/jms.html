<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>JMS</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="RiderMsgEptRef.html" title="Messaging Endpoints"><link rel="prev" href="irc.html" title="IRC"><link rel="next" href="mail.html" title="Mail"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="jms"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>JMS &#8212; allows message to be sent to or consumed from JMS destinations</p></div><div class="refsection"><a name="d0e42034"></a><h2>Overview</h2><p>The JMS component allows messages to be sent to (or consumed from) a <a class="link" href="http://java.sun.com/products/jms/" target="_top">JMS</a> destination. The
            implementation of the JMS Component uses Spring's JMS support for declarative
            transactions, using Spring's <code class="literal">JmsTemplate</code> for sending and a
                <code class="literal">MessageListenerContainer</code> for consuming.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If you are using Red Hat JBoss A-MQ, use the <a class="link" href="ActiveMQ.html" title="ActiveMQ">ActiveMQ</a> endpoint; 
                it has been optimized for Red Hat JBoss A-MQ. All of
                the options and samples on this page are also valid for the <a class="link" href="ActiveMQ.html" title="ActiveMQ">ActiveMQ</a> component.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If using transactions with JMS, see section <a class="xref" href="jms.html#JMS_HSH_TransactionsandCacheLevels" title="Transactions and Cache Levels">Transactions and Cache Levels</a> as it can impact
                performance.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Be sure to read the section <a class="xref" href="jms.html#JMS_HSH_RequestreplyoverJMS" title="Request-reply over JMS">Request-reply over JMS</a> for
                important notes about request/reply, as Camel offers a number of options to
                configure for performance, and clustered environments.</p></td></tr></table></div></div><div class="refsection"><a name="d0e42067"></a><h2>URI format</h2><p>The URI format for a JMS endpoint is:</p><pre class="programlisting">
jms:[queue:|topic:]destinationName[?options]
</pre><p>Where <code class="literal">destinationName</code> is a JMS queue or topic name. By default,
                <code class="literal">destinationName</code> is interpreted as a queue name. For example, to
            connect to the queue, <code class="literal">FOO.BAR</code> use:</p><pre class="programlisting">
jms:FOO.BAR
</pre><p>You can include the optional <code class="literal">queue:</code> prefix, if you prefer:</p><pre class="programlisting">
jms:queue:FOO.BAR
</pre><p>To connect to a topic, you <span class="emphasis"><em>must</em></span> include the
                <code class="literal">topic:</code> prefix. For example, to connect to the topic,
                <code class="literal">Stocks.Prices</code>, use:</p><pre class="programlisting">
jms:topic:Stocks.Prices
</pre><p>You append query options to the URI using the following format,
                <code class="literal">?option=value&amp;option=value&amp;...</code>
        </p></div><div class="refsection"><a name="d0e42112"></a><h2>Dependencies</h2><p>Maven users will need to add the following dependency to their
                <code class="literal">pom.xml</code> for this component:</p><pre class="programlisting">
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
    &lt;artifactId&gt;camel-jms&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
    &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;
</pre></div><div class="refsection"><a name="JMS_HSH_UsingActiveMQ"></a><h2>Using ActiveMQ</h2><p>The JMS component reuses Spring 2's <code class="literal">JmsTemplate</code> for sending
            messages. This is not ideal for use in a non-J2EE container and typically requires some
            caching in the JMS provider to avoid <a class="link" href="http://activemq.apache.org/jmstemplate-gotchas.html" target="_top">poor
                performance</a>.</p><p>If you intend to use <a class="link" href="http://activemq.apache.org/" target="_top">Apache
                ActiveMQ</a> as your Message Broker - which is a good choice as ActiveMQ rocks
            :-) , then we recommend that you either:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use the <a class="link" href="ActiveMQ.html" title="ActiveMQ">ActiveMQ</a> component, which is
                    already optimized to use ActiveMQ efficiently</p></li><li class="listitem"><p>Use the <code class="literal">PoolingConnectionFactory</code> in ActiveMQ.</p></li></ul></div></div><div class="refsection"><a name="JMS_HSH_TransactionsandCacheLevels"></a><h2>Transactions and Cache Levels</h2><p><span class="phrase"><a name="JMS_HSH_transactionCacheLevels"></a></span> If you are consuming messages and
            using transactions (<code class="literal">transacted=true</code>) then the default settings for
            cache level can impact performance. If you are using XA transactions then you cannot
            cache as it can cause the XA transaction to not work properly.</p><p>If you are <span class="bold"><strong>not</strong></span> using XA, then you should consider
            caching as it speeds up performance, such as setting
                <code class="literal">cacheLevelName=CACHE_CONSUMER</code>.</p><p>Through Camel 2.7.x, the default setting for <code class="literal">cacheLevelName</code> is
                <code class="literal">CACHE_CONSUMER</code>. You will need to explicitly set
                <code class="literal">cacheLevelName=CACHE_NONE</code>. In Camel 2.8 onwards, the default
            setting for <code class="literal">cacheLevelName</code> is <code class="literal">CACHE_AUTO</code>. This
            default auto detects the mode and sets the cache level accordingly to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>CACHE_CONSUMER = if transacted=false</p></li><li class="listitem"><p>CACHE_NONE = if transacted=true</p></li></ul></div><p>So you can say the default setting is conservative. Consider using
                <code class="literal">cacheLevelName=CACHE_CONSUMER</code> if you are using non-XA
            transactions.</p></div><div class="refsection"><a name="JMS_HSH_DurableSubscriptions"></a><h2>Durable Subscriptions</h2><p>If you wish to use durable topic subscriptions, you need to specify both <span class="bold"><strong>clientId</strong></span> and <span class="bold"><strong>durableSubscriptionName</strong></span>. The value of the <code class="literal">clientId</code>
            must be unique and can only be used by a single JMS connection instance in your entire
            network. You may prefer to use <a class="link" href="http://activemq.apache.org/virtual-destinations.html" target="_top">Virtual Topics</a>
            instead to avoid this limitation. More background on durable messaging <a class="link" href="http://activemq.apache.org/how-do-durable-queues-and-topics-work.html" target="_top">here</a>.</p></div><div class="refsection"><a name="JMS_HSH_MessageHeaderMapping"></a><h2>Message Header Mapping</h2><p>When using message headers, the JMS specification states that header names must be
            valid Java identifiers. So try to name your headers to be valid Java identifiers. One
            benefit of doing this is that you can then use your headers inside a JMS Selector (whose
            SQL92 syntax mandates Java identifier syntax for headers).</p><p>A simple strategy for mapping header names is used by default. The strategy is to
            replace any dots and hyphens in the header name as shown below and to reverse the
            replacement when the header name is restored from a JMS message sent over the wire. What
            does this mean? No more losing method names to invoke on a bean component, no more
            losing the filename header for the File Component, and so on.</p><p>The current header name strategy for accepting header names in Camel is as
            follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Dots are replaced by <code class="literal">\_DOT\_</code> and the replacement is
                    reversed when Camel consume the message</p></li><li class="listitem"><p>Hyphen is replaced by <code class="literal">\_HYPHEN\_</code> and the replacement is
                    reversed when Camel consumes the message</p></li></ul></div></div><div class="refsection"><a name="JMS_HSH_Mostcommonlyusedoptions"></a><h2>Most commonly used options</h2><p><a class="xref" href="jms.html#JMSOptsTbl">JMS Common Options</a> and <a class="xref" href="jms.html#JMSOptsTbl2" title="Table&nbsp;34.&nbsp;Other JMS options">Table&nbsp;34, &#8220;Other JMS options&#8221;</a> list the options for a
            JMS endpoint, which map to properties on the <a class="link" href="http://camel.apache.org/maven/current/camel-jms/apidocs/org/apache/camel/component/jms/JmsConfiguration.html" target="_top">JMSConfiguration POJO</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Many of these properties map to properties on Spring JMS, which Apache Camel uses
                for sending and receiving messages. You can get more information about these
                properties by consulting the relevant Spring documentation.</p></td></tr></table></div><table id="JMSOptsTbl"><tr>
                <th>Option </th>
                <th>Default </th>
                <th>Description </th>
            </tr><tr>
                <td>
                    <code class="literal">clientId</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td> Sets the JMS client ID to use. Note that this value, if specified, must be
                    unique and can only be used by a single JMS connection instance. It is typically
                    only required for durable topic subscriptions. You may prefer to use <a class="link" href="http://activemq.apache.org/virtual-destinations.html" target="_top">Virtual
                        Topics</a> instead. </td>
            </tr><tr>
                <td>
                    <code class="literal">concurrentConsumers</code>
                </td>
                <td>
                    <code class="literal">1</code>
                </td>
                <td> Specifies the default number of concurrent consumers. From <span class="bold"><strong>Camel 2.10.3</strong></span> onwards this option can also be used
                    when doing request/reply over JMS. See also the
                        <code class="literal">maxMessagesPerTask</code> option to control dynamic scaling
                    up/down of threads. </td>
            </tr><tr>
                <td>
                    <code class="literal">disableReplyTo</code>
                </td>
                <td>
                    <code class="literal">false</code>
                </td>
                <td> If <code class="literal">true</code>, a producer will behave like a InOnly exchange with
                    the exception that <code class="literal">JMSReplyTo</code> header is sent out and not be
                    suppressed like in the case of <code class="literal">InOnly</code>. Like
                        <code class="literal">InOnly</code> the producer will not wait for a reply. A consumer
                    with this flag will behave like <code class="literal">InOnly</code>. This feature can be
                    used to bridge <code class="literal">InOut</code> requests to another queue so that a
                    route on the other queue will send its response directly back to the original
                        <code class="literal">JMSReplyTo</code>. </td>
            </tr><tr>
                <td>
                    <code class="literal">durableSubscriptionName</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td> The durable subscriber name for specifying durable topic subscriptions. The
                        <code class="literal">clientId</code> option <span class="bold"><strong>must</strong></span> be
                    configured as well. </td>
            </tr><tr>
                <td>
                    <code class="literal">maxConcurrentConsumers</code>
                </td>
                <td>
                    <code class="literal">1</code>
                </td>
                <td> Specifies the maximum number of concurrent consumers. From <span class="bold"><strong>Camel 2.10.3</strong></span> onwards this option can also be used
                    when doing request/reply over JMS. See also the
                        <code class="literal">maxMessagesPerTask</code> option to control dynamic scaling
                    up/down of threads. </td>
            </tr><tr>
                <td>
                    <code class="literal">maxMessagesPerTask</code>
                </td>
                <td>
                    <code class="literal">\-1</code>
                </td>
                <td> The number of messages per task. \-1 is unlimited. If you use a range for
                    concurrent consumers (eg min &lt; max), then this option can be used to set a
                    value to eg <code class="literal">100</code> to control how fast the consumers will shrink
                    when less work is required. </td>
            </tr><tr>
                <td>
                    <code class="literal">preserveMessageQos</code>
                </td>
                <td>
                    <code class="literal">false</code>
                </td>
                <td> Set to <code class="literal">true</code>, if you want to send message using the QoS
                    settings specified on the message, instead of the QoS settings on the JMS
                    endpoint. The following three headers are considered
                        <code class="literal">JMSPriority</code>, <code class="literal">JMSDeliveryMode</code>, and
                        <code class="literal">JMSExpiration</code>. You can provide all or only some of them.
                    If not provided, Camel will fall back to use the values from the endpoint
                    instead. So, when using this option, the headers override the values from the
                    endpoint. The <code class="literal">explicitQosEnabled</code> option, by contrast, will
                    only use options set on the endpoint, and not values from the message header.
                </td>
            </tr><tr>
                <td>
                    <code class="literal">replyTo</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td> Provides an explicit ReplyTo destination, which overrides any incoming value of
                        <code class="literal">Message.getJMSReplyTo()</code>. If you do <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a> over JMS then <span class="bold"><strong>make sure</strong></span> to read the section <span class="emphasis"><em>Request-reply
                        over JMS</em></span> further below for more details, and the
                        <code class="literal">replyToType</code> option as well. </td>
            </tr><tr>
                <td>
                    <code class="literal">replyToType</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td>
                    <span class="bold"><strong>Camel 2.9:</strong></span> Allows for explicitly specifying
                    which kind of strategy to use for replyTo queues when doing request/reply over
                    JMS. Possible values are: <code class="literal">Temporary</code>,
                        <code class="literal">Shared</code>, or <code class="literal">Exclusive</code>. By default Camel
                    will use temporary queues. However if <code class="literal">replyTo</code> has been
                    configured, then <code class="literal">Shared</code> is used by default. This option
                    allows you to use exclusive queues instead of shared ones. See further below for
                    more details, and especially the notes about the implications if running in a
                    clustered environment, and the fact that <code class="literal">Shared</code> reply queues
                    has lower performance than its alternatives <code class="literal">Temporary</code> and
                        <code class="literal">Exclusive</code>. </td>
            </tr><tr>
                <td>
                    <code class="literal">requestTimeout</code>
                </td>
                <td>
                    <code class="literal">20000</code>
                </td>
                <td>
                    <span class="bold"><strong>Producer only:</strong></span> The timeout for waiting for a
                    reply when using the InOut <a class="link" href="http://camel.apache.org/exchange-pattern.html" target="_top">Exchange
                        Pattern</a> (in milliseconds). The default is 20 seconds. See below in
                    section <span class="emphasis"><em>About time to live</em></span> for more details. See also the
                        <span class="emphasis"><em>requestTimeoutCheckerInterval</em></span> option. </td>
            </tr><tr>
                <td>
                    <code class="literal">selector</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td> Sets the JMS Selector, which is an SQL 92 predicate that is used to filter
                    messages within the broker. You may have to encode special characters such as =
                    as %3D <span class="bold"><strong>Before Camel 2.3.0</strong></span>, we don't support
                    this option in CamelConsumerTemplate </td>
            </tr><tr>
                <td>
                    <code class="literal">timeToLive</code>
                </td>
                <td>
                    <code class="literal">null</code>
                </td>
                <td> When sending messages, specifies the time-to-live of the message (in
                    milliseconds). See below in section <span class="emphasis"><em>About time to live</em></span> for
                    more details. </td>
            </tr><tr>
                <td>
                    <code class="literal">transacted</code>
                </td>
                <td>
                    <code class="literal">false</code>
                </td>
                <td> Specifies whether to use transacted mode for sending/receiving messages using
                    the InOnly <a class="link" href="http://camel.apache.org/exchange-pattern.html" target="_top">Exchange Pattern</a>. </td>
            </tr><tr>
                <td>
                    <code class="literal">testConnectionOnStartup</code>
                </td>
                <td>
                    <code class="literal">false</code>
                </td>
                <td>
                    <span class="bold"><strong>Camel 2.1:</strong></span> Specifies whether to test the
                    connection on startup. This ensures that when Camel starts that all the JMS
                    consumers have a valid connection to the JMS broker. If a connection cannot be
                    granted then Camel throws an exception on startup. This ensures that Camel is
                    not started with failed connections. From <span class="bold"><strong>Camel
                        2.8</strong></span> onwards also the JMS producers is tested as well. </td>
            </tr></table></div><div class="refsection"><a name="JMS_HSH_Alltheotheroptions"></a><h2>All other options</h2><div class="table"><a name="JMSOptsTbl2"></a><p class="title"><b>Table&nbsp;34.&nbsp;Other JMS options</b></p><div class="table-contents"><table summary="Other JMS options" width="100%" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="literal">acceptMessages</code>
                            <code class="literal">WhileStopping</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p>Specifies whether the consumer accept messages while it is
                                stopping. You might consider enabling this option, if you start and
                                stop <a class="link" href="jms.html" title="JMS">JMS</a> routes at runtime,
                                while there are still messages enqued on the queue.</p>
                            <p>If this option is <code class="literal">false</code>, and you stop the
                                <a class="link" href="jms.html" title="JMS">JMS</a> route, messages may be
                                rejected, and the JMS broker would have to attempt redeliveries,
                                which may also be rejected. Eventually, the message may be moved to
                                a dead letter queue on the JMS broker. To avoid this scenario,
                                enable this option.</p>
                        </td></tr><tr><td>
                            <code class="literal">acknowledgement</code>
                            <code class="literal">ModeName</code>
                        </td><td>
                            <p>
                                <code class="literal">AUTO</code>
                            </p>
                            <p>
                                <code class="literal">_ACKNOWLEDGE</code>
                            </p>
                        </td><td>The JMS acknowledgement name, which is one of:
                                <code class="literal">SESSION_TRANSACTED</code>,
                                <code class="literal">CLIENT_ACKNOWLEDGE</code>,
                                <code class="literal">AUTO_ACKNOWLEDGE</code>, and
                                <code class="literal">DUPS_OK_ACKNOWLEDGE</code>
                        </td></tr><tr><td>
                            <code class="literal">acknowledgementMode</code>
                        </td><td>
                            <code class="literal">\-1</code>
                        </td><td>The JMS acknowledgement mode defined as an Integer. This option
                            enables you to set vendor-specific extensions in the acknowledgment
                            mode. For the regular modes, it is preferable to use the
                                <code class="literal">acknowledgementModeName</code>. </td></tr><tr><td>
                            <code class="literal">allowNullBody</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td><span class="bold"><strong>Camel 2.9.3/2.10.1:</strong></span> Specifies
                            whether to allow sending messages with no body. If this option is
                                <code class="literal">false</code> and the message body is null, an
                                <code class="literal">JMSException</code> is thrown. </td></tr><tr><td>
                            <code class="literal">alwaysCopyMessage</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p>If <code class="literal">true</code>, Camel always makes a JMS message copy
                                of the message when it is passed to the producer for sending.
                                Copying the message is needed in some situations, such as when a
                                    <code class="literal">replyToDestinationSelectorName</code> is set.</p>
                            <p>Camel sets the <code class="literal">alwaysCopyMessage</code> option to
                                    <code class="literal">true</code> when a
                                    <code class="literal">replyToDestinationSelectorName</code> is
                                set.)</p>
                        </td></tr><tr><td>
                            <code class="literal">asyncConsumer</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.9:</strong></span> Specifies whether the
                                    <code class="literal">JmsConsumer</code> processes the <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a>
                                <a class="link" href="http://camel.apache.org/asynchronous-routing-engine.html" target="_top">asynchronously</a>.</p>
                            <p>If enabled, the <code class="literal">JmsConsumer</code> may pickup the next
                                message from the JMS queue, while the previous message is being
                                processed asynchronously (by the <a class="link" href="http://camel.apache.org/asynchronous-routing-engine.html" target="_top">Asynchronous Routing
                                    Engine</a>). This means that messages may not be processed in
                                order.</p>
                            <p>If disabled (as default), the <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> is fully processed before the
                                    <code class="literal">JmsConsumer</code> picks up the next message from
                                the JMS queue. Note that if <code class="literal">transacted</code> is
                                enabled, <code class="literal">asyncConsumer=true</code> does not run
                                asynchronously because transactions must be executed
                                synchronously.</p>
                        </td></tr><tr><td>
                            <code class="literal">asyncStartListener</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.10:</strong></span> Specifies whether to
                                startup the <code class="literal">JmsConsumer</code> message listener
                                asynchronously when starting a route.</p>
                            <p>For example, if a <code class="literal">JmsConsumer</code> cannot get a
                                connection to a remote JMS broker, it may block while retrying or
                                failing over. This will cause Camel to block while starting
                                routes.</p>
                            <p>Setting this option to <code class="literal">true</code>enables routes to
                                startup while the <code class="literal">JmsConsumer</code> connects to the JMS
                                broker, using a dedicated thread in asynchronous mode. If you use
                                this option, be aware that if the connection cannot be established,
                                an exception is logged at <code class="literal">WARN</code> level, and the
                                consumer will be unable to receive messages. In this case, you can
                                restart the route to retry connecting.</p>
                        </td></tr><tr><td>
                            <code class="literal">asyncStopListener</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td><span class="bold"><strong>Camel 2.10:</strong></span> Specifies whether to
                            stop the <code class="literal">JmsConsumer</code> message listener asynchronously
                            when stopping a route. </td></tr><tr><td>
                            <code class="literal">autoStartup</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>Specifies whether the consumer container should auto-startup.
                        </td></tr><tr><td>
                            <code class="literal">cacheLevelName</code>
                        </td><td>
                            <p>
                                <code class="literal">CACHE_AUTO </code>
                            </p>
                            <p> (Camel 2.8.0+)</p>
                            <p>
                                <code class="literal">CACHE_CONSUMER</code>
                            </p>
                            <p> (Camel 2.7.1-)</p>
                        </td><td>
                            <p>Sets the cache level by name for the underlying JMS resources.
                                Possible values are: <code class="literal">CACHE_AUTO</code>,
                                    <code class="literal">CACHE_CONNECTION</code>,
                                    <code class="literal">CACHE_CONSUMER</code>,
                                <code class="literal">CACHE_NONE</code>, and
                                <code class="literal">CACHE_SESSION</code>.</p>
                            <p><span class="bold"><strong>Camel 2.8 onwards:</strong></span> The default
                                setting is <code class="literal">CACHE_AUTO</code>. <span class="bold"><strong>Camel 2.7.1 and earlier:</strong></span> The default is
                                    <code class="literal">CACHE_CONSUMER</code>.</p>
                            <p>For details, see the <a class="link" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jms/listener/DefaultMessageListenerContainer.html" target="_top">Spring documentation</a> and <a class="xref" href="jms.html#JMS_HSH_TransactionsandCacheLevels" title="Transactions and Cache Levels">Transactions and Cache Levels</a>.</p>
                        </td></tr><tr><td>
                            <code class="literal">cacheLevel</code>
                        </td><td>&nbsp;</td><td>Sets the cache level by ID for the underlying JMS resources. See
                                <code class="literal">cacheLevelName</code> option for more details. </td></tr><tr><td>
                            <code class="literal">consumerType</code>
                        </td><td>
                            <code class="literal">Default</code>
                        </td><td>
                            <p>Specifies the consumer type to use, which can be one of:
                                    <code class="literal">Simple</code>, <code class="literal">Default</code>, or
                                    <code class="literal">Custom</code>.</p>
                            <p>The consumer type determines which Spring JMS listener to use.
                                    <code class="literal">Default</code> will use
                                    <code class="literal">org.springframework.jms.listener.DefaultMessage</code><code class="literal">ListenerContainer</code>,
                                    <code class="literal">Simple</code> will use
                                    <code class="literal">org.springframework.jms.listener.SimpleMessage</code><code class="literal">ListenerContainer</code>.</p>
                            <p>When <code class="literal">Custom</code> is specified, the
                                    <code class="literal">MessageListenerContainerFactory</code> defined by
                                the <code class="literal">messageListenerContainerFactoryRef</code> option
                                will determine what
                                    <code class="literal">org.springframework.jms.listener.AbstractMessage</code><code class="literal">ListenerContainer</code>
                                to use (<span class="bold"><strong>new option in Camel 2.11 and
                                    2.10.2</strong></span>). This option was temporary removed in Camel
                                2.7 and 2.8. But has been added back from Camel 2.9 onwards.</p>
                        </td></tr><tr><td>
                            <code class="literal">connectionFactory</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>The default JMS connection factory to use for the
                                <code class="literal">listener</code><code class="literal">ConnectionFactory</code> and
                                <code class="literal">templateConnectionFactory</code>, if neither is
                            specified. </td></tr><tr><td>
                            <code class="literal">defaultTask</code>
                            <code class="literal">ExecutorType</code>
                        </td><td> (see description) </td><td>
                            <p><span class="bold"><strong>Camel 2.10.4:</strong></span> Specifies the
                                default TaskExecutor type to use in the
                                DefaultMessageListenerContainer, for both consumer endpoints and the
                                ReplyTo consumer of producer endpoints.</p>
                            <p>Possible values: <code class="literal">SimpleAsync</code> (uses Spring's
                                    <a class="link" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html" target="_top">SimpleAsyncTaskExecutor</a>) or
                                    <code class="literal">ThreadPool</code> (uses Spring's <a class="link" href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html" target="_top">ThreadPoolTaskExecutor</a> with optimal values&#8212;cached
                                threadpool-like).</p>
                            <p>If not set, defaults to the previous behaviour, which uses a
                                cached thread pool for consumer endpoints and SimpleAsync for reply
                                consumers.</p>
                            <p>The use of <code class="literal">ThreadPool</code> is recommended to reduce
                                "thread trash" in elastic configurations with dynamically increasing
                                and decreasing concurrent consumers.</p>
                        </td></tr><tr><td>
                            <code class="literal">deliveryPersistent</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>Specifies whether persistent delivery is used by default. </td></tr><tr><td>
                            <code class="literal">destination</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the JMS Destination object to use on this endpoint.
                        </td></tr><tr><td>
                            <code class="literal">destinationName</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the JMS destination name to use on this endpoint. </td></tr><tr><td>
                            <code class="literal">destinationResolver</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>A pluggable
                                <code class="literal">org.springframework.jms.support.destination.</code><code class="literal">DestinationResolver</code>
                            that allows you to use your own resolver (for example, to lookup the
                            real destination in a JNDI registry). </td></tr><tr><td>
                            <code class="literal">disableTimeToLive</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.8:</strong></span> Use this option to
                                force disabling time to live.</p>
                            <p>For example, when you do request/reply over JMS, Camel, by
                                default, uses the <code class="literal">requestTimeout</code> value as time to
                                live on the message being sent.</p>
                            <p>The problem is that the systems clocks on the sender and the
                                receiver must be synchronized. This is not always easy to achieve.
                                In that case, you can use <code class="literal">disableTimeToLive=true</code>
                                on the message to prevent it from expiring on the receiver system.
                                See <a class="xref" href="jms.html#JMS_HSH_Abouttimetolive" title="About time to live">About time to live</a> for more
                                details.</p>
                        </td></tr><tr><td>
                            <code class="literal">eagerLoadingOf</code>
                            <code class="literal">Properties</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>Enables eager loading of JMS properties as soon as a message is
                            received, which is generally inefficient, because the JMS properties
                            might not be required. But this feature can sometimes catch early any
                            issues with the underlying JMS provider and the use of JMS properties.
                            This feature can also be used for testing purposes, to ensure JMS
                            properties can be understood and handled correctly. </td></tr><tr><td>
                            <code class="literal">exceptionListener</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the JMS Exception Listener that is to be notified of any
                            underlying JMS exceptions. </td></tr><tr><td>
                            <code class="literal">errorHandler</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.8.2, 2.9:</strong></span> Specifies a
                                    <code class="literal">org.springframework.util.ErrorHandler</code> to be
                                invoked in case of any uncaught exceptions thrown while processing a
                                    <code class="literal">Message</code>.</p>
                            <p>By default, these exceptions are logged at the WARN level when no
                                    <code class="literal">errorHandler</code> is configured.</p>
                            <p><span class="bold"><strong>Camel 2.9.1 onwards:</strong></span> Using the
                                next two options, you can configure the logging level and whether to
                                log stack traces. This is easier to configure than coding a custom
                                    <code class="literal">errorHandler</code>.</p>
                        </td></tr><tr><td>
                            <code class="literal">errorHandlerLogging</code>
                            <code class="literal">Level</code>
                        </td><td>
                            <code class="literal">WARN</code>
                        </td><td><span class="bold"><strong>Camel 2.9.1:</strong></span> Allows to configure the
                            default <code class="literal">errorHandler</code> logging level for logging
                            uncaught exceptions. </td></tr><tr><td>
                            <code class="literal">errorHandlerLog</code>
                            <code class="literal">StackTrace</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td><span class="bold"><strong>Camel 2.9.1:</strong></span> Allows to control
                            whether stacktraces should be logged or not, by the default
                                <code class="literal">errorHandler</code>. </td></tr><tr><td>
                            <code class="literal">explicitQosEnabled</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p>Sets whether the <code class="literal">deliveryMode</code>,
                                    <code class="literal">priority</code> or <code class="literal">timeToLive</code>
                                qualities of service should be used when sending messages. This
                                option is based on Spring's <code class="literal">JmsTemplate</code>.</p>
                            <p>The <code class="literal">deliveryMode</code>, <code class="literal">priority</code>
                                and <code class="literal">timeToLive</code> options are applied to the current
                                endpoint. This contrasts with the
                                    <code class="literal">preserveMessageQos</code> option, which operates at
                                message granularity, reading QoS properties exclusively from the
                                Camel In message headers.</p>
                        </td></tr><tr><td>
                            <code class="literal">exposeListenerSession</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>Specifies whether the listener session should be exposed when
                            consuming messages. </td></tr><tr><td>
                            <code class="literal">forceSendOriginal</code>
                            <code class="literal">Message</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.7:</strong></span> When using
                                    <code class="literal">mapJmsMessage=false</code> Camel creates a new JMS
                                message to send to a new JMS destination if you touch the headers
                                (get or set) during the route.</p>
                            <p>Set this option to <code class="literal">true</code> to force Camel to send
                                the original JMS message that was received.</p>
                        </td></tr><tr><td>
                            <code class="literal">idleTaskExecution</code>
                            <code class="literal">Limit</code>
                        </td><td>
                            <code class="literal">1</code>
                        </td><td>
                            <p>Specifies the limit for idle executions of a receive task that has
                                not received any message within its execution.</p>
                            <p>When this limit is reached, the task shuts down and leaves
                                receiving to other executing tasks (in the case of dynamic
                                scheduling; see the <code class="literal">maxConcurrentConsumers</code>
                                setting).</p>
                        </td></tr><tr><td>
                            <code class="literal">idleConsumerLimit</code>
                        </td><td>
                            <code class="literal">1</code>
                        </td><td><span class="bold"><strong>Camel 2.8.2, 2.9:</strong></span> Specifies the
                            limit for the number of consumers that can be idle at any given time.
                        </td></tr><tr><td>
                            <code class="literal">includeSentJMS</code>
                            <code class="literal">MessageID</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.10.3:</strong></span> Only applicable
                                when sending to JMS destination using InOnly (eg fire and
                                forget).</p>
                            <p>Enabling this option enriches the Camel <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> with the actual JMSMessageID that was used by
                                the JMS client when the message was sent to the JMS
                                destination.</p>
                        </td></tr><tr><td>
                            <code class="literal">includeAllJMSX</code>
                            <code class="literal">Properties</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.11.2/2.12:</strong></span> Specifies
                                whether to include all JMSXxxx properties when mapping from JMS to
                                Camel Message.</p>
                            <p>Setting this to <code class="literal">true</code> includes properties such
                                as <code class="literal">JMSXAppID</code>, and <code class="literal">JMSXUserID</code>,
                                etc.</p>
                            <p>If using a custom <code class="literal">headerFilterStrategy</code>, this
                                option does not apply.</p>
                        </td></tr><tr><td>
                            <code class="literal">jmsMessageType</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Allows you to force the use of a specific
                                <code class="literal">javax.jms.Message</code> implementation for sending JMS
                            messages. Possible values are: <code class="literal">Bytes</code>,
                                <code class="literal">Map</code>, <code class="literal">Object</code>,
                                <code class="literal">Stream</code>, <code class="literal">Text</code>. By default,
                            Camel would determine which JMS message type to use from the In body
                            type. This option allows you to specify it. </td></tr><tr><td>
                            <code class="literal">jmsKeyFormatStrategy</code>
                        </td><td>
                            <code class="literal">default</code>
                        </td><td>
                            <p>Pluggable strategy for encoding and decoding JMS keys so they can
                                be compliant with the JMS specification.</p>
                            <p>Camel provides two implementations out-of-the-box:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">default</code>&#8212;safely marshals dots
                                            and hyphens (<code class="literal">.</code> and
                                                <code class="literal">\-</code>)</p></li><li class="listitem"><p><code class="literal">passthrough</code>&#8212;leaves the key as
                                            is</p><p>You can use <code class="literal">passthrough</code> for JMS
                                            brokers that do not care whether JMS header keys contain
                                            illegal characters.</p></li></ul></div>
                            <p>You can provide your own implementation of the
                                    <code class="literal">org.apache.camel.component.jms.JmsKeyFormatStrategy</code>
                                and refer to it using <code class="literal">\#</code> notation.</p>
                        </td></tr><tr><td>
                            <code class="literal">jmsOperations</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <p>Allows you to use your implementation of the
                                    <code class="literal">org.springframework.jms.core.JmsOperations</code>
                                interface.</p>
                            <p>Camel uses <code class="literal">JmsTemplate</code> by default. Can be used
                                for testing purposes, but not much as stated in the Spring API
                                docs.</p>
                        </td></tr><tr><td>
                            <code class="literal">lazyCreateTransaction</code>
                            <code class="literal">Manager</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>If <code class="literal">true</code>, Camel creates a
                                <code class="literal">JmsTransactionManager</code> if there is no
                                <code class="literal">transactionManager</code> injected when option
                                <code class="literal">transacted=true</code>. </td></tr><tr><td>
                            <code class="literal">listenerConnection</code>
                            <code class="literal">Factory</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the JMS connection factory used for consuming messages.
                        </td></tr><tr><td>
                            <code class="literal">mapJmsMessage</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>
                            <p>Specifies whether Camel should auto map the received JMS message
                                to an appropiate payload type, such as mapping
                                    <code class="literal">javax.jms.TextMessage</code> to a
                                    <code class="literal">String</code>, etc.</p>
                            <p>See section <a class="xref" href="jms.html#JMSMsgMapping" title="Message mapping">Message mapping</a> for more
                                details.</p>
                        </td></tr><tr><td>
                            <code class="literal">maximumBrowseSize</code>
                        </td><td>
                            <code class="literal">\-1</code>
                        </td><td>Limits the number of messages fetched at most, when browsing
                            endpoints using <a class="link" href="http://camel.apache.org/browse.html" target="_top">Browse</a> or JMX
                            API. </td></tr><tr><td>
                            <code class="literal">messageConverter</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Allows you to use a custom Spring
                                <code class="literal">org.springframework.jms.support.converter.</code><code class="literal">MessageConverter</code>
                            so you can be 100% in control of how to map to/from a
                                <code class="literal">javax.jms.Message</code>. </td></tr><tr><td>
                            <code class="literal">messageIdEnabled</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>When sending, specifies whether message IDs should be added. </td></tr><tr><td>
                            <code class="literal">messageListener</code>
                            <code class="literal">ContainerFactoryRef</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.10.2:</strong></span> Registry ID of the
                                    <code class="literal">MessageListenerContainerFactory</code> used to
                                determine which
                                    <code class="literal">org.springframework.jms.listener.AbstractMessage</code><code class="literal">ListenerContainer</code>
                                to use to consume messages.</p>
                            <p>Setting this will automatically set
                                    <code class="literal">consumerType</code> to
                                <code class="literal">Custom</code>.</p>
                        </td></tr><tr><td>
                            <code class="literal">messageTimestamp </code>
                            <code class="literal">Enabled</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>Specifies whether timestamps should be enabled by default on sending
                            messages. </td></tr><tr><td>
                            <code class="literal">password</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the password for the connector factory. </td></tr><tr><td>
                            <code class="literal">priority</code>
                        </td><td>
                            <code class="literal">4</code>
                        </td><td>
                            <p>Specifies the message priority.</p>
                            <p>Values greater than <code class="literal">1</code> specify the message
                                priority when sending (where <code class="literal">0</code> is the lowest
                                priority, and <code class="literal">9</code> is the highest).</p>
                            <p>The <code class="literal">explicitQosEnabled</code> option must also be
                                enabled for this option to have any effect.</p>
                        </td></tr><tr><td>
                            <code class="literal">pubSubNoLocal</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>Specifies whether to inhibit the delivery of messages published by
                            its own connection. </td></tr><tr><td>
                            <code class="literal">receiveTimeout</code>
                        </td><td>
                            <span class="emphasis"><em>None</em></span>
                        </td><td>Specifies the timeout for receiving messages (in milliseconds).
                        </td></tr><tr><td>
                            <code class="literal">recoveryInterval</code>
                        </td><td>
                            <code class="literal">5000</code>
                        </td><td>Specifies the interval between recovery attempts&#8212;when a
                            connection is being refreshed, in ms. The default is 5000 ms. </td></tr><tr><td>
                            <code class="literal">replyToCacheLevelName</code>
                        </td><td>
                            <p>
                                <code class="literal">CACHE</code>
                            </p>
                            <p>
                                <code class="literal">_CONSUMER</code>
                            </p>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.9.1:</strong></span> Sets the cache level
                                by name for the reply consumer when doing request/reply over
                                JMS.</p>
                            <p>This option applies only when using fixed reply queues (not
                                temporary ones). Camel, by default, uses:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">CACHE_CONSUMER</code>&#8212;for
                                            exclusive or shared w/
                                                <code class="literal">replyToSelectorName</code></p></li><li class="listitem"><p><code class="literal">CACHE_SESSION</code>&#8212;for
                                            shared without
                                            <code class="literal">replyToSelectorName</code></p></li></ul></div>
                            <p>Some JMS brokers, such as IBM WebSphere, may require you to set
                                the <code class="literal">replyToCacheLevelName=CACHE_NONE</code>.</p>
                        </td></tr><tr><td>
                            <code class="literal">replyToDestination</code>
                            <code class="literal">SelectorName</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <p>Sets the JMS Selector specifying the fixed name to use, so you can
                                filter out your own replies when using a shared queue (not using a
                                temporary reply queue).</p>
                        </td></tr><tr><td>
                            <code class="literal">replyToDelivery</code>
                            <code class="literal">Persistent</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td>Specifies whether to use persistent delivery by default for replies.
                        </td></tr><tr><td>
                            <code class="literal">requestTimeout</code>
                            <code class="literal">CheckerInterval</code>
                        </td><td>
                            <code class="literal">1000</code>
                        </td><td>
                            <p><span class="bold"><strong>Camel 2.9.2:</strong></span> Specifies how often
                                Camel should check for timed out <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a>s when doing request/reply over JMS.</p>
                            <p>By default, Camel checks once per second. But if you must react
                                faster when a timeout occurs, you can lower this interval to check
                                more frequently.</p>
                            <p>The timeout is determined by the option
                                    <span class="emphasis"><em>requestTimeout</em></span>.</p>
                        </td></tr><tr><td>
                            <code class="literal">subscriptionDurable</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td><span class="bold"><strong>@deprecated:</strong></span> Enabled by default, if
                            you specify a <code class="literal">durableSubscriberName</code> and a
                                <code class="literal">clientId</code>. </td></tr><tr><td>
                            <code class="literal">taskExecutor</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies a custom task executor for consuming messages. </td></tr><tr><td>
                            <code class="literal">taskExecutorSpring2</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td><span class="bold"><strong>Camel 2.6:</strong></span> To use when using Spring
                            2.x with Camel. Allows you to specify a custom task executor for
                            consuming messages. </td></tr><tr><td>
                            <code class="literal">templateConnection</code>
                            <code class="literal">Factory</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>The JMS connection factory used for sending messages. </td></tr><tr><td>
                            <code class="literal">transactedInOut</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p><span class="bold"><strong>@deprecated:</strong></span> Specifies whether to
                                use transacted mode for sending messages using the InOut <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange Pattern</a>.</p>
                            <p>Applies only to producer endpoints. See section <a class="xref" href="jms.html#JMS_HSH_EnablingTransactedConsumption" title="Enabling Transacted Consumption">Enabling Transacted Consumption</a> for more details.</p>
                        </td></tr><tr><td>
                            <code class="literal">transactionManager</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>Specifies the Spring transaction manager to use. </td></tr><tr><td>
                            <code class="literal">transactionName</code>
                        </td><td>
                            <p>
                                <code class="literal">"JmsConsumer</code>
                            </p>
                            <p>
                                <code class="literal">[destinationName]"</code>
                            </p>
                        </td><td>Specifies the name of the transaction to use. </td></tr><tr><td>
                            <code class="literal">transactionTimeout</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>The timeout value of the transaction (in seconds) when using
                            transacted mode. </td></tr><tr><td>
                            <code class="literal">transferException</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p>When enabled and you are using <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request
                                    Reply</a> messaging (<span class="bold"><strong>InOut</strong></span>)
                                and an <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> fails on the
                                consumer side, the resulting <code class="literal">Exception</code> is sent
                                back in response as a
                                <code class="literal">javax.jms.ObjectMessage</code>.</p>
                            <p>If the client is Camel, the returned <code class="literal">Exception</code>
                                is rethrown. This allows you to use Camel <a class="link" href="jms.html" title="JMS">JMS</a> as a bridge in your routing;
                                for example, using persistent queues to enable robust
                                routing.</p>
                            <p>Note that if you have also enabled <span class="bold"><strong>transferExchange</strong></span>, this option takes
                                precedence.</p>
                            <p>The caught exception must be serializable. The original
                                    <code class="literal">Exception</code> on the consumer side can be wrapped
                                in an outer exception, such as
                                    <code class="literal">org.apache.camel.RuntimeCamelException</code>, when
                                it's returned to the producer.</p>
                        </td></tr><tr><td>
                            <code class="literal">transferExchange</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p>Allows you to transfer the exchange over the wire, not just the
                                body and headers.</p>
                            <p>The following fields are transferred: <code class="literal">In body</code>,
                                    <code class="literal">Out body</code>, <code class="literal">Fault body</code>,
                                    <code class="literal">In headers</code>, <code class="literal">Out headers</code>,
                                    <code class="literal">Fault headers</code>, <code class="literal">exchange
                                    properties</code>, and <code class="literal">exchange
                                exception</code>.</p>
                            <p>The objects must be serializable. Camel excludes any
                                non-serializable object and logs it at <code class="literal">WARN</code>
                                level.</p>
                            <p>You must enable this option on both the producer and consumer
                                side, so Camel knows the payload is an Exchange, not a regular
                                payload.</p>
                        </td></tr><tr><td>
                            <code class="literal">username</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>The username for the connector factory.</td></tr><tr><td>
                            <code class="literal">useMessageIDAs</code>
                            <code class="literal">CorrelationID</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>Specifies whether <code class="literal">JMSMessageID</code> should always be
                            used as <code class="literal">JMSCorrelationID</code> for <span class="bold"><strong>InOut</strong></span> messages.</td></tr><tr><td>
                            <code class="literal">useVersion102</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td><span class="bold"><strong>@deprecated (removed from Camel 2.5
                                onwards):</strong></span> Specifies whether the old JMS API should be
                            used.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="JMSMsgMapping"></a><h2>Message mapping</h2><p>Apache Camel automatically maps messages between <code class="literal">javax.jms.Message</code>
            and <code class="literal">org.apache.camel.Message</code>.</p><p>When sending a JMS message, Apache Camel converts the message body to the JMS message
            types shown in <a class="xref" href="jms.html#JMSRefMsgTbl1" title="Table&nbsp;35.&nbsp;Mapping from Apache Camel to JMS">Table&nbsp;35</a>.</p><div class="table"><a name="JMSRefMsgTbl1"></a><p class="title"><b>Table&nbsp;35.&nbsp;Mapping from Apache Camel to JMS</b></p><div class="table-contents"><table summary="Mapping from Apache Camel to JMS" width="100%" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th>Body Type</th><th>JMS Message</th></tr></thead><tbody><tr><td>
                            <code class="literal">String</code>
                        </td><td>
                            <code class="literal">javax.jms.TextMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">org.w3c.dom.Node</code>
                            <a href="#ftn.d0e44333" class="footnote"><sup class="footnote"><a name="d0e44333"></a>[a]</sup></a>
                        </td><td>
                            <code class="literal">javax.jms.TextMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">Map</code>
                        </td><td>
                            <code class="literal">javax.jms.MapMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">java.io.Serializable</code>
                        </td><td>
                            <code class="literal">javax.jms.ObjectMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">byte[]</code>
                        </td><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">java.io.File</code>
                        </td><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">java.io.Reader</code>
                        </td><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">java.io.InputStream</code>
                        </td><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td></tr><tr><td>
                            <code class="literal">java.nio.ByteBuffer</code>
                        </td><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.d0e44333" class="footnote"><p><a href="#d0e44333" class="para"><sup class="para">[a] </sup></a>The DOM will be converted to <code class="literal">String</code></p></div></td></tr></tbody></table></div></div><br class="table-break"><p>When receiving a JMS message, Apache Camel converts the JMS message to body type
            listed in <a class="xref" href="jms.html#JMSRefMsgTbl2" title="Table&nbsp;36.&nbsp;Mapping from JMS to Apache Camel">Table&nbsp;36, &#8220;Mapping from JMS to Apache Camel&#8221;</a>.</p><div class="table"><a name="JMSRefMsgTbl2"></a><p class="title"><b>Table&nbsp;36.&nbsp;Mapping from JMS to Apache Camel</b></p><div class="table-contents"><table summary="Mapping from JMS to Apache Camel" width="100%" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th>JMS Message</th><th>Body Type</th></tr></thead><tbody><tr><td>
                            <code class="literal">javax.jms.TextMessage</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td></tr><tr><td>
                            <code class="literal">javax.jms.BytesMessage</code>
                        </td><td>
                            <code class="literal">byte[]</code>
                        </td></tr><tr><td>
                            <code class="literal">javax.jms.MapMessage</code>
                        </td><td>
                            <code class="literal">Map&lt;String, Object&gt;</code>
                        </td></tr><tr><td>
                            <code class="literal">javax.jms.ObjectMessage</code>
                        </td><td>
                            <code class="literal">Object</code>
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="JMS_HSH_DisablingautomappingofJMSmessages"></a><h2>Disabling auto-mapping of JMS messages</h2><p>You can use the <code class="literal">mapJmsMessage</code> option to disable the auto-mapping
            above. If disabled, Camel will not try to map the received JMS message, but instead uses
            it directly as the payload. This allows you to avoid the overhead of mapping and let
            Camel just pass through the JMS message. For instance, it even allows you to route
                <code class="literal">javax.jms.ObjectMessage</code> JMS messages with classes you do
                <span class="bold"><strong>not</strong></span> have on the classpath.</p></div><div class="refsection"><a name="JMS_HSH_UsingacustomMessageConverter"></a><h2>Using a custom MessageConverter</h2><p>You can use the <code class="literal">messageConverter</code> option to do the mapping yourself
            in a Spring
                <code class="literal">org.springframework.jms.support.converter.MessageConverter</code>
            class.</p><p>For example, in the route below we use a custom message converter when sending a
            message to the JMS order queue:</p><pre class="programlisting">
  from("file://inbox/order").to("jms:queue:order?messageConverter=#myMessageConverter");
</pre><p>You can also use a custom message converter when consuming from a JMS
            destination.</p></div><div class="refsection"><a name="JMS_HSH_Controllingthemappingstrategyselected"></a><h2>Controlling the mapping strategy selected</h2><p>You can use the <span class="bold"><strong>jmsMessageType</strong></span> option on the endpoint
            URL to force a specific message type for all messages. In the route below, we poll files
            from a folder and send them as <code class="literal">javax.jms.TextMessage</code> as we have
            forced the JMS producer endpoint to use text messages:</p><pre class="programlisting">
  from("file://inbox/order").to("jms:queue:order?jmsMessageType=Text");
</pre><p>You can also specify the message type to use for each messabe by setting the header
            with the key <code class="literal">CamelJmsMessageType</code>. For example:</p><pre class="programlisting">
  from("file://inbox/order").setHeader("CamelJmsMessageType", JmsMessageType.Text).to("jms:queue:order");
</pre><p>The possible values are defined in the <code class="literal">enum</code> class,
                <code class="literal">org.apache.camel.jms.JmsMessageType</code>.</p></div><div class="refsection"><a name="JMS_HSH_Messageformatwhensending"></a><h2>Message format when sending</h2><p>The exchange that is sent over the JMS wire must conform to the <a class="link" href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="_top">JMS Message
                spec</a>.</p><p>For the <code class="literal">exchange.in.header</code> the following rules apply for the header
                <span class="bold"><strong>keys</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Keys starting with <code class="literal">JMS</code> or <code class="literal">JMSX</code> are
                    reserved.</p></li><li class="listitem"><p><code class="literal">exchange.in.headers</code> keys must be literals and all be valid
                    Java identifiers (do not use dots in the key name).</p></li><li class="listitem"><p>Camel replaces dots &amp; hyphens and the reverse when when consuming JMS
                    messages: <code class="literal">.</code> is replaced by <code class="literal">\_DOT\_</code> and the
                    reverse replacement when Camel consumes the message. <code class="literal">\-</code> is
                    replaced by <code class="literal">\_HYPHEN\_</code> and the reverse replacement when Camel
                    consumes the message.</p></li><li class="listitem"><p>See also the option <code class="literal">jmsKeyFormatStrategy</code>, which allows use
                    of your own custom strategy for formatting keys.</p></li></ul></div><p>For the <code class="literal">exchange.in.header</code>, the following rules apply for the
            header <span class="bold"><strong>values</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The values must be primitives or their counter objects (such as
                        <code class="literal">Integer</code>, <code class="literal">Long</code>,
                        <code class="literal">Character</code>). The types, <code class="literal">String</code>,
                        <code class="literal">CharSequence</code>, <code class="literal">Date</code>,
                        <code class="literal">BigDecimal</code> and <code class="literal">BigInteger</code> are all
                    converted to their <code class="literal">toString()</code> representation. All other types
                    are dropped.</p></li></ul></div><p>Camel will log with category
                <code class="literal">org.apache.camel.component.jms.JmsBinding</code> at <span class="bold"><strong>DEBUG</strong></span> level if it drops a given header value. For
            example:</p><pre class="programlisting">
            
2008-07-09 06:43:04,046 [main           ] DEBUG JmsBinding
  - Ignoring non primitive header: order of class: org.apache.camel.component.jms.issues.DummyOrder with value: DummyOrder{orderId=333, itemId=4444, quantity=2}
</pre></div><div class="refsection"><a name="JMS_HSH_Messageformatwhenreceiving"></a><h2>Message format when receiving</h2><p>Camel adds the following properties to the <code class="literal">Exchange</code> when it
            receives a message:
        </p><table id="d0e44650"><tr>
                <th> Property </th>
                <th> Type </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <code class="literal">org.apache.camel.jms.replyDestination</code>
                </td>
                <td>
                    <code class="literal">javax.jms.Destination</code>
                </td>
                <td> The reply destination. </td>
            </tr></table><p>Camel adds the following JMS properties to the In message headers when it receives a
            JMS message: </p><table id="d0e44681"><tr>
                <th> Header </th>
                <th> Type </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <code class="literal">JMSCorrelationID</code>
                </td>
                <td>
                    <code class="literal">String</code>
                </td>
                <td> The JMS correlation ID. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSDeliveryMode</code>
                </td>
                <td>
                    <code class="literal">int</code>
                </td>
                <td> The JMS delivery mode. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSDestination</code>
                </td>
                <td>
                    <code class="literal">javax.jms.Destination</code>
                </td>
                <td> The JMS destination. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSExpiration</code>
                </td>
                <td>
                    <code class="literal">long</code>
                </td>
                <td> The JMS expiration. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSMessageID</code>
                </td>
                <td>
                    <code class="literal">String</code>
                </td>
                <td> The JMS unique message ID. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSPriority</code>
                </td>
                <td>
                    <code class="literal">int</code>
                </td>
                <td> The JMS priority (with 0 as the lowest priority and 9 as the highest). </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSRedelivered</code>
                </td>
                <td>
                    <code class="literal">boolean</code>
                </td>
                <td> Is the JMS message redelivered. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSReplyTo</code>
                </td>
                <td>
                    <code class="literal">javax.jms.Destination</code>
                </td>
                <td> The JMS reply-to destination. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSTimestamp</code>
                </td>
                <td>
                    <code class="literal">long</code>
                </td>
                <td> The JMS timestamp. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSType</code>
                </td>
                <td>
                    <code class="literal">String</code>
                </td>
                <td> The JMS type. </td>
            </tr><tr>
                <td>
                    <code class="literal">JMSXGroupID</code>
                </td>
                <td>
                    <code class="literal">String</code>
                </td>
                <td> The JMS group ID. </td>
            </tr></table></div><div class="refsection"><a name="JMS_HSH_AboutusingCameltosendandreceivemessagesandJMSReplyTo"></a><h2>About using Camel to send and receive messages and JMSReplyTo</h2><p>The JMS component is complex and you have to pay close attention to how it works in
            some cases. So this is a short summary of some of the areas/pitfalls to look for.</p><p>When Camel sends a message using its <code class="literal">JMSProducer</code>, it checks the
            following conditions:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The message exchange pattern,</p></li><li class="listitem"><p>Whether a <code class="literal">JMSReplyTo</code> was set in the endpoint or in the
                    message headers,</p></li><li class="listitem"><p>Whether any of the following options have been set on the JMS endpoint:
                        <code class="literal">disableReplyTo</code>, <code class="literal">preserveMessageQos</code>,
                        <code class="literal">explicitQosEnabled</code>.</p></li></ul></div><p>All this can be a tad complex to understand and configure to support your use
            case.</p></div><div class="refsection"><a name="JMS_HSH_JmsProducer"></a><h2>JmsProducer</h2><p>The <code class="literal">JmsProducer</code> behaves as follows, depending on configuration:
        </p><table id="d0e44922"><tr>
                <th> Exchange Pattern </th>
                <th> Other options </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOut</em></span>
                </td>
                <td> \- </td>
                <td> Camel will expect a reply, set a temporary <code class="literal">JMSReplyTo</code>, and
                    after sending the message, it will start to listen for the reply message on the
                    temporary queue. </td>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOut</em></span>
                </td>
                <td><code class="literal">JMSReplyTo</code> is set </td>
                <td> Camel will expect a reply and, after sending the message, it will start to
                    listen for the reply message on the specified <code class="literal">JMSReplyTo</code>
                    queue. </td>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOnly</em></span>
                </td>
                <td> \- </td>
                <td> Camel will send the message and <span class="bold"><strong>not</strong></span> expect a
                    reply. </td>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOnly</em></span>
                </td>
                <td><code class="literal">JMSReplyTo</code> is set </td>
                <td> By default, Camel discards the <code class="literal">JMSReplyTo</code> destination and
                    clears the <code class="literal">JMSReplyTo</code> header before sending the message.
                    Camel then sends the message and does <span class="bold"><strong>not</strong></span>
                    expect a reply. Camel logs this in the log at <code class="literal">WARN</code> level
                    (changed to <code class="literal">DEBUG</code> level from <span class="bold"><strong>Camel
                        2.6</strong></span> onwards. You can use
                        <code class="literal">preserveMessageQuo=true</code> to instruct Camel to keep the
                        <code class="literal">JMSReplyTo</code>. In all situations the
                        <code class="literal">JmsProducer</code> does <span class="bold"><strong>not</strong></span>
                    expect any reply and thus continue after sending the message. </td>
            </tr></table></div><div class="refsection"><a name="JMS_HSH_JmsConsumer"></a><h2>JmsConsumer</h2><p>The <code class="literal">JmsConsumer</code> behaves as follows, depending on configuration: </p><table id="d0e45042"><tr>
                <th> Exchange Pattern </th>
                <th> Other options </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOut</em></span>
                </td>
                <td> \- </td>
                <td> Camel will send the reply back to the <code class="literal">JMSReplyTo</code> queue.
                </td>
            </tr><tr>
                <td>
                    <span class="emphasis"><em>InOnly</em></span>
                </td>
                <td> \- </td>
                <td> Camel will not send a reply back, as the pattern is
                    <span class="emphasis"><em>InOnly</em></span>. </td>
            </tr><tr>
                <td> \- </td>
                <td>
                    <code class="literal">disableReplyTo=true</code>
                </td>
                <td> This option suppresses replies. </td>
            </tr></table><p>So pay attention to the message exchange pattern set on your exchanges.</p><p>If you send a message to a JMS destination in the middle of your route you can specify
            the exchange pattern to use, see more at <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request
                Reply</a>. This is useful if you want to send an <code class="literal">InOnly</code>
            message to a JMS topic:</p><pre class="programlisting">
from("activemq:queue:in")
   .to("bean:validateOrder")
   .to(ExchangePattern.InOnly, "activemq:topic:order")
   .to("bean:handleOrder");
</pre></div><div class="refsection"><a name="JMS_HSH_Reuseendpointandsendtodifferentdestinationscomputedatruntime"></a><h2>Reuse endpoint and send to different destinations computed at runtime</h2><p>If you need to send messages to a lot of different JMS destinations, it makes sense to
            reuse a JMS endpoint and specify the real destination in a message header. This allows
            Camel to reuse the same endpoint, but send to different destinations. This greatly
            reduces the number of endpoints created and economizes on memory and thread
            resources.</p><p>You can specify the destination in the following headers:
        </p><table id="d0e45121"><tr>
                <th> Header </th>
                <th> Type </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <code class="literal">CamelJmsDestination</code>
                </td>
                <td>
                    <code class="literal">javax.jms.Destination</code>
                </td>
                <td> A destination object. </td>
            </tr><tr>
                <td>
                    <code class="literal">CamelJmsDestinationName</code>
                </td>
                <td>
                    <code class="literal">String</code>
                </td>
                <td> The destination name. </td>
            </tr></table><p>For example, the following route shows how you can compute a destination at run time
            and use it to override the destination appearing in the JMS URL:</p><pre class="programlisting">
from("file://inbox")
  .to("bean:computeDestination")
  .to("activemq:queue:dummy");
</pre><p>The queue name, <code class="literal">dummy</code>, is just a placeholder. It must be provided
            as part of the JMS endpoint URL, but it will be ignored in this example.</p><p>In the <code class="literal">computeDestination</code> bean, specify the real destination by
            setting the <code class="literal">CamelJmsDestinationName</code> header as follows:</p><pre class="programlisting">
public void setJmsHeader(Exchange exchange) {
   String id = ....
   exchange.getIn().setHeader("CamelJmsDestinationName", "order:" + id");
}
</pre><p>Then Camel will read this header and use it as the destination instead of the one
            configured on the endpoint. So, in this example Camel sends the message to
                <code class="literal">activemq:queue:order:2</code>, assuming the <code class="literal">id</code> value
            was 2.</p><p>If both the <code class="literal">CamelJmsDestination</code> and the
                <code class="literal">CamelJmsDestinationName</code> headers are set,
                <code class="literal">CamelJmsDestination</code> takes priority.</p></div><div class="refsection"><a name="JMS_HSH_ConfiguringdifferentJMSproviders"></a><h2>Configuring different JMS providers</h2><p>You can configure your JMS provider in <a class="link" href="http://camel.apache.org/spring.html" target="_top">Spring</a> XML as
            follows:</p><pre class="programlisting">&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;jmxAgent id="agent" disabled="true"/&gt;
&lt;/camelContext&gt;

&lt;bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent"&gt;
  &lt;property name="connectionFactory"&gt;
    &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
      &lt;property name="brokerURL" value="vm://localhost?broker.persistent=false&amp;roker.useJmx=false"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</pre><p>Basically, you can configure as many JMS component instances as you wish and give them
                <span class="bold"><strong>a unique name using the</strong></span><code class="literal">id</code>
            attribute. The preceding example configures an <code class="literal">activemq</code> component.
            You could do the same to configure MQSeries, TibCo, BEA, Sonic and so on.</p><p>Once you have a named JMS component, you can then refer to endpoints within that
            component using URIs. For example for the component name, <code class="literal">activemq</code>,
            you can then refer to destinations using the URI format,
                <code class="literal">activemq:[queue:|topic:]destinationName</code>. You can use the same
            approach for all other JMS providers.</p><p>This works by the SpringCamelContext lazily fetching components from the spring
            context for the scheme name you use for <a class="link" href="http://camel.apache.org/endpoint.html" target="_top">Endpoint</a>
            <a class="link" href="http://camel.apache.org/uris.html" target="_top">URIs</a> and having the <a class="link" href="http://camel.apache.org/component.html" target="_top">Component</a> resolve the endpoint URIs.</p></div><div class="refsection"><a name="JMS_HSH_UsingJNDItofindtheConnectionFactory"></a><h2>Using JNDI to find the ConnectionFactory</h2><p>If you are using a J2EE container, you might need to look up JNDI to find the JMS
                <code class="literal">ConnectionFactory</code> rather than use the usual
                <code class="literal">&lt;bean&gt;</code> mechanism in Spring. You can do this using Spring's
            factory bean or the new Spring XML namespace. For example:</p><pre class="programlisting">
&lt;bean id="weblogic" class="org.apache.camel.component.jms.JmsComponent"&gt;
  &lt;property name="connectionFactory" ref="myConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;jee:jndi-lookup id="myConnectionFactory" jndi-name="jms/connectionFactory"/&gt;
</pre><p>See <a class="link" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html#xsd-config-body-schemas-jee" target="_top">The jee schema</a> in the Spring reference documentation for more details about
            JNDI lookup.</p></div><div class="refsection"><a name="JMS_HSH_ConcurrentConsuming"></a><h2>Concurrent Consuming</h2><p>A common requirement with JMS is to consume messages concurrently in multiple threads
            in order to make an application more responsive. You can set the
                <code class="literal">concurrentConsumers</code> option to specify the number of threads
            servicing the JMS endpoint, as follows:</p><pre class="programlisting">
from("jms:SomeQueue?concurrentConsumers=20").
  bean(MyClass.class);
</pre><p>You can configure this option in one of the following ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>On the <code class="literal">JmsComponent</code>,</p></li><li class="listitem"><p>On the endpoint URI or,</p></li><li class="listitem"><p>By invoking <code class="literal">setConcurrentConsumers()</code> directly on the
                        <code class="literal">JmsEndpoint</code>.</p></li></ul></div></div><div class="refsection"><a name="JMS_HSH_RequestreplyoverJMS"></a><h2>Request-reply over JMS</h2><p>Camel supports <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a> over JMS. In essence
            the MEP of the Exchange should be <code class="literal">InOut</code> when you send a message to a
            JMS queue.</p><p>Camel offers a number of options to configure request/reply over JMS that influence
            performance and clustered environments. The table below summaries the options.</p><table width="932" id="d0e45306"><col width="21%"><col width="9%"><col width="5%"><col width="55%"><tr>
                <th>Option </th>
                <th>Performance </th>
                <th>Cluster </th>
                <th>Description </th>
            </tr><tr>
                <td>
                    <code class="literal">Temporary</code>
                </td>
                <td>Fast </td>
                <td> Yes </td>
                <td>A temporary queue is used as reply queue, and automatic created by Camel. To use
                    this do <span class="bold"><strong>not</strong></span> specify a replyTo queue name. And
                    you can optionally configure <code class="literal">replyToType=Temporary</code> to make it
                    stand out that temporary queues are in use. </td>
            </tr><tr>
                <td>
                    <code class="literal">Shared</code>
                </td>
                <td>Slow </td>
                <td> Yes </td>
                <td>A shared persistent queue is used as reply queue. The queue must be created
                    beforehand, although some brokers can create them on the fly such as Apache
                    ActiveMQ. To use this you must specify the replyTo queue name. And you can
                    optionally configure <code class="literal">replyToType=Shared</code> to make it stand out
                    that shared queues are in use. A shared queue can be used in a clustered
                    environment with multiple nodes running this Camel application at the same time.
                    All using the same shared reply queue. This is possible because JMS Message
                    selectors are used to correlate expected reply messages; this impacts
                    performance though. JMS Message selectors is slower, and therefore not as fast
                    as <code class="literal">Temporary</code> or <code class="literal">Exclusive</code> queues. See
                    further below how to tweak this for better performance. </td>
            </tr><tr>
                <td>
                    <code class="literal">Exclusive</code>
                </td>
                <td>Fast </td>
                <td> No </td>
                <td>An exclusive persistent queue is used as reply queue. The queue must be created
                    beforehand, although some brokers can create them on the fly such as Apache
                    ActiveMQ. To use this you must specify the replyTo queue name. And you <span class="bold"><strong>must</strong></span> configure
                        <code class="literal">replyToType=Exclusive</code> to instruct Camel to use exclusive
                    queues, as <code class="literal">Shared</code> is used by default, if a
                        <code class="literal">replyTo</code> queue name was configured. When using exclusive
                    reply queues, then JMS Message selectors are <span class="bold"><strong>not</strong></span> in use, and therefore other applications must not use this
                    queue as well. An exclusive queue <span class="bold"><strong>cannot</strong></span> be
                    used in a clustered environment with multiple nodes running this Camel
                    application at the same time; as we do not have control if the reply queue comes
                    back to the same node that sent the request message; that is why shared queues
                    use JMS Message selectors to make sure of this. <span class="bold"><strong>Though</strong></span> if you configure each Exclusive reply queue with an
                    unique name per node, then you can run this in a clustered environment. As then
                    the reply message will be sent back to that queue for the given node, that
                    awaits the reply message. </td>
            </tr><tr>
                <td>
                    <code class="literal">concurrentConsumers</code>
                </td>
                <td>Fast </td>
                <td> Yes </td>
                <td><span class="bold"><strong>Camel 2.10.3:</strong></span> Allows to process reply messages
                    concurrently using concurrent message listeners in use. You can specify a range
                    using the <code class="literal">concurrentConsumers</code> and
                        <code class="literal">maxConcurrentConsumers</code> options. <span class="bold"><strong>Notice:</strong></span> That using <code class="literal">Shared</code> reply queues may
                    not work as well with concurrent listeners, so use this option with care.</td>
            </tr><tr>
                <td>
                    <code class="literal">maxConcurrentConsumers</code>
                </td>
                <td>Fast </td>
                <td> Yes </td>
                <td><span class="bold"><strong>Camel 2.10.3:</strong></span> Allows to process reply messages
                    concurrently using concurrent message listeners in use. You can specify a range
                    using the <code class="literal">concurrentConsumers</code> and
                        <code class="literal">maxConcurrentConsumers</code> options. <span class="bold"><strong>Notice:</strong></span> That using <code class="literal">Shared</code> reply queues may
                    not work as well with concurrent listeners, so use this option with care. </td>
            </tr></table><p>The <code class="literal">JmsProducer</code> detects the <code class="literal">InOut</code> and provides a
                <code class="literal">JMSReplyTo</code> header with the reply destination to be used. By
            default Camel uses a temporary queue, but you can use the <code class="literal">replyTo</code>
            option on the endpoint to specify a fixed reply queue (see more below about fixed reply
            queue).</p><p>Camel will automatic setup a consumer which listen on the reply queue, so you should
                <span class="bold"><strong>not</strong></span> do anything. This consumer is a Spring
                <code class="literal">DefaultMessageListenerContainer</code> which listen for replies. However
            it's fixed to 1 concurrent consumer. That means replies will be processed in sequence as
            there are only 1 thread to process the replies. If you want to process replies faster,
            then we need to use concurrency. But <span class="bold"><strong>not</strong></span> using the
                <code class="literal">concurrentConsumer</code> option. We should use the
                <code class="literal">threads</code> from the Camel DSL instead, as shown in the route
            below:</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo")
.threads(5)
.to(yyy)
.to(zzz);
</pre><p>In this route we instruct Camel to route replies <a class="link" href="http://camel.apache.org/async.html" target="_top">asynchronously</a> using a thread pool with 5 threads.</p><p>From Camel 2.10.3 onwards you can now configure the listener to use concurrent threads
            using the <code class="literal">concurrentConsumers</code> and
                <code class="literal">maxConcurrentConsumers</code> options. This allows you to easier
            configure this in Camel as shown below:</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo?concurrentConsumers=5")
.to(yyy)
.to(zzz);
</pre></div><div class="refsection"><a name="JMS_HSH_RequestreplyoverJMSandusingasharedfixedreplyqueue"></a><h2>Request-reply over JMS and using a shared fixed reply queue</h2><p>If you use a fixed reply queue when doing <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request
                Reply</a> over JMS as shown in the example below, then pay attention.</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar")
.to(yyy)
</pre><p>In this example the fixed reply queue named "bar" is used. By default Camel assumes
            the queue is shared when using fixed reply queues, and therefore it uses a
                <code class="literal">JMSSelector</code> to only pickup the expected reply messages (eg based
            on the <code class="literal">JMSCorrelationID</code>). See next section for exclusive fixed reply
            queues. That means its not as fast as temporary queues. You can speedup how often Camel
            will pull for reply messages using the <code class="literal">receiveTimeout</code> option. By
            default its 1000 millis. So to make it faster you can set it to 250 millis to pull 4
            times per second as shown:</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&amp;receiveTimeout=250")
.to(yyy)
</pre><p>Notice this will cause the Camel to send pull requests to the message broker more
            frequent, and thus require more network traffic. It is generally recommended to use
            temporary queues if possible.</p></div><div class="refsection"><a name="JMS_HSH_RequestreplyoverJMSandusinganexclusivefixedreplyqueue"></a><h2>Request-reply over JMS and using an exclusive fixed reply queue</h2><p>
            <span class="bold"><strong>Available as of Camel 2.9</strong></span>
        </p><p>In the previous example, Camel would anticipate the fixed reply queue named "bar" was
            shared, and thus it uses a <code class="literal">JMSSelector</code> to only consume reply messages
            which it expects. However there is a drawback doing this as JMS selectos is slower. Also
            the consumer on the reply queue is slower to update with new JMS selector ids. In fact
            it only updates when the <code class="literal">receiveTimeout</code> option times out, which by
            default is 1 second. So in theory the reply messages could take up till about 1 sec to
            be detected. On the other hand if the fixed reply queue is exclusive to the Camel reply
            consumer, then we can avoid using the JMS selectors, and thus be more performant. In
            fact as fast as using temporary queues. So in <span class="bold"><strong>Camel 2.9</strong></span>
            onwards we introduced the <code class="literal">ReplyToType</code> option which you can configure
            to <code class="literal">Exclusive</code> to tell Camel that the reply queue is exclusive as shown
            in the example below:</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive")
.to(yyy)
</pre><p>Mind that the queue must be exclusive to each and every endpoint. So if you have two
            routes, then they each need an unique reply queue as shown in the next example:</p><pre class="programlisting">
from(xxx)
.inOut().to("activemq:queue:foo?replyTo=bar&amp;replyToType=Exclusive")
.to(yyy)

from(aaa)
.inOut().to("activemq:queue:order?replyTo=order.reply&amp;replyToType=Exclusive")
.to(bbb)
</pre><p>The same applies if you run in a clustered environment. Then each node in the cluster
            must use an unique reply queue name. As otherwise each node in the cluster may pickup
            messages which was intended as a reply on another node. For clustered environments its
            recommended to use shared reply queues instead.</p></div><div class="refsection"><a name="JMS_HSH_Synchronizingclocksbetweensendersandreceivers"></a><h2>Synchronizing clocks between senders and receivers</h2><p>When doing messaging between systems, its desirable that the systems have synchronized
            clocks. For example when sending a <a class="link" href="jms.html" title="JMS">JMS</a> message, then
            you can set a time to live value on the message. Then the receiver can inspect this
            value, and determine if the message is already expired, and thus drop the message
            instead of consume and process it. However this requires that both sender and receiver
            have synchronized clocks. If you are using <a class="link" href="http://activemq.apache.org/" target="_top">ActiveMQ</a> then you can use the <a class="link" href="http://activemq.apache.org/timestampplugin.html" target="_top">timestamp plugin</a> to
            synchronize clocks.</p></div><div class="refsection"><a name="JMS_HSH_Abouttimetolive"></a><h2>About time to live</h2><p>Read first above about synchronized clocks.</p><p>When you do request/reply (InOut) over <a class="link" href="jms.html" title="JMS">JMS</a> with
            Camel then Camel uses a timeout on the sender side, which is default 20 seconds from the
                <code class="literal">requestTimeout</code> option. You can control this by setting a
            higher/lower value. However the time to live value is still set on the <a class="link" href="jms.html" title="JMS">JMS</a> message being send. So that requires the clocks to
            be synchronized between the systems. If they are not, then you may want to disable the
            time to live value being set. This is now possible using the
                <code class="literal">disableTimeToLive</code> option from <span class="bold"><strong>Camel
                2.8</strong></span> onwards. So if you set this option to
                <code class="literal">disableTimeToLive=true</code>, then Camel does <span class="bold"><strong>not</strong></span> set any time to live value when sending <a class="link" href="jms.html" title="JMS">JMS</a> messages. <span class="bold"><strong>But</strong></span> the request timeout is
            still active. So for example if you do request/reply over <a class="link" href="jms.html" title="JMS">JMS</a> and have disabled time to live, then Camel will still use a timeout by
            20 seconds (the <code class="literal">requestTimeout</code> option). That option can of course
            also be configured. So the two options <code class="literal">requestTimeout</code> and
                <code class="literal">disableTimeToLive</code> gives you fine grained control when doing
            request/reply.</p><p>When you do fire and forget (InOut) over <a class="link" href="jms.html" title="JMS">JMS</a> with
            Camel then Camel by default does <span class="bold"><strong>not</strong></span> set any time to
            live value on the message. You can configure a value by using the
                <code class="literal">timeToLive</code> option. For example to indicate a 5 sec., you set
                <code class="literal">timeToLive=5000</code>. The option <code class="literal">disableTimeToLive</code>
            can be used to force disabling the time to live, also for InOnly messaging. The
                <code class="literal">requestTimeout</code> option is not being used for InOnly
            messaging.</p></div><div class="refsection"><a name="JMS_HSH_EnablingTransactedConsumption"></a><h2>Enabling Transacted Consumption</h2><p>A common requirement is to consume from a queue in a transaction and then process the
            message using the Camel route. To do this, just ensure that you set the following
            properties on the component/endpoint:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">transacted</code> = true</p></li><li class="listitem"><p><code class="literal">transactionManager</code> = a <span class="emphasis"><em>Transsaction
                        Manager</em></span> \- typically the <code class="literal">JmsTransactionManager</code>
                </p></li></ul></div><p>See the <a class="link" href="http://camel.apache.org/transactional-client.html" target="_top">Transactional Client</a> EIP pattern
            for further details.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>When using <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a> over JMS you cannot
                use a single transaction; JMS will not send any messages until a commit is
                performed, so the server side won't receive anything at all until the transaction
                commits. Therefore to use <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a> you
                must commit a transaction after sending the request and then use a separate
                transaction for receiving the response.</p><p>To address this issue the JMS component uses different properties to specify
                transaction use for oneway messaging and request reply messaging:</p><p>The <code class="literal">transacted</code> property applies <span class="bold"><strong>only</strong></span> to the InOnly message <a class="link" href="http://camel.apache.org/exchange-pattern.html" target="_top">Exchange
                    Pattern</a> (MEP).</p><p>The <code class="literal">transactedInOut</code> property applies to the InOut(<a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a>) message <a class="link" href="http://camel.apache.org/exchange-pattern.html" target="_top">Exchange Pattern</a> (MEP).</p><p>If you want to use transactions for <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request
                    Reply</a>(InOut MEP), you <span class="bold"><strong>must</strong></span> set
                    <code class="literal">transactedInOut=true</code>.</p></td></tr></table></div><p>
            <span class="bold"><strong>Available as of Camel 2.10</strong></span>
        </p><p>You can leverage the <a class="link" href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.html#setSessionTransacted(boolean)" target="_top">DMLC transacted session API</a> using the following properties on
            component/endpoint:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">transacted</code> = true</p></li><li class="listitem"><p><code class="literal">lazyCreateTransactionManager</code> = false</p></li></ul></div><p>The benefit of doing so is that the cacheLevel setting will be honored when using
            local transactions without a configured TransactionManager. When a TransactionManager is
            configured, no caching happens at DMLC level and its necessary to rely on a pooled
            connection factory. For more details about this kind of setup see <a class="link" href="http://tmielke.blogspot.com/2012/03/camel-jms-with-transactions-lessons.html" target="_top">here</a> and <a class="link" href="http://forum.springsource.org/showthread.php?123631-JMS-DMLC-not-caching connection-when-using-TX-despite-cacheLevel-CACHE_CONSUMER&amp;p=403530&amp;posted=1#post403530" target="_top">here</a>.</p></div><div class="refsection"><a name="JMS_HSH_UsingJMSReplyToforlatereplies"></a><h2>Using JMSReplyTo for late replies</h2><p>When using Camel as a JMS listener, it sets an Exchange property with the value of the
            ReplyTo <code class="literal">javax.jms.Destination</code> object, having the key
                <code class="literal">ReplyTo</code>. You can obtain this <code class="literal">Destination</code> as
            follows:</p><pre class="programlisting">
Destination replyDestination = exchange.getIn().getHeader(JmsConstants.JMS_REPLY_DESTINATION, Destination.class);
</pre><p>And then later use it to send a reply using regular JMS or Camel.</p><pre class="programlisting">
    // we need to pass in the JMS component, and in this sample we use ActiveMQ
    JmsEndpoint endpoint = JmsEndpoint.newInstance(replyDestination, activeMQComponent);
    // now we have the endpoint we can use regular Camel API to send a message to it
    template.sendBody(endpoint, "Here is the late reply.");
</pre><p>A different solution to sending a reply is to provide the
                <code class="literal">replyDestination</code> object in the same Exchange property when
            sending. Camel will then pick up this property and use it for the real destination. The
            endpoint URI must include a dummy destination, however. For example:</p><pre class="programlisting">
    // we pretend to send it to some non existing dummy queue
    template.send("activemq:queue:dummy, new Processor() {
        public void process(Exchange exchange) throws Exception {
            // and here we override the destination with the ReplyTo destination object so the message is sent to there instead of dummy
            exchange.getIn().setHeader(JmsConstants.JMS_DESTINATION, replyDestination);
            exchange.getIn().setBody("Here is the late reply.");
        }
    }
</pre></div><div class="refsection"><a name="JMS_HSH_Usingarequesttimeout"></a><h2>Using a request timeout</h2><p>In the sample below we send a <a class="link" href="http://camel.apache.org/request-reply.html" target="_top">Request Reply</a> style
            message <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> (we use the
                <code class="literal">requestBody</code> method = <code class="literal">InOut</code>) to the slow queue
            for further processing in Camel and we wait for a return reply:</p><pre class="programlisting">// send a in-out with a timeout for 5 sec
Object out = template.requestBody("activemq:queue:slow?requestTimeout=5000", "Hello World");
</pre></div><div class="refsection"><a name="JMS_HSH_Samples"></a><h2>Samples</h2><p>JMS is used in many examples for other components as well. But we provide a few
            samples below to get started.</p></div><div class="refsection"><a name="JMS_HSH_ReceivingfromJMS"></a><h2>Receiving from JMS</h2><p>In the following sample we configure a route that receives JMS messages and routes the
            message to a POJO:</p><pre class="programlisting">
   from("jms:queue:foo").
     to("bean:myBusinessLogic");
</pre><p>You can of course use any of the EIP patterns so the route can be context based. For
            example, here's how to filter an order topic for the big spenders:</p><pre class="programlisting">
from("jms:topic:OrdersTopic").
  filter().method("myBean", "isGoldCustomer").
    to("jms:queue:BigSpendersQueue");
</pre></div><div class="refsection"><a name="JMS_HSH_SendingtoaJMS"></a><h2>Sending to a JMS</h2><p>In the sample below we poll a file folder and send the file content to a JMS topic. As
            we want the content of the file as a <code class="literal">TextMessage</code> instead of a
                <code class="literal">BytesMessage</code>, we need to convert the body to a
                <code class="literal">String</code>:</p><pre class="programlisting">
from("file://orders").
  convertBodyTo(String.class).
  to("jms:topic:OrdersTopic");
</pre></div><div class="refsection"><a name="JMS_HSH_UsingAnnotationsBeanIntegration"></a><h2>Using <a class="link" href="http://camel.apache.org/bean-integration.html" target="_top">Annotations</a>
        </h2><p>Camel also has annotations so you can use <a class="link" href="http://camel.apache.org/pojo-consuming.html" target="_top">POJO
            Consuming</a> and <a class="link" href="http://camel.apache.org/pojo-producing.html" target="_top">POJO Producing</a>.</p></div><div class="refsection"><a name="JMS_HSH_SpringDSLsample"></a><h2>Spring DSL sample</h2><p>The preceding examples use the Java DSL. Camel also supports Spring XML DSL. Here is
            the big spender sample using Spring DSL:</p><pre class="programlisting">
&lt;route&gt;
  &lt;from uri="jms:topic:OrdersTopic"/&gt;
  &lt;filter&gt;
    &lt;method bean="myBean" method="isGoldCustomer"/&gt;
    &lt;to uri="jms:queue:BigSpendersQueue"/&gt;
  &lt;/filter&gt;
&lt;/route&gt;
</pre></div><div class="refsection"><a name="JMS_HSH_Othersamples"></a><h2>Other samples</h2><p>JMS appears in many of the examples for other components and EIP patterns, as well in
            this Camel documentation. So feel free to browse the documentation. If you have time,
            check out the this tutorial that uses JMS but focuses on how well Spring Remoting and
            Camel works together <a class="link" href="http://camel.apache.org/tutorial-jmsremoting.html" target="_top">Tutorial-JmsRemoting</a>.</p></div><div class="refsection"><a name="JMS_HSH_UsingJMSasaDeadLetterQueuestoringExchange"></a><h2>Using JMS as a Dead Letter Queue storing Exchange</h2><p>Normally, when using <a class="link" href="jms.html" title="JMS">JMS</a> as the transport, it only
            transfers the body and headers as the payload. If you want to use <a class="link" href="jms.html" title="JMS">JMS</a> 
            with a <a class="link" href="http://camel.apache.org/dead-letter-channel.html" target="_top">Dead
                Letter Channel</a>, using a JMS queue as the Dead Letter Queue, then normally the
            caused Exception is not stored in the JMS message. You can, however, use the <span class="bold"><strong>transferExchange</strong></span> option on the JMS dead letter queue to
            instruct Camel to store the entire <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> in the queue
            as a <code class="literal">javax.jms.ObjectMessage</code> that holds a
                <code class="literal">org.apache.camel.impl.DefaultExchangeHolder</code>. This allows you to
            consume from the Dead Letter Queue and retrieve the caused exception from the Exchange
            property with the key <code class="literal">Exchange.EXCEPTION_CAUGHT</code>. The demo below
            illustrates this:</p><pre class="programlisting">
// setup error handler to use JMS as queue and store the entire Exchange
errorHandler(deadLetterChannel("jms:queue:dead?transferExchange=true"));
</pre><p>Then you can consume from the JMS queue and analyze the problem:</p><pre class="programlisting">
from("jms:queue:dead").to("bean:myErrorAnalyzer");

// and in our bean
String body = exchange.getIn().getBody();
Exception cause = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class);
// the cause message is
String problem = cause.getMessage();
</pre></div><div class="refsection"><a name="JMS_HSH_UsingJMSasaDeadLetterChannelstoringerroronly"></a><h2>Using JMS as a Dead Letter Channel storing error only</h2><p>You can use JMS to store the cause error message or to store a custom body, which you
            can initialize yourself. The following example uses the <a class="link" href="http://camel.apache.org/message-translator.html" target="_top">Message Translator</a> EIP to do a transformation on
            the failed exchange before it is moved to the <a class="link" href="jms.html" title="JMS">JMS</a>
            dead letter queue:</p><pre class="programlisting">
// we sent it to a seda dead queue first
errorHandler(deadLetterChannel("seda:dead"));

// and on the seda dead queue we can do the custom transformation before its sent to the JMS queue
from("seda:dead").transform(exceptionMessage()).to("jms:queue:dead");
</pre><p>Here we only store the original cause error message in the transform. You can,
            however, use any <a class="link" href="http://camel.apache.org/expression.html" target="_top">Expression</a> to send whatever you like.
            For example, you can invoke a method on a Bean or use a custom processor.</p></div><div class="refsection"><a name="JMS_HSH_SendinganInOnlymessageandkeepingtheJMSReplyToheader"></a><h2>Sending an InOnly message and keeping the JMSReplyTo header</h2><p>When sending to a <a class="link" href="jms.html" title="JMS">JMS</a> destination using <span class="bold"><strong>camel-jms</strong></span> the producer will use the MEP to detect if its
            InOnly or InOut messaging. However there can be times where you want to send an InOnly
            message but keeping the JMSReplyTo header. To do so you have to instruct Camel to keep
            it, otherwise the JMSReplyTo header will be dropped.</p><p>For example to send an InOnly message to the foo queue, but with a JMSReplyTo with bar
            queue you can do as follows:</p><pre class="programlisting">
        template.send("activemq:queue:foo?preserveMessageQos=true", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody("World");
                exchange.getIn().setHeader("JMSReplyTo", "bar");
            }
        });
</pre><p>Notice we use <code class="literal">preserveMessageQos=true</code> to instruct Camel to keep the
            JMSReplyTo header.</p></div><div class="refsection"><a name="JMS_HSH_SettingJMSprovideroptionsonthedestination"></a><h2>Setting JMS provider options on the destination</h2><p>Some JMS providers, like IBM's WebSphere MQ need options to be set on the JMS
            destination. For example, you may need to specify the targetClient option. Since
            targetClient is a WebSphere MQ option and not a Camel URI option, you need to set that
            on the JMS destination name like so:</p><pre class="programlisting">
...
.setHeader("CamelJmsDestinationName", constant("queue:///MY_QUEUE?targetClient=1"))
.to("wmq:queue:MY_QUEUE?useMessageIDAsCorrelationID=true");
</pre><p>Some versions of WMQ won't accept this option on the destination name and you will get
            an exception like:</p><div class="blockquote"><blockquote class="blockquote"><p>com.ibm.msg.client.jms.DetailedJMSException: JMSCC0005: The specified value
                'MY_QUEUE?targetClient=1' is not allowed for 'XMSC_DESTINATION_NAME'</p></blockquote></div><p>A workaround is to use a custom DestinationResolver:</p><pre class="programlisting">
JmsComponent wmq = new JmsComponent(connectionFactory);

wmq.setDestinationResolver(new DestinationResolver(){
    public Destination resolveDestinationName(Session session, String destinationName, boolean pubSubDomain) throws JMSException {
        MQQueueSession wmqSession = (MQQueueSession) session;
        return wmqSession.createQueue("queue:///" + destinationName + "?targetClient=1");
    }
});
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <a class="link" href="http://camel.apache.org/transactional-client.html" target="_top">Transactional Client</a>
                </p></li><li class="listitem"><p>
                    <a class="link" href="http://camel.apache.org/bean-integration.html" target="_top">Bean Integration</a>
                </p></li><li class="listitem"><p>
                    <a class="link" href="Tutorial-JmsRemoting" target="_top">Tutorial-JmsRemoting</a>
                </p></li><li class="listitem"><p>
                    <a class="link" href="http://activemq.apache.org/jmstemplate-gotchas.html" target="_top">JMSTemplate
                        gotchas</a>
                </p></li></ul></div></div><div class="refsection"><a name="d0e45982"></a><h2>Related topics</h2><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <a class="xref" href="ActiveMQ.html" title="ActiveMQ">ActiveMQ</a>
            </td></tr><tr><td>
                <a class="xref" href="amqp.html" title="AMQP">AMQP</a>
            </td></tr></table></div></div></body></html>