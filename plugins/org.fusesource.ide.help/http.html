<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HTTP</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="RiderHTTPEptRef.html" title="HTTP Endpoints"><link rel="prev" href="RiderHTTPEptRef.html" title="HTTP Endpoints"><link rel="next" href="http4.html" title="HTTP4"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="http"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>HTTP &#8212; provides endpoints for consuming external HTTP resources</p></div><div class="refsection"><a name="d0e34907"></a><h2>Overview</h2><p>The HTTP component provides HTTP based endpoints for consuming external HTTP resources
            as a client to call external servers using HTTP.</p><p>The HTTP component can only send messages to external resources. It should never be
            used as input into a route. To expose an HTTP endpoint via a HTTP server as input to a
            route, you can use the Jetty Component.</p></div><div class="refsection"><a name="d0e34914"></a><h2>URI format</h2><p>The URI format for an HTTP endpoint is:</p><pre class="programlisting">http:hostname[:port][/resourceUri][?param1=value1][&amp;param2=value2]</pre><p>By default the port is set to <code class="code">80</code> for HTTP and to <code class="code">443</code> for
            HTTPS.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>You can produce only to endpoints generated by the HTTP component. Therefore it
                should never be used as input into your camel Routes. To bind/expose an HTTP
                endpoint via a HTTP server as input to a camel route, you can use the Jetty
                Component or the Servlet component. </p></td></tr></table></div></div><div class="refsection"><a name="d0e34932"></a><h2>Dependencies</h2><p>Maven users will need to add a dependency on <code class="code">camel-http</code> to their
                <code class="filename">pom.xml</code> for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-http<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre></div><div class="refsection"><a name="HTTPExamples"></a><h2>Examples</h2><p>Call the url with the body using POST and return response as out message. If body is
            null call URL using GET and return response as out message</p><table id="d0e34950"><tr>
                <th>Java DSL</th>
                <th>Spring DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">from("direct:start")
  .to("http://myhost/mypath");
</pre>
                </td>
                <td>
                    <pre class="programlisting">&lt;from uri="direct:start"/&gt;
&lt;to uri="http://oldhost"/&gt;
</pre>
                </td>
            </tr></table><p>You can override the HTTP endpoint URI by adding a header. Camel will call the <a class="link" href="http://newhost" target="_top">http://newhost</a>. This is very handy for e.g. REST
            urls.</p><table id="d0e34978"><tr>
                <th>Java DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">from("direct:start")
  .setHeader(Exchange.HTTP_URI, simple("http://myserver/orders/${header.orderId}"))
  .to("http://dummyhost");
</pre>
                </td>
            </tr></table><p>URI parameters can either be set directly on the endpoint URI or as a header</p><table id="d0e34994"><tr>
                <th>Java DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">
from("direct:start")
  .to("http://oldhost?order=123&amp;detail=short");
from("direct:start")
  .setHeader(Exchange.HTTP_QUERY, constant("order=123&amp;detail=short"))
  .to("http://oldhost");
</pre>
                </td>
            </tr></table><p>Set the HTTP request method to POST</p><table id="d0e35010"><tr>
                <th>Java DSL</th>
                <th>Spring DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">from("direct:start")
  .setHeader(Exchange.HTTP_METHOD, constant("POST"))
  .to("http://www.google.com");
</pre>
                </td>
                <td>
                    <pre class="programlisting">
&lt;from uri="direct:start"/&gt;
&lt;setHeader headerName="CamelHttpMethod"&gt;
  &lt;constant&gt;POST&lt;/constant&gt;
&lt;/setHeader&gt;
&lt;to uri="http://www.google.com"/&gt;
&lt;to uri="mock:results"/&gt;
</pre>
                </td>
            </tr></table></div><div class="refsection"><a name="d0e35033"></a><h2>Options</h2><p><a class="xref" href="http.html#HTTPRefOptsTbl" title="Table&nbsp;23.&nbsp;HTTP endpoint options">Table&nbsp;23, &#8220;HTTP endpoint options&#8221;</a> lists the options for an HTTP endpoint.</p><div class="table"><a name="HTTPRefOptsTbl"></a><p class="title"><b>Table&nbsp;23.&nbsp;HTTP endpoint options</b></p><div class="table-contents"><table summary="HTTP endpoint options" width="100%" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Name</th><th>Default </th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="literal">throwExceptionOnFailure</code>
                        </td><td>
                            <code class="literal">true</code>
                        </td><td> Option to disable throwing the
                                <code class="literal">HttpOperationFailedException</code> in case of failed
                            responses from the remote server. This allows you to get all responses
                            regardless of the HTTP status code. </td></tr><tr><td>
                            <code class="literal">bridgeEndpoint</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>
                            <p> If the option is true , HttpProducer will ignore the
                                Exchange.HTTP_URI header, and use the endpoint's URI for request.
                                You may also set the <span class="bold"><strong>throwExceptionOnFailure</strong></span> to be false to let the
                                HttpProducer send all the fault response back. <span class="bold"><strong>Camel 2.3:</strong></span> If the option is true, HttpProducer and
                                CamelServlet will skip the gzip processing if the content-encoding
                                is "gzip". </p>
                        </td></tr><tr><td>
                            <code class="literal">disableStreamCache</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td> DefaultHttpBinding will copy the request input stream into a stream
                            cache and put it into message body if this option is false to support
                            read it twice, otherwise DefaultHttpBinding will set the request input
                            stream direct into the message body. </td></tr><tr><td>
                            <code class="literal">httpBindingRef</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <span class="bold"><strong>Deprecated and will be removed in Camel
                                3.0:</strong></span> Reference to a
                                <code class="literal">org.apache.camel.component.http.HttpBinding</code> in
                            the <a class="link" href="http://camel.apache.org/registry.html" target="_top">Registry</a>. Use the
                                <code class="literal">httpBinding</code> option instead. </td></tr><tr><td>
                            <code class="literal">httpBinding</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> Reference to a
                                <code class="literal">org.apache.camel.component.http.HttpBinding</code> in
                            the <a class="link" href="http://camel.apache.org/registry.html" target="_top">Registry</a>. </td></tr><tr><td>
                            <code class="literal">httpClientConfigurerRef</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td>
                            <span class="bold"><strong>Deprecated and will be removed in Camel
                                3.0:</strong></span> Reference to a
                                <code class="literal">org.apache.camel.component.http.HttpClientConfigurer</code>
                            in the <a class="link" href="http://camel.apache.org/registry.html" target="_top">Registry</a>. Use the
                                <code class="literal">httpClientConfigurer</code> option instead. </td></tr><tr><td>
                            <code class="literal">httpClientConfigurer</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> Reference to a
                                <code class="literal">org.apache.camel.component.http.HttpClientConfigurer</code>
                            in the <a class="link" href="http://camel.apache.org/registry.html" target="_top">Registry</a>. </td></tr><tr><td>
                            <code class="literal">httpClient.XXX</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> Setting options on the <a class="link" href="http://hc.apache.org/httpclient-3.x/apidocs/org/apache/commons/httpclient/params/HttpClientParams.html" target="_top">HttpClientParams</a>. For instance
                                <code class="literal">httpClient.soTimeout=5000</code> will set the
                                <code class="literal">SO_TIMEOUT</code> to 5 seconds. </td></tr><tr><td>
                            <code class="literal">clientConnectionManager</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> To use a custom
                                <code class="literal">org.apache.http.conn.ClientConnectionManager</code>.
                        </td></tr><tr><td>
                            <code class="literal">transferException</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td><span class="bold"><strong>Camel 2.6:</strong></span> If enabled and an <a class="link" href="http://camel.apache.org/exchange.html" target="_top">Exchange</a> failed processing on the consumer
                            side, and if the caused <code class="literal">Exception</code> was send back
                            serialized in the response as a
                                <code class="literal">application/x-java-serialized-object</code> content type
                            (for example using <a class="link" href="jetty.html" title="Jetty">Jetty</a> or <a class="link" href="servlet.html" title="Servlet">Servlet</a> Camel components). On the
                            producer side the exception will be deserialized and thrown as is,
                            instead of the <code class="literal">HttpOperationFailedException</code>. The
                            caused exception is required to be serialized. </td></tr><tr><td>
                            <code class="literal">headerFilterStrategy</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td><span class="bold"><strong>Camel 2.11:</strong></span> Reference to a instance
                            of <code class="literal">org.apache.camel.spi.HeaderFilterStrategy</code> in the
                            <a class="link" href="http://camel.apache.org/registry.html" target="_top">Registry</a>. It will be used to apply
                            the custom headerFilterStrategy on the new create HttpEndpoint. </td></tr><tr><td>
                            <code class="literal">urlRewrite</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>Producer only</strong></span> Refers to a custom
                                <code class="literal">org.apache.camel.component.http.UrlRewrite</code> which
                            allows you to rewrite urls when you bridge/proxy endpoints. See more
                            details at <a class="link" href="http://camel.apache.org/urlrewrite.html" target="_top">UrlRewrite</a> and 
                                <a class="link" href="http://camel.apache.org/how-to-use-camel-as-a-http-proxy-between-a-client-and-server.html" target="_top">How to use Camel as a HTTP proxy between a client and
                            server</a>. </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="d0e35309"></a><h2>Authentication options</h2><p>The following authentication options can also be set on the HTTP endpoint:</p><div class="table"><a name="d0e35314"></a><p class="title"><b>Table&nbsp;24.&nbsp;HTTP authentication options</b></p><div class="table-contents"><table summary="HTTP authentication options" width="100%" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="code">authMethod</code>
                        </td><td>
                            <p>Specifies the authentication method to use. Supported methods
                                are:</p>
                            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        <code class="code">Basic</code>
                                    </p></li><li class="listitem"><p>
                                        <code class="code">Digest</code>
                                    </p></li><li class="listitem"><p>
                                        <code class="code">NTLM</code>
                                    </p></li></ul></div>
                        </td></tr><tr><td>
                            <code class="code">authMethodPriority</code>
                        </td><td>Specifies the priority of the authentication methods using a comma
                            seperated list.</td></tr><tr><td>
                            <code class="code">authUsername</code>
                        </td><td>Specifies the username for authentication.</td></tr><tr><td>
                            <code class="code">authPassword</code>
                        </td><td>Specifies the password for authentication.</td></tr><tr><td>
                            <code class="code">authDomain</code>
                        </td><td>Specifies the domain for NTML authentication.</td></tr><tr><td>
                            <code class="code">authHost</code>
                        </td><td>Specifies an optional host for NTML authentication.</td></tr><tr><td>
                            <code class="code">proxyHost</code>
                        </td><td>Specifies the proxy host name.</td></tr><tr><td>
                            <code class="code">proxyPort</code>
                        </td><td>Specifies the proxy port number.</td></tr><tr><td>
                            <code class="code">proxyAuthMethod</code>
                        </td><td>
                            <p>Specifies the authentication method to use for connecting to the
                                proxy. Supported methods are:</p>
                            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                        <code class="code">Basic</code>
                                    </p></li><li class="listitem"><p>
                                        <code class="code">Digest</code>
                                    </p></li><li class="listitem"><p>
                                        <code class="code">NTLM</code>
                                    </p></li></ul></div>
                        </td></tr><tr><td>
                            <code class="code">proxyAuthUsername</code>
                        </td><td>Specifies the username for proxy authentication.</td></tr><tr><td>
                            <code class="code">proxyAuthPassword</code>
                        </td><td>Specifies the password for proxy authentication.</td></tr><tr><td>
                            <code class="code">proxyAuthDomain</code>
                        </td><td>Specifies the domain for proxy NTML authentication.</td></tr><tr><td>
                            <code class="code">proxyAuthHost</code>
                        </td><td>Specifies the optional host for proxy NTML authentication.</td></tr></tbody></table></div></div><br class="table-break"><p>When using authentication you must provide a value for either the
                <code class="literal">authMethod</code> or <code class="literal">authProxyMethod</code> options. You can
            configure the proxy and authentication details on either the
                <code class="literal">HttpComponent</code> or the <code class="literal">HttpEndoint</code>. Values
            provided on the <code class="literal">HttpEndpoint</code> take precedence over
                <code class="literal">HttpComponent</code>. It's probably best to configure this on the
                <code class="literal">HttpComponent</code>, which allows you to do it just once.</p><p>The HTTP component uses convention over
            configuration, which means that, if you have not explicitly set an
                <code class="literal">authMethodPriority</code>, it will fallback to using the select(ed)
                <code class="literal">authMethod</code> as priority as well. So, if you use
                <code class="literal">authMethod.Basic</code>, the <code class="literal">auhtMethodPriority</code> will
            be <code class="literal">Basic</code> too.</p></div><div class="refsection"><a name="HttpComponentOptions"></a><h2>Http component options</h2><div class="table"><a name="d0e35518"></a><p class="title"><b>Table&nbsp;25.&nbsp;HTTP component options</b></p><div class="table-contents"><table summary="HTTP component options" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th> Name </th><th> Default  </th><th> Description </th></tr></thead><tbody><tr><td>
                            <code class="literal">httpBinding</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> To use a custom
                                <code class="literal">org.apache.camel.component.http.HttpBinding</code>.
                        </td></tr><tr><td>
                            <code class="literal">httpClientConfigurer</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> To use a custom
                                <code class="literal">org.apache.camel.component.http.HttpClientConfigurer</code>.
                        </td></tr><tr><td>
                            <code class="literal">httpConnectionManager</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> To use a custom
                                <code class="literal">org.apache.commons.httpclient.HttpConnectionManager</code>.
                        </td></tr><tr><td>
                            <code class="literal">httpConfiguration</code>
                        </td><td>
                            <code class="literal">null</code>
                        </td><td> To use a custom
                                <code class="literal">org.apache.camel.component.http.HttpConfiguration</code>
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="d0e35595"></a><h2>Message headers</h2><p>The following <code class="code">Exchange</code> properties are recognized by HTTP
            endpoints:</p><div class="table"><a name="d0e35603"></a><p class="title"><b>Table&nbsp;26.&nbsp;HTTP Exchange properties</b></p><div class="table-contents"><table summary="HTTP Exchange properties" width="100%" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="literal">Exchange.HTTP_URI</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> URI to call. Will override existing URI set directly on the
                            endpoint. </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_METHOD</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> HTTP Method / Verb to use (GET/POST/PUT/DELETE/HEAD/OPTIONS/TRACE)
                        </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_PATH</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> Request URI's path, the header will be used to build the request URI
                            with the HTTP_URI. <span class="bold"><strong>Camel 2.3.0:</strong></span> If the
                            path is start with "/", http producer will try to find the relative path
                            based on the Exchange.HTTP_BASE_URI header or the
                            exchange.getFromEndpoint().getEndpointUri(); </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_QUERY</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> URI parameters. Will override existing URI parameters set directly
                            on the endpoint. </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_RESPONSE_CODE</code>
                        </td><td>
                            <code class="literal">int</code>
                        </td><td> The HTTP response code from the external server. Is 200 for OK.
                        </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_CHARACTER_ENCODING</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> Character encoding. </td></tr><tr><td>
                            <code class="literal">Exchange.CONTENT_TYPE</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> The HTTP content type. Is set on both the IN and OUT message to
                            provide a content type, such as <code class="literal">text/html</code>. </td></tr><tr><td>
                            <code class="literal">Exchange.CONTENT_ENCODING</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td> The HTTP content encoding. Is set on both the IN and OUT message to
                            provide a content encoding, such as <code class="literal">gzip</code>. </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_SERVLET_REQUEST</code>
                        </td><td>
                            <code class="literal">HttpServletRequest</code>
                        </td><td> The <code class="literal">HttpServletRequest</code> object. </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_SERVLET_RESPONSE</code>
                        </td><td>
                            <code class="literal">HttpServletResponse</code>
                        </td><td> The <code class="literal">HttpServletResponse</code> object. </td></tr><tr><td>
                            <code class="literal">Exchange.HTTP_PROTOCOL_VERSION</code>
                        </td><td>
                            <code class="literal">String</code>
                        </td><td><span class="bold"><strong>Camel 2.5:</strong></span> You can set the http
                            protocol version with this header, eg. "HTTP/1.0". If you didn't specify
                            the header, HttpProducer will use the default value "HTTP/1.1" </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="d0e35776"></a><h2>Message Body</h2><p>Apache Camel will store the HTTP response from the external server on the OUT body.
            All headers from the IN message will be copied to the OUT message, so headers are
            preserved during routing. Additionally, Apache Camel will add the HTTP response headers
            as well to the OUT message headers.</p></div><div class="refsection"><a name="d0e35781"></a><h2>Response code</h2><p>Apache Camel will handle according to the HTTP response code:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Response code is in the range 100..299, Apache Camel regards it as a success
                    response.</p></li><li class="listitem"><p>Response code is in the range 300..399, Apache Camel regards it as a
                    redirection response and will throw a
                        <code class="literal">HttpOperationFailedException</code> with the information.</p></li><li class="listitem"><p>Response code is 400+, Apache Camel regards it as an external server failure
                    and will throw a <code class="exceptionname">HttpOperationFailedException</code>
                    with the information. <code class="code">throwExceptionOnFailure</code> can be set to
                        <code class="literal">false</code> to prevent the
                        <code class="exceptionname">HttpOperationFailedException</code> from being
                    thrown for failed response codes. This allows you to get any response from the
                    remote server.</p></li></ul></div></div><div class="refsection"><a name="HttpOperationFailedException"></a><h2>HttpOperationFailedException</h2><p>This exception contains the following information:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The HTTP status code</p></li><li class="listitem"><p>The HTTP status line (text of the status code)</p></li><li class="listitem"><p>Redirect location, if server returned a redirect</p></li><li class="listitem"><p>Response body as a <code class="literal">java.lang.String</code>, if server provided a
                    body as response</p></li></ul></div></div><div class="refsection"><a name="HttpCallingusingGETorPOST"></a><h2>Calling using GET or POST</h2><p>The following algorithm is used to determine if either <code class="literal">GET</code> or
                <code class="literal">POST</code> HTTP method should be used: 1. Use method provided in
            header. 2. <code class="literal">GET</code> if query string is provided in header. 3.
                <code class="literal">GET</code> if endpoint is configured with a query string. 4.
                <code class="literal">POST</code> if there is data to send (body is not null). 5.
                <code class="literal">GET</code> otherwise.</p></div><div class="refsection"><a name="HttpHowtogetaccesstoHttpServletRequestandHttpServletResponse"></a><h2>How to get access to HttpServletRequest and HttpServletResponse</h2><p>You can get access to these two using the Camel type converter system using</p><pre class="programlisting">
HttpServletRequest request = exchange.getIn().getBody(HttpServletRequest.class);
HttpServletRequest response = exchange.getIn().getBody(HttpServletResponse.class);
</pre></div><div class="refsection"><a name="HttpUsingclienttimeoutSOTIMEOUT"></a><h2>Using client timeout - SO_TIMEOUT</h2><p>See the unit test in <a class="link" href="http://svn.apache.org/viewvc?view=rev&amp;revision=781775" target="_top">this link</a>
        </p></div><div class="refsection"><a name="HttpConfiguringaProxy"></a><h2>Configuring a Proxy</h2><table id="d0e35873"><tr>
                <th>Java DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">from("direct:start")
  .to("http://oldhost?proxyHost=www.myproxy.com&amp;proxyPort=80");
</pre>
                </td>
            </tr></table><p>There is also support for proxy authentication via the
                <code class="literal">proxyUsername</code> and <code class="literal">proxyPassword</code>
            options.</p></div><div class="refsection"><a name="HttpUsingproxysettingsoutsideofURI"></a><h2>Using proxy settings outside of URI</h2><table id="d0e35898"><tr>
                <th>Java DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">
 context.getProperties().put("http.proxyHost", "172.168.18.9");
 context.getProperties().put("http.proxyPort" "8080");
</pre>
                </td>
            </tr></table><table id="d0e35912"><tr>
                <th>Spring DSL</th>
            </tr><tr>
                <td>
                    <pre class="programlisting">
   &lt;camelContext&gt;
       &lt;properties&gt;
           &lt;property key="http.proxyHost" value="172.168.18.9"/&gt;
           &lt;property key="http.proxyPort" value="8080"/&gt;
      &lt;/properties&gt;
   &lt;/camelContext&gt;
</pre>
                </td>
            </tr></table><p>Options on Endpoint will override options on the context.</p></div><div class="refsection"><a name="HttpConfiguringcharset"></a><h2>Configuring charset</h2><p>If you are using <code class="literal">POST</code> to send data you can configure the
                <code class="literal">charset</code>
        </p><pre class="programlisting">
setProperty(Exchange.CHARSET_NAME, "iso-8859-1");
</pre></div><div class="refsection"><a name="HttpSamplewithscheduledpoll"></a><h2>Sample with scheduled poll</h2><p>The sample polls the Google homepage every 10 seconds and write the page to the file
                <code class="literal">message.html</code>:</p><pre class="programlisting">
from("timer://foo?fixedRate=true&amp;delay=0&amp;period=10000")
    .to("http://www.google.com")
    .setHeader(FileComponent.HEADER_FILE_NAME, "message.html").to("file:target/google");
</pre></div><div class="refsection"><a name="HttpGettingtheResponseCode"></a><h2>Getting the Response Code</h2><p>You can get the HTTP response code from the HTTP component by getting the value from
            the Out message header with <code class="literal">HttpProducer.HTTP_RESPONSE_CODE</code>.</p><pre class="programlisting">
   Exchange exchange = template.send("http://www.google.com/search", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setHeader(Exchange.HTTP_QUERY, constant("hl=en&amp;q=activemq"));
            }
   });
   Message out = exchange.getOut();
   int responseCode = out.getHeader(HttpProducer.HTTP_RESPONSE_CODE, Integer.class);
</pre></div><div class="refsection"><a name="HttpUsingthrowExceptionOnFailurefalsetogetanyresponseback"></a><h2>Using <code class="literal">throwExceptionOnFailure=false</code> to get any response
            back</h2><p>In the route below we want to route a message that we enrich with data returned from a
            remote HTTP call. As we want any response from the remote server, we set the
                <code class="literal">throwExceptionOnFailure</code> option to <code class="literal">false</code> so we
            get any response in the <code class="literal">AggregationStrategy</code>. As the code is based on
            a unit test that simulates a HTTP status code 404, there is some assertion code
            etc.</p><pre class="programlisting">// We set throwExceptionOnFailure to false to let Camel return any response from the remove HTTP server without thrown
// HttpOperationFailedException in case of failures.
// This allows us to handle all responses in the aggregation strategy where we can check the HTTP response code
// and decide what to do. As this is based on an unit test we assert the code is 404
from("direct:start").enrich("http://localhost:{{port}}/myserver?throwExceptionOnFailure=false&amp;user=Camel", new AggregationStrategy() {
    public Exchange aggregate(Exchange original, Exchange resource) {
        // get the response code
        Integer code = resource.getIn().getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);
        assertEquals(404, code.intValue());
        return resource;
    }
}).to("mock:result");

// this is our jetty server where we simulate the 404
from("jetty://http://localhost:{{port}}/myserver")
        .process(new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getOut().setBody("Page not found");
                exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, 404);
            }
        });
</pre></div><div class="refsection"><a name="HttpDisablingCookies"></a><h2>Disabling Cookies</h2><p>To disable cookies you can set the HTTP Client to ignore cookies by adding this URI
            option: <code class="literal">httpClient.cookiePolicy=ignoreCookies</code>
        </p></div><div class="refsection"><a name="HttpAdvancedUsage"></a><h2>Advanced Usage</h2><p>If you need more control over the HTTP producer you should use the
                <code class="literal">HttpComponent</code> where you can set various classes to give you
            custom behavior.</p></div><div class="refsection"><a name="HttpSettingMaxConnectionsPerHost"></a><h2>Setting MaxConnectionsPerHost</h2><p>The HTTP Component has a
                <code class="literal">org.apache.commons.httpclient.HttpConnectionManager</code> where you can
            configure various global configuration for the given component. By global, we mean that
            any endpoint the component creates has the same shared
                <code class="literal">HttpConnectionManager</code>. So, if we want to set a different value
            for the max connection per host, we need to define it on the HTTP component and
                <span class="bold"><strong>not</strong></span> on the endpoint URI that we usually use. So
            here comes:</p><p>First, we define the <code class="literal">http</code> component in Spring XML. Yes, we use the
            same scheme name, <code class="literal">http</code>, because otherwise Camel will auto-discover
            and create the component with default settings. What we need is to overrule this so we
            can set our options. In the sample below we set the max connection to 5 instead of the
            default of 2.</p><pre class="programlisting">&lt;bean id="http" class="org.apache.camel.component.http.HttpComponent"&gt;
    &lt;property name="camelContext" ref="camel"/&gt;
    &lt;property name="httpConnectionManager" ref="myHttpConnectionManager"/&gt;
&lt;/bean&gt;

&lt;bean id="myHttpConnectionManager" class="org.apache.commons.httpclient.MultiThreadedHttpConnectionManager"&gt;
    &lt;property name="params" ref="myHttpConnectionManagerParams"/&gt;
&lt;/bean&gt;

&lt;bean id="myHttpConnectionManagerParams" class="org.apache.commons.httpclient.params.HttpConnectionManagerParams"&gt;
    &lt;property name="defaultMaxConnectionsPerHost" value="5"/&gt;
&lt;/bean&gt;

</pre><p>And then we can just use it as we normally do in our routes:</p><pre class="programlisting">&lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring" trace="true"&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;to uri="http://www.google.com"/&gt;
        &lt;to uri="mock:result"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;
</pre></div><div class="refsection"><a name="HttpUsingpreemptiveauthentication"></a><h2>Using preemptive authentication</h2><p>An end user reported that he had problem with authenticating with HTTPS. The problem
            was eventually resolved when he discovered the HTTPS server did not return a HTTP code
            401 Authorization Required. The solution was to set the following URI option:
                <code class="literal">httpClient.authenticationPreemptive=true</code>
        </p></div><div class="refsection"><a name="HttpAcceptingselfsignedcertificatesfromremoteserver"></a><h2>Accepting self signed certificates from remote server</h2><p>See this <a class="link" href="http://www.nabble.com/Using-HTTPS-in-camel-http-when-remote-side-has-self-signed-cert-td25916878.html" target="_top">link</a> from a mailing list discussion with some code to outline how to do this
            with the Apache Commons HTTP API.</p></div><div class="refsection"><a name="HttpUsingtheJSSEConfigurationUtility"></a><h2>Using the JSSE Configuration Utility</h2><p>As of Camel 2.8, the HTTP4 component supports SSL/TLS configuration through the Camel
            JSSE Configuration Utility. This utility greatly decreases the amount of component
            specific code you need to write and is configurable at the endpoint and component
            levels. The following examples demonstrate how to use the utility with the HTTP4
            component.</p><p>The version of the Apache HTTP client used in this component resolves SSL/TLS
            information from a global "protocol" registry. This component provides an
            implementation,
                <code class="literal">org.apache.camel.component.http.SSLContextParametersSecureProtocolSocketFactory</code>,
            of the HTTP client's protocol socket factory in order to support the use of the Camel
            JSSE Configuration utility. The following example demonstrates how to configure the
            protocol registry and use the registered protocol information in a route.</p><pre class="programlisting">
KeyStoreParameters ksp = new KeyStoreParameters();
ksp.setResource("/users/home/server/keystore.jks");
ksp.setPassword("keystorePassword");

KeyManagersParameters kmp = new KeyManagersParameters();
kmp.setKeyStore(ksp);
kmp.setKeyPassword("keyPassword");

SSLContextParameters scp = new SSLContextParameters();
scp.setKeyManagers(kmp);

ProtocolSocketFactory factory =
    new SSLContextParametersSecureProtocolSocketFactory(scp);

Protocol.registerProtocol("https",
        new Protocol(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "https",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; factory,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 443));

from("direct:start")
        .to("https://mail.google.com/mail/").to("mock:results");
</pre></div><div class="refsection"><a name="HttpConfiguringApacheHTTPClientDirectly"></a><h2>Configuring Apache HTTP Client Directly</h2><p>Basically camel-http component is built on the top of Apache HTTP client, and you can
            implement a custom
                <code class="literal">org.apache.camel.component.http.HttpClientConfigurer</code> to do some
            configuration on the http client if you need full control of it.</p><p>However if you <span class="emphasis"><em>just</em></span> want to specify the keystore and truststore
            you can do this with Apache HTTP <code class="literal">HttpClientConfigurer</code>, for
            example:</p><pre class="programlisting">
Protocol authhttps = new Protocol("https", new AuthSSLProtocolSocketFactory(
  new URL("file:my.keystore"), "mypassword",
  new URL("file:my.truststore"), "mypassword"), 443);

Protocol.registerProtocol("https", authhttps);
</pre><p>And then you need to create a class that implements
                <code class="literal">HttpClientConfigurer</code>, and registers https protocol providing a
            keystore or truststore per example above. Then, from your camel route builder class you
            can hook it up like so:</p><pre class="programlisting">
HttpComponent httpComponent = getContext().getComponent("http", HttpComponent.class);
httpComponent.setHttpClientConfigurer(new MyHttpClientConfigurer());
</pre><p>If you are doing this using the Spring DSL, you can specify your
                <code class="literal">HttpClientConfigurer</code> using the URI. For example:</p><pre class="programlisting">
&lt;bean id="myHttpClientConfigurer"
 class="my.https.HttpClientConfigurer"&gt;
&lt;/bean&gt;

&lt;to uri="https://myhostname.com:443/myURL?httpClientConfigurerRef=myHttpClientConfigurer"/&gt;
</pre><p>As long as you implement the HttpClientConfigurer and configure your keystore and
            truststore as described above, it will work fine.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Jetty </p></li></ul></div></div><div class="refsection"><a name="d0e36090"></a><h2>Related topics</h2><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <a class="link" href="http4.html" title="HTTP4">HTT4</a>
            </td></tr><tr><td>
                <a class="link" href="jetty.html" title="Jetty">Jetty</a>
            </td></tr><tr><td>
                <a class="link" href="http://hc.apache.org/httpclient-3.x/apidocs/org/apache/commons/httpclient/params/HttpClientParams.html" target="_top">HttpClientParams</a>
            </td></tr></table></div></div></body></html>